<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Unidad 4 Cadenas de Markov de Tiempo Contínuo | Simulación de Procesos y Sistemas</title>
<meta name="description" content="En esta unidad, consideramos un sistema estocástico que se observa continuamente a lo largo del tiempo, siendo \(X_t\) el estado en el momento \(t\), con \(t \geq 0\). Siguiendo la definición de...">
<meta name="generator" content="bookdown 0.26 with bs4_book()">
<meta property="og:title" content="Unidad 4 Cadenas de Markov de Tiempo Contínuo | Simulación de Procesos y Sistemas">
<meta property="og:type" content="book">
<meta property="og:description" content="En esta unidad, consideramos un sistema estocástico que se observa continuamente a lo largo del tiempo, siendo \(X_t\) el estado en el momento \(t\), con \(t \geq 0\). Siguiendo la definición de...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unidad 4 Cadenas de Markov de Tiempo Contínuo | Simulación de Procesos y Sistemas">
<meta name="twitter:description" content="En esta unidad, consideramos un sistema estocástico que se observa continuamente a lo largo del tiempo, siendo \(X_t\) el estado en el momento \(t\), con \(t \geq 0\). Siguiendo la definición de...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
<link rel="stylesheet" href="bs4_style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Simulación de Procesos y Sistemas</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Antes de comenzar</a></li>
<li><a class="" href="software.html">Software</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> Conceptos básicos</a></li>
<li><a class="" href="cmtd.html"><span class="header-section-number">2</span> Cadenas de Markov de Tiempo Discreto</a></li>
<li><a class="" href="poissonprocess.html"><span class="header-section-number">3</span> Proceso de Poisson</a></li>
<li><a class="active" href="CMTC.html"><span class="header-section-number">4</span> Cadenas de Markov de Tiempo Contínuo</a></li>
<li><a class="" href="COLAS.html"><span class="header-section-number">5</span> Sistemas de colas</a></li>
<li><a class="" href="SIMSIST.html"><span class="header-section-number">6</span> Aplicaciones prácticas</a></li>
<li><a class="" href="simmerunidad.html"><span class="header-section-number">7</span> Simulación DES con simmer</a></li>
<li><a class="" href="bibliograf%C3%ADa.html">Bibliografía</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="CMTC" class="section level1" number="4">
<h1>
<span class="header-section-number">Unidad 4</span> Cadenas de Markov de Tiempo Contínuo<a class="anchor" aria-label="anchor" href="#CMTC"><i class="fas fa-link"></i></a>
</h1>
<p>En esta unidad, consideramos un sistema estocástico que se observa continuamente a lo largo del tiempo, siendo <span class="math inline">\(X_t\)</span> el estado en el momento <span class="math inline">\(t\)</span>, con <span class="math inline">\(t \geq 0\)</span>. Siguiendo la definición de las CMTD, a continuación definimos las cadenas de Markov de tiempo continuo (CMTC).</p>
<div class="yellowbox">
<div class="definition">
<p><span id="def:cmtc001" class="definition"><strong>Definición 4.1  </strong></span>Un proceso estocástico <span class="math inline">\(\{X_t; t \geq 0\}\)</span> con espacio de estados <span class="math inline">\(S\)</span> es una cadena de Markov de tiempo continuo, CMTC, si para todo <span class="math inline">\(i\)</span> y <span class="math inline">\(j\)</span> en <span class="math inline">\(S\)</span>, y <span class="math inline">\(t, s \geq 0\)</span>, cumple la propiedad de Markov:</p>
<p><span class="math display">\[P(X_{s+t} = j \mid X_s = i, X_u, 0 \leq u \leq s) = P(X_{s+t} = j \mid X_s = i).\]</span></p>
</div>
</div>
<p>La CMTC <span class="math inline">\(\{X_t; t \geq 0\}\)</span> se denomina homogénea si el cambio entre dos instantes cualesquiera depende exclusivamente del tiempo transcurrido, esto es para cualquier <span class="math inline">\(t, s \geq 0\)</span>,</p>
<p><span class="math display">\[P(X_{s+t} = j \mid X_s = i) = P(X_t = j \mid X_0 = i).\]</span></p>
<p>En toda esta unidad asumimos que las CMTC con las que trabajamos son homogéneas y tienen espacio de estados finito <span class="math inline">\(S=\{1, 2,,...,N\}\)</span> de forma que podemos definir la probabilidad de pasar del estado <span class="math inline">\(i\)</span> al estado <span class="math inline">\(j\)</span> en un periodo de amplitud <span class="math inline">\(t, (0,t],\)</span> como:</p>
<p><span class="math display">\[p_{ij}(t) = P(X_t = j \mid X_0 = i), \quad 1 \leq i, j \leq N.\]</span></p>
<p>La matriz de probabilidad de transición <span class="math inline">\(P(t)\)</span> de una CMTC <span class="math inline">\(\{X_t; t \geq 0\}\)</span> viene dada por las distribuciones de probabilidad condicionadas (por filas) de pasar de un estado <span class="math inline">\(i\)</span> a un estado <span class="math inline">\(j\)</span> en un periodo de tiempo de amplitud <span class="math inline">\(t\)</span>:</p>
<p><span class="math display">\[P(t) = 
\begin{pmatrix}
p_{11}(t) &amp; p_{12}(t) &amp; ... &amp; p_{1N}(t)\\
p_{21}(t) &amp; p_{22}(t) &amp; ... &amp; p_{2N}(t)\\
... &amp; ... &amp; ... &amp; ...\\
p_{N1}(t) &amp; p_{N2}(t) &amp; ... &amp; p_{NN}(t)
\end{pmatrix}\]</span></p>
<p>Dicha matriz de transición verifica que:</p>
<ul>
<li>Todos sus elementos son probabilidades condicionadas <span class="math inline">\(\{p_{ij}(t); j \in S\}\)</span>
</li>
</ul>
<p><span class="math display">\[1 \geq p_{ij}(t) \geq 0, \quad  1 \leq i, j \leq N; t \geq 0\]</span></p>
<ul>
<li>La suma de las probabilidades en cada fila, esto es, de acceder a cualquiera de los estados a partir de un estado <span class="math inline">\(i\)</span> es igual a 1.</li>
</ul>
<p><span class="math display">\[\sum_{j=1}^N p_{ij}(t) = 1, \quad  1 \leq i, j \leq N; t \geq 0\]</span></p>
<ul>
<li>Ecuaciones de Chapman-Kolmogorov</li>
</ul>
<p><span class="math display">\[p_{ij}(s+t) =  \sum_{k=1}^N p_{ik}(s)p_{kj}(t) =  \sum_{k=1}^N p_{ik}(t)p_{kj}(s)   , \quad  1 \leq i, j \leq N; t \geq 0\]</span></p>
<p>La dificultad principal con <span class="math inline">\(P(t)\)</span> es que resulta díficil de obtener de forma inmediata para la mayoría de las CMTC, al contrario de lo que ocurría con las CMTD. Necesitamos un método simple que nos permita describir de forma rápida el comportamiento del proceso. A continuación, sentamos las bases para el estudio de las CMTC a partir de los tiempos de permanencia en cada uno de los estados del proceso. Dado que la única distribución que verifica la propiedad de pérdida de memoria es la exponencial, la utilizaremos como base para la construcción de una CMTC.</p>
<div id="CMTCA" class="section level2" number="4.1">
<h2>
<span class="header-section-number">4.1</span> Evolución del proceso<a class="anchor" aria-label="anchor" href="#CMTCA"><i class="fas fa-link"></i></a>
</h2>
<p>Sea <span class="math inline">\(X_t\)</span> el estado de un sistema en el instante temporal <span class="math inline">\(t\)</span>. Supongamos que el espacio de estados del proceso estocástico <span class="math inline">\(\{X_t; t \geq 0\}\)</span> es <span class="math inline">\(S=\{1, 2,...,N\}\)</span>. La evolución aleatoria del sistema se produce de la siguiente manera:</p>
<ul>
<li><p>Supongamos que el sistema comienza en el estado <span class="math inline">\(i\)</span> y permanece allí durante un tiempo <span class="math inline">\(Exp(r_i)\)</span> que denominamos <strong>tiempo de permanencia</strong> en el estado <span class="math inline">\(i\)</span>, con <span class="math inline">\(r_i\)</span> la <strong>tasa media de permanencia</strong>; recordemos que en la distribución exponencial las tasas medias son el recíproco de los tiempos medios.</p></li>
<li><p>Al final del tiempo de permanencia en el estado <span class="math inline">\(i\)</span>, el sistema realiza una transición repentina al estado <span class="math inline">\(j\)</span> con probabilidad <span class="math inline">\(p_{ij}\)</span>, independientemente del tiempo que el sistema haya permanecido en el estado <span class="math inline">\(i\)</span>. Una vez en el estado <span class="math inline">\(j\)</span>, permanece allí durante un tiempo <span class="math inline">\(Exp(r_j)\)</span>.</p></li>
<li><p>A continuación pasa a un nuevo estado <span class="math inline">\(k\)</span> con una probabilidad <span class="math inline">\(p_{jk}\)</span>, independientemente de la historia del sistema hasta el momento, y repite este comportamiento hasta que finaliza el tiempo de observación del proceso.</p></li>
</ul>
<p>Conviene hacer tres observaciones con respecto al funcionamiento del sistema:</p>
<ul>
<li>En primer lugar, las probabilidades de salto <span class="math inline">\(p_{ij}\)</span> no deben deben confundirse con las probabilidades de transición <span class="math inline">\(p_{ij}(t)\)</span>. En este caso, <span class="math inline">\(p_{ij}\)</span> actúa como la probabilidad de que el sistema pase al estado <span class="math inline">\(j\)</span> cuando sale del estado <span class="math inline">\(i\)</span>.</li>
<li>En segundo lugar, <span class="math inline">\(p_{ii} = 0\)</span>, dado que, por definición, el tiempo de permanencia en el estado <span class="math inline">\(i\)</span> es el tiempo que el sistema pasa en el estado <span class="math inline">\(i\)</span> hasta que sale de él; por lo tanto, no es posible una transición de <span class="math inline">\(i\)</span> a <span class="math inline">\(i\)</span>.</li>
<li>En tercer lugar, en caso de que el estado <span class="math inline">\(i\)</span> sea absorbente, es decir que el sistema permanezca en ese estado para siempre una vez que llegue a él, fijamos <span class="math inline">\(r_i = 0\)</span>.</li>
</ul>
<p>Con estas premisas podremos obtener la <strong>matriz de probabilidades de salto</strong>, <span class="math inline">\(P\)</span>, que denotaremos como:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
p_{11} &amp; p_{12} &amp; ... &amp; p_{1N}\\
p_{21} &amp; p_{22} &amp; ... &amp; p_{2N}\\
... &amp; ... &amp; ... &amp; ...\\
p_{N1} &amp; p_{N2} &amp; ... &amp; p_{NN}
\end{pmatrix}\]</span></p>
<div class="theorem">
<p><span id="thm:thecmtc001" class="theorem"><strong>Teorema 4.1  </strong></span>El proceso estocástico <span class="math inline">\(\{X_t; t \geq 0\}\)</span> con parámetros <span class="math inline">\(r_i\)</span>, <span class="math inline">\(1 \leq i \leq N\)</span>, y probabilidades <span class="math inline">\(p_{ij}\)</span>, <span class="math inline">\(1 \leq i,j \leq N\)</span> descrito anteriormente es una CMTC.</p>
</div>
<p>A continuación presentamos un par de ejemplos.</p>
<div class="example">
<p><span id="exm:excmtc001" class="example"><strong>Ejemplo 4.1  </strong></span><strong>Sistema de vida útil de un satélite</strong>. Supongamos que la vida útil <span class="math inline">\(T\)</span> de un satélite de gran altitud es una variable aleatoria exponencial de tasa <span class="math inline">\(\mu\)</span> en meses, <span class="math inline">\(Exp(\mu)\)</span>, de forma que una vez que falla sigue fallando para siempre, ya que no es posible repararlo. Consideramos el proceso <span class="math inline">\(X_t = 1\)</span> si el satélite está operativo en el momento <span class="math inline">\(t\)</span>, y 0 en caso contrario. En esta situación <span class="math inline">\(r_0 = 0\)</span> (porque si se estropea, se queda estropeado) y <span class="math inline">\(r_1 = \mu\)</span> (que es el inverso del tiempo esperado de vida), pero desconocemos los valores de <span class="math inline">\(P\)</span>, aunque podremos obtener la matriz de transición calculando las probabilidades <span class="math inline">\(p_{00}(t)\)</span> y <span class="math inline">\(p_{11}(t)\)</span> que vienen dadas por:</p>
<p><span class="math display">\[p_{00}(t) = P(\text{satélite no está operativo en t} \mid \text{satélite no está operativo en 0}) = 1\]</span></p>
<span class="math display">\[\begin{eqnarray*}
p_{01}(t) &amp;=&amp; P(X_t=1|X_0=0) = 0 \\
p_{10}(t) &amp;=&amp; P(X_t=0|X_0=1) = Pr(T \leq t) = 1- e^{-\mu t}\\
p_{11}(t) &amp;=&amp; P(X_t=1|X_0=1) = Pr(T &gt;t) = e^{-\mu t}
\end{eqnarray*}\]</span>
<p>La matriz de transición viene dada pues por:</p>
<p><span class="math display">\[P(t) = 
\begin{pmatrix}
1 &amp; 0\\
1- e^{-\mu t} &amp; e^{-\mu t} 
\end{pmatrix}\]</span></p>
</div>
<div class="example">
<p><span id="exm:excmtc002" class="example"><strong>Ejemplo 4.2  </strong></span><strong>Sistema del viajante</strong>. Un vendedor vive en la ciudad A y es responsable de las ciudades A, B y C. El tiempo que pasa en cada ciudad es aleatorio. Tras un estudio, se ha determinado que la cantidad de tiempo consecutivo que pasa en una ciudad cualquiera sigue una variable aleatoria con distribución exponencial, cuya media de tiempo de estancia depende de la ciudad. En su ciudad natal pasa un tiempo medio de dos semanas, en la ciudad B pasa un tiempo medio de una semana, y en la ciudad C pasa un tiempo medio de una y media. Cuando sale de la ciudad A, lanza una moneda para determinar a qué ciudad va a continuación; cuando sale de la ciudad B o C, lanza dos monedas de manera que hay un 75% de posibilidades de volver a A y un 25% de posibilidades de ir a la otra ciudad. Sea <span class="math inline">\(X_t\)</span> una variable aleatoria que denota la ciudad en la que se encuentra el vendedor en el momento <span class="math inline">\(t\)</span>, de forma que toma el valor 0 si está en A, el valor 1 si está en B, y 2 si está en C.</p>
</div>
<p>El proceso <span class="math inline">\(\{X_t; t \geq 0\}\)</span> con espacio de estados <span class="math inline">\(\{0, 1, 2\}\)</span> es una CMTC con:</p>
<ul>
<li>tasas de permanecia (en semanas): <span class="math inline">\(r_0 = 1/2=0.5, r_1 = 1, r_2 = 1/1.5 =0.67\)</span> , y</li>
<li>matriz de saltos</li>
</ul>
<p><span class="math display">\[P = 
\begin{pmatrix}
0 &amp; 0.5 &amp; 0.5\\
0.75 &amp; 0 &amp; 0.25\\
0.75 &amp; 0.25 &amp; 0
\end{pmatrix}\]</span></p>
</div>
<div id="CMTCB" class="section level2" number="4.2">
<h2>
<span class="header-section-number">4.2</span> Descripción del proceso<a class="anchor" aria-label="anchor" href="#CMTCB"><i class="fas fa-link"></i></a>
</h2>
<p>En virtud del teorema <a href="CMTC.html#thm:thecmtc001">4.1</a> todas las CMTC con espacios de estado finitos que tienen tiempos de permanencia no nulos en cada estado pueden ser descritos a través de las tasas de permanencia y la matriz de saltos. En este punto detallamos este análisis e introducimos todos los conceptos necesarios para el análisis del proceso.</p>
<p>La <strong>tasa de transición</strong> de <span class="math inline">\(i\)</span> a <span class="math inline">\(j\)</span> se define como el producto de la tasa de permanencia en el estado <span class="math inline">\(i\)</span>, <span class="math inline">\(r_i\)</span>, por la probabilidad de salto al estado <span class="math inline">\(j\)</span>, <span class="math inline">\(p_{ij}\)</span></p>
<span class="math display" id="eq:tasatransicion">\[\begin{equation}
r_{ij} = r_i p_{ij}
\tag{4.1}
\end{equation}\]</span>
<p>De forma análoga a las CMTD, una CMTC también puede representarse gráficamente mediante un grafo dirigido cuyos nodos (o vértices) indican cada uno de los estados del proceso, y surge un arco dirigido del nodo <span class="math inline">\(i\)</span> al nodo <span class="math inline">\(j\)</span> si <span class="math inline">\(p_{ij} &gt; 0\)</span>; además junto a cada arco se escribe la tasa de transición <span class="math inline">\(r_{ij} = r_i p_{ij}\)</span>. Nunca habrá arcos que empiecen y acaben en el mismo nodo porque <span class="math inline">\(p_{ii}=0\)</span>. Esta representación gráfica se denomina <strong>diagrama de tasas de la CMTC</strong>.</p>
<p>Podemos entender la dinámica de una CMTC visualizando una partícula que se mueve de nodo en nodo en el diagrama de tasas de la siguiente manera: permanece en el nodo <span class="math inline">\(i\)</span> durante cierto periodo de tiempo de duración variable <span class="math inline">\(Exp(r_i)\)</span> y luego elige uno de los arcos de salida del nodo <span class="math inline">\(i\)</span> con probabilidades proporcionales a las tasas de los arcos, trasladándose al nodo que conecta dicho arco con el nodo origen <span class="math inline">\(i\)</span>. Este movimiento continúa para siempre. El nodo ocupado por la partícula en el instante <span class="math inline">\(t\)</span> es el estado de la CMTC en el instante <span class="math inline">\(t\)</span>.</p>
<p>En esta situación resulta posible obtener los valores de <span class="math inline">\(r_i\)</span> y <span class="math inline">\(p_{ij}\)</span> a partir de las tasas <span class="math inline">\(r_{ij}\)</span> dado que:</p>
<span class="math display" id="eq:probsalto">\[\begin{eqnarray}
\sum_{j=1}^{N} r_{ij} &amp;=&amp; \sum_{j=1}^{N} r_i p_{ij} = r_i \sum_{j=1}^{N} p_{ij} = r_i  \tag{4.2} \\
p_{ij} &amp;=&amp; \frac{r_{ij}}{r_i} \quad \text{ si } r_i \neq 0.
\tag{4.3} 
\end{eqnarray}\]</span>
<p>Para un mejor manejo de la información, resulta conveniente construir la <strong>matriz de tasas</strong> teniendo en cuenta que <span class="math inline">\(r_{ii} = 0\)</span> para cualquier valor de <span class="math inline">\(i\)</span>, y por tanto la diagonal de la matriz <span class="math inline">\(R\)</span> es siempre cero. Así tenemos que:</p>
<p><span class="math display">\[R = 
\begin{pmatrix}
0 &amp; r_{12} &amp; ... &amp; r_{1N}\\
r_{21} &amp; 0 &amp; ... &amp; r_{2N}\\
... &amp; ... &amp; ... &amp; ...\\
r_{N1} &amp; r_{N2} &amp; ... &amp; 0
\end{pmatrix}\]</span></p>
<p>A partir de la matriz <span class="math inline">\(R\)</span> se puede obtener la denominada <strong>matriz generadora</strong> <span class="math inline">\(Q\)</span> de la CMTC, que se define como aquella que tiene por elementos <span class="math inline">\(q_{ij}\)</span>, con:</p>
<p><span class="math display">\[q_{ij} = \begin{cases}
-r_i, \quad \text{ si } i = j, \\
r_{ij}, \quad \text{ si } i \neq j.
\end{cases}\]</span></p>
<p>de forma que:</p>
<p><span class="math display">\[Q = R-diag(r_1,...,r_N)=
\begin{pmatrix}
-r_1 &amp; r_{12} &amp; ... &amp; r_{1N}\\
r_{21} &amp; -r_2 &amp; ... &amp; r_{2N}\\
... &amp; ... &amp; ... &amp; ...\\
r_{N1} &amp; r_{N2} &amp; ... &amp; -r_N
\end{pmatrix}\]</span></p>
<div class="example">
<p><span id="exm:excmtc003" class="example"><strong>Ejemplo 4.3  </strong></span>Continuando con el sistema de vida útil del satélite del ejemplo <a href="CMTC.html#exm:excmtc001">4.1</a>, podemos establecer que <span class="math inline">\(r_0 = 0\)</span> y <span class="math inline">\(r_1 = \mu\)</span>, con <span class="math inline">\(p_{10} = 1\)</span> y <span class="math inline">\(p_{01}\)</span> no definida, de forma que:</p>
</div>
<p><span class="math display">\[R = 
\begin{pmatrix}
0 &amp; 0 \\
\mu &amp; 0
\end{pmatrix} \quad \text{ y } \quad Q = 
\begin{pmatrix}
0 &amp; 0 \\
\mu &amp; -\mu
\end{pmatrix}\]</span></p>
<p>En esta situación el diagrama de tasas se construye con la librería <code>diagram</code>:</p>
<div class="sourceCode" id="cb414"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">diagram</span><span class="op">)</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"0"</span>, <span class="st">"1"</span><span class="op">)</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">estados</span><span class="op">)</span>

<span class="va">M</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="va">M</span><span class="op">)</span>

<span class="va">R</span><span class="op">[[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"mu"</span> 

<span class="va">pp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/diagram/man/plotmat.html">plotmat</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span>,  pos <span class="op">=</span> <span class="fl">2</span>, curve <span class="op">=</span> <span class="fl">0.2</span>, name <span class="op">=</span> <span class="va">estados</span>,
              lwd <span class="op">=</span> <span class="fl">1</span>, box.lwd <span class="op">=</span> <span class="fl">2</span>, cex.txt <span class="op">=</span> <span class="fl">0.8</span>,
              box.type <span class="op">=</span> <span class="st">"circle"</span>, box.prop <span class="op">=</span> <span class="fl">0.5</span>, arr.type <span class="op">=</span> <span class="st">"triangle"</span>,
              arr.pos <span class="op">=</span> <span class="fl">0.55</span>, self.cex <span class="op">=</span> <span class="fl">0.6</span>,  
              shadow.size <span class="op">=</span> <span class="fl">0.01</span>, prefix <span class="op">=</span> <span class="st">""</span>, endhead <span class="op">=</span> <span class="cn">FALSE</span>, main <span class="op">=</span> <span class="st">""</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:05-002"></span>
<img src="04-CMTC_files/figure-html/05-002-1.png" alt="Diagrama de tasas para el tiempo de vida del Satélite" width="95%"><p class="caption">
Figura 4.1: Diagrama de tasas para el tiempo de vida del Satélite
</p>
</div>
<div class="example">
<p><span id="exm:excmtc004" class="example"><strong>Ejemplo 4.4  </strong></span>Continuando con el sistema del viajante descrito en el ejemplo <a href="CMTC.html#exm:excmtc002">4.2</a> ya que conocemos las tasas medias y las probabilidades de salto podemos obtener la matriz <span class="math inline">\(R\)</span> de forma inmediata:</p>
</div>
<div class="sourceCode" id="cb415"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"0"</span>, <span class="st">"1"</span>, <span class="st">"2"</span><span class="op">)</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">estados</span><span class="op">)</span>

<span class="va">P</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, 
            data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="fl">0</span>, <span class="fl">0.25</span>, <span class="fl">0.75</span>, <span class="fl">0.25</span>, <span class="fl">0</span><span class="op">)</span>, 
            byrow <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>
<span class="va">r</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">1.5</span><span class="op">)</span>

<span class="va">R</span> <span class="op">&lt;-</span> <span class="va">r</span><span class="op">*</span><span class="va">P</span>
<span class="va">R</span></code></pre></div>
<pre><code>##      [,1]      [,2] [,3]
## [1,] 0.00 0.2500000 0.25
## [2,] 0.75 0.0000000 0.25
## [3,] 0.50 0.1666667 0.00</code></pre>
<p>de forma que el diagrama de tasas viene dado por (asignamos el valor de la ciudad a cada uno de los posibles estados del sistema)</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:05-004"></span>
<img src="04-CMTC_files/figure-html/05-004-1.png" alt="Diagrama de tasas para el proceso del vendedor" width="95%"><p class="caption">
Figura 4.2: Diagrama de tasas para el proceso del vendedor
</p>
</div>
<p>El diagrama representa el comportamiento de todo el proceso de viajes y estancias del vendedor.</p>
<div class="example">
<p><span id="exm:excmtc005" class="example"><strong>Ejemplo 4.5  </strong></span><strong>Sistema vida útil de una máquina</strong>. Consideramos un sistema compuesto por una máquina que funciona durante un cantidad de tiempo que viene determinada por una variable aleatoria <span class="math inline">\(Exp(\mu)\)</span> hasta que falla. Una vez se detecta la avería, la máquina se repara. El tiempo de reparación es una variable aleatoria <span class="math inline">\(Exp(\lambda)\)</span> y es independiente del pasado. La máquina está como nueva después de la reparación. Sea <span class="math inline">\(X_t\)</span> el estado de la máquina en tiempo <span class="math inline">\(t\)</span>, de forma que toma el valor 1 si está en marcha y 0 si está parada (porque está siendo reparada).</p>
</div>
<p>En esta situación el tiempo de estancia en el estado 0 es el tiempo de reparación, de forma que <span class="math inline">\(r_0 = \lambda\)</span>, mientras que el tiempo en el estado 1 es el tiempo de funcionamiento con <span class="math inline">\(r_1 = \mu\)</span>. Además las probabilidades de salto de interés son <span class="math inline">\(p_{01} = 1\)</span> y <span class="math inline">\(p_{10} = 1\)</span>, dado que la máquina siempre es reparada y vuelve a funcionar, y porque sabemos que la máquina debe estropearse en algún momento.</p>
<p>El proceso definido de esta forma <span class="math inline">\(\{X_t; t \geq 0\}\)</span> es una CMTC cuya matriz de tasas y matriz generadora del sistema vienen dadas por:</p>
<p><span class="math display">\[R = 
\begin{pmatrix}
0 &amp; \lambda \\
\mu &amp; 0
\end{pmatrix} \quad \text{ y } \quad Q = 
\begin{pmatrix}
-\lambda &amp; \lambda \\
\mu &amp; -\mu
\end{pmatrix}\]</span></p>
<p>El diagrama del sistema viene dado por:</p>
<div class="sourceCode" id="cb417"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"0"</span>, <span class="st">"1"</span><span class="op">)</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">estados</span><span class="op">)</span>

<span class="va">M</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="va">M</span><span class="op">)</span>

<span class="va">R</span><span class="op">[[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"lambda"</span> 
<span class="va">R</span><span class="op">[[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"mu"</span> 

<span class="va">pp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/diagram/man/plotmat.html">plotmat</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span>,  pos <span class="op">=</span> <span class="fl">2</span>, curve <span class="op">=</span> <span class="fl">0.2</span>, name <span class="op">=</span> <span class="va">estados</span>,
              lwd <span class="op">=</span> <span class="fl">1</span>, box.lwd <span class="op">=</span> <span class="fl">2</span>, cex.txt <span class="op">=</span> <span class="fl">0.8</span>,
              box.type <span class="op">=</span> <span class="st">"circle"</span>, box.prop <span class="op">=</span> <span class="fl">0.5</span>, arr.type <span class="op">=</span> <span class="st">"triangle"</span>,
              arr.pos <span class="op">=</span> <span class="fl">0.55</span>, self.cex <span class="op">=</span> <span class="fl">0.6</span>,  
              shadow.size <span class="op">=</span> <span class="fl">0.01</span>, prefix <span class="op">=</span> <span class="st">""</span>, endhead <span class="op">=</span> <span class="cn">FALSE</span>, main <span class="op">=</span> <span class="st">""</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:05-005"></span>
<img src="04-CMTC_files/figure-html/05-005-1.png" alt="Diagrama de tasas para el sistema de una máquina" width="95%"><p class="caption">
Figura 4.3: Diagrama de tasas para el sistema de una máquina
</p>
</div>
</div>
<div id="CMTCC" class="section level2" number="4.3">
<h2>
<span class="header-section-number">4.3</span> Análisis preliminar del proceso<a class="anchor" aria-label="anchor" href="#CMTCC"><i class="fas fa-link"></i></a>
</h2>
<p>Aunque más adelante estudiaremos los aspectos teóricos para el análisis completo de una CMTC, en este punto utilizamos la simulación del sistema para analizar su comportamiento. Nos centramos en las herramientas de simulación estudiadas hasta este punto para más adelante presentar con detalle la librería <code>simmer</code> que nos permite simular procesos y sistemas complejos.</p>
<p>Utilizamos los ejemplos <a href="CMTC.html#exm:excmtc002">4.2</a> y <a href="CMTC.html#exm:excmtc005">4.5</a> para mostrar cómo analizar un sistema, dado que el descrito en el ejemplo <a href="CMTC.html#exm:excmtc001">4.1</a> se puede analizar sin más que describir la tasa del tiempo de vida del satélite.</p>
<div id="vidautil-maquina" class="section level3" number="4.3.1">
<h3>
<span class="header-section-number">4.3.1</span> Vida útil de una máquina<a class="anchor" aria-label="anchor" href="#vidautil-maquina"><i class="fas fa-link"></i></a>
</h3>
<p>Comenzamos con el ejemplo <a href="CMTC.html#exm:excmtc005">4.5</a>, para el que vamos a construir un algoritmo con el que simular el sistema hasta cierto instante de tiempo.</p>
<div class="silverbox">
<p>Algoritmo para el sistema de vida útil de una máquina:</p>
<ol style="list-style-type: decimal">
<li>Fijar tasas de funcionamiento <span class="math inline">\(\mu\)</span> y reparación <span class="math inline">\(\lambda\)</span>, así como el tiempo en que el sistema estará funcionando (<span class="math inline">\(tfin\)</span>).</li>
<li>Fijar el tiempo de funcionamiento <span class="math inline">\(tfun = 0\)</span>, tiempo de reparación <span class="math inline">\(trep = 0\)</span>, y tiempo de funcionamiento del sistema <span class="math inline">\(tsis = tfun + trep\)</span>.</li>
<li>Fijar el número de visitas al estado de funcionamiento <span class="math inline">\(nfun = 0\)</span> y al estado de reparación <span class="math inline">\(nrep =0\)</span>.</li>
</ol>
<p>Repetir los pasos siguientes hasta abandonar el sistema:</p>
<ol start="3" style="list-style-type: decimal">
<li>Generar <span class="math inline">\(tfun \sim Exp(\mu)\)</span> actualizando <span class="math inline">\(tsis\)</span> y <span class="math inline">\(nfun\)</span>.</li>
<li>Si <span class="math inline">\(tsis &gt; tfin\)</span>, abandonar el sistema.</li>
<li>Generar <span class="math inline">\(trep \sim Exp(\lambda)\)</span> actualizando <span class="math inline">\(tsis\)</span> y <span class="math inline">\(nrep\)</span>.</li>
<li>Si <span class="math inline">\(tsis &gt; tfin\)</span>, abandonar el sistema.</li>
</ol>
<p>Los valores <span class="math inline">\(tfun\)</span>, <span class="math inline">\(trep\)</span>, así como las veces que se visitan los estados de funcionamiento y reparación nos permiten describir el funcionamiento del sistema para un tiempo prefijado.</p>
</div>
<p>Para facilitar el análisis establecemos que todos los tiempos del sistema están en días y que deseamos estudiar el sistema durante un año. Creamos una función que nos permite modificar los valores de la tasa del tiempo de funcionamiento (recíproco de la media de tiempo en funcionamiento ), la tasa de reparación (recíproco de la media del tiempo de reparación) y el tiempo total de funcionamiento del sistema. Almacenamos los resultados de cada paso por el sistema para poder realizar los análisis correspondientes.</p>
<div class="sourceCode" id="cb418"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">TSIM_one_machine</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">tasafun</span>, <span class="va">tasarep</span>, <span class="va">tfin</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Parámetros de la función</span>
  <span class="co"># =========================</span>
  <span class="co"># tasafun: tasa de funcionamiento</span>
  <span class="co"># tasarep: tasa de reparación</span>
  <span class="co"># tfin: tiempo de funcionamiento del sistema</span>
  
  <span class="co"># inicialización de parámetros del sistema </span>
  <span class="va">tfun</span> <span class="op">=</span> <span class="va">trep</span> <span class="op">=</span> <span class="va">nfun</span> <span class="op">=</span> <span class="va">nrep</span> <span class="op">=</span> <span class="va">tsis</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="op">)</span>
  <span class="co"># estado inicial del sistema</span>
  <span class="va">i</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">tfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">trep</span> <span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">nfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">nrep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span>
  <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">+</span> <span class="va">trep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
  
  <span class="co"># Bucle de simulación</span>
  <span class="kw">while</span><span class="op">(</span><span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;=</span> <span class="va">tfin</span><span class="op">)</span>
  <span class="op">{</span>
    <span class="va">i</span><span class="op">&lt;-</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="co"># Máquina en funcionamiento</span>
    <span class="va">nfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">nfun</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="va">tfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasafun</span><span class="op">)</span> 
    <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
    <span class="va">trep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span> <span class="co">#Actualizamos estos dos parámetros ya que no hemos entrado en reparación</span>
    <span class="va">nrep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">nrep</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&gt;</span> <span class="va">tfin</span><span class="op">)</span> <span class="op">{</span>
      <span class="co"># adaptamos valores para quedarnos en los 365 días</span>
      <span class="va">tfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tfin</span> <span class="op">-</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>
      <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tfun</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
      <span class="kw">break</span>
      <span class="op">}</span>
    <span class="co"># Máquina en reparación</span>
    <span class="va">nrep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">nrep</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="va">trep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasarep</span><span class="op">)</span>
    <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">+</span> <span class="va">trep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&gt;</span> <span class="va">tfin</span><span class="op">)</span> <span class="op">{</span>
    <span class="co"># adaptamos valores para quedarnos en los 365 días</span>
      <span class="va">trep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tfin</span> <span class="op">-</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> 
      <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">+</span> <span class="va">trep</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
      <span class="kw">break</span>
      <span class="op">}</span>
  <span class="op">}</span>
  <span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span><span class="va">tfun</span>, <span class="va">nfun</span>, <span class="va">trep</span>, <span class="va">nrep</span>,<span class="va">tsis</span><span class="op">)</span>
  <span class="co"># Devolvemos resultados del sistema quitando la fila de inicialización</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">res</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span>,<span class="op">]</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Supongamos que a través de los registros históricos de funcionamiento y reparación de la máquina se sabe que el tiempo medio de funcionamiento es de 60 días (<span class="math inline">\(\mu = 1/60\)</span>) y el tiempo medio de reparación es de cuatro días (<span class="math inline">\(\lambda = 1/4\)</span>). Además se está interesado en estudiar el funcionamiento del sistema para el próximo año (365 días). Queremos pues, estimar:</p>
<ul>
<li>Proporción del tiempo que la máquina está funcionando y en reparación.</li>
<li>Número de ocasiones en que la máquina debe ser reparada.</li>
<li>Si el beneficio neto es de 100 euros por cada día que la máquina está funcionando y una pérdida de 1500 euros por cada día que está en reparación ¿cuál es el beneficio esperado para el próximo año?</li>
</ul>
<p>Obtenemos la simulación del sistema:</p>
<div class="sourceCode" id="cb419"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mu</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">60</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">4</span>
<span class="va">simulacion</span> <span class="op">&lt;-</span> <span class="fu">TSIM_one_machine</span><span class="op">(</span><span class="va">mu</span>, <span class="va">lambda</span>, <span class="fl">365</span><span class="op">)</span>
<span class="va">simulacion</span></code></pre></div>
<pre><code>## # A tibble: 4 × 5
##     tfun  nfun  trep  nrep  tsis
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  12.1      1  6.58     1  18.7
## 2 311.       2  3.41     2 333. 
## 3  27.9      3  2.18     3 363. 
## 4   1.42     4  2.28     4 370.</code></pre>
<p>Podemos ver que el número de ciclos en que la máquina ha entrado en funcionamiento es 4, mientras que el número de veces que ha necesitado reparación son 4.</p>
<p>Calculamos ahora los tiempos totales de funcionamiento y reparación:</p>
<div class="sourceCode" id="cb421"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tiempos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">simulacion</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span><span class="op">]</span>, <span class="fl">2</span>, <span class="va">sum</span><span class="op">)</span>
<span class="va">tiempos</span></code></pre></div>
<pre><code>##      tfun      trep 
## 351.97978  14.44428</code></pre>
<p>Por tanto, la proporción de tiempo que la máquina está en funcionamiento es 0.96, y el beneficio estimado para el próximo año viene dado por:</p>
<div class="sourceCode" id="cb423"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">beneficio</span> <span class="op">&lt;-</span> <span class="fl">100</span> <span class="op">*</span> <span class="va">tiempos</span><span class="op">[</span><span class="st">"tfun"</span><span class="op">]</span> <span class="op">-</span> <span class="fl">1500</span> <span class="op">*</span> <span class="va">tiempos</span><span class="op">[</span><span class="st">"trep"</span><span class="op">]</span>
<span class="va">beneficio</span></code></pre></div>
<pre><code>##     tfun 
## 13531.56</code></pre>
</div>
<div id="viajanteCMTC" class="section level3" number="4.3.2">
<h3>
<span class="header-section-number">4.3.2</span> Sistema del viajante<a class="anchor" aria-label="anchor" href="#viajanteCMTC"><i class="fas fa-link"></i></a>
</h3>
<p>A continuación analizamos el sistema del viajante correspondiente al ejemplo <a href="CMTC.html#exm:excmtc002">4.2</a>. En primer lugar establecemos el algoritmo de simulación del sistema. Para facilitar todas las posibilidades del algoritmo asumimos que el vendedor comienza el recorrido en la ciudad en la que reside.</p>
<div class="silverbox">
<p>Algoritmo para el análisis del sistema del viajante:</p>
<ol style="list-style-type: decimal">
<li>Fijar tasas de permanencia en cada ciudad <span class="math inline">\(\mu_A\)</span>, <span class="math inline">\(\mu_B\)</span>, y <span class="math inline">\(\mu_C\)</span>, así como las probabilidades de salto dadas en la matriz <span class="math inline">\(P\)</span>, y una variable que indica la ciudad en la que nos encontramos (<span class="math inline">\(ciudad\)</span>).</li>
<li>Fijar el tiempo de funcionamiento del sistema <span class="math inline">\(tsis = 0\)</span>, tiempo de permanencia en cada ciudad <span class="math inline">\(tiempo = 0\)</span>, y el tiempo de estudio <span class="math inline">\(tfin\)</span>.</li>
<li>Generar <span class="math inline">\(tiempo \sim Exp(\mu_a)\)</span> y actualizar <span class="math inline">\(tsis\)</span>, de forma que si <span class="math inline">\(tsis &gt; tfin\)</span> abandonamos el sistema.</li>
<li>Generamos un salto de la ciudad <span class="math inline">\(A\)</span> de acuerdo a las probabilidades de <span class="math inline">\(P\)</span> correspondientes a la ciudad <span class="math inline">\(A\)</span>.</li>
</ol>
<p>Repetir los pasos siguientes hasta que el tiempo en el sistema supere el tiempo fijado:</p>
<ol start="5" style="list-style-type: decimal">
<li>Actualizamos <span class="math inline">\(ciudad\)</span>, generamos <span class="math inline">\(tiempo \sim Exp(\mu_{ciudad})\)</span> y actualizamos <span class="math inline">\(tsis\)</span>, de forma que si <span class="math inline">\(tsis &gt; tfin\)</span> abandonamos el sistema.</li>
<li>Generamos un salto de la ciudad del paso anterior de acuerdo a las probabilidades de <span class="math inline">\(P\)</span> correspondientes a dicha ciudad.</li>
</ol>
<p>Los valores <span class="math inline">\(tiempo\)</span>, y <span class="math inline">\(ciudad\)</span> nos permiten describir el funcionamiento del sistema para un tiempo prefijado.</p>
</div>
<p>A continuación construimos la función para simular el sistema hasta cierto instante de tiempo.</p>
<div class="sourceCode" id="cb425"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">TSIM_viajante</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">tasaA</span>, <span class="va">tasaB</span>, <span class="va">tasaC</span>, <span class="va">tfin</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Parámetros de la función</span>
  <span class="co"># =========================</span>
  <span class="co"># tasaA: tasa de permanencia en A</span>
  <span class="co"># tasaB: tasa de permanencia en B</span>
  <span class="co"># tasaC: tasa de permanencia en C</span>
  <span class="co"># tfin: tiempo de funcionamiento del sistema</span>
  
  <span class="co"># inicialización de parámetros del sistema </span>
  <span class="va">tiempo</span> <span class="op">=</span> <span class="va">tsis</span> <span class="op">=</span> <span class="va">ciudad</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="op">)</span>
  <span class="co"># Probabilidades de salto. Fijamos la primera ya que la otra es complementaria</span>
  <span class="va">pA</span> <span class="op">&lt;-</span> <span class="fl">0.5</span> <span class="co"># de A a B. De A a C es  1-pA</span>
  <span class="va">pB</span> <span class="op">&lt;-</span> <span class="fl">0.75</span> <span class="co"># de B a A. De B a C es  1-pB</span>
  <span class="va">pC</span> <span class="op">&lt;-</span> <span class="fl">0.75</span> <span class="co"># de C a A. De C a B es  1-pC</span>
  
  <span class="co"># estado inicial del sistema</span>
  <span class="va">i</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"A"</span>

  <span class="co"># Primer tiempo de estancia</span>
  <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasaA</span><span class="op">)</span>
  <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
  <span class="co"># Saltamos de la ciudad A</span>
  <span class="va">uniforme</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>
  <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">uniforme</span> <span class="op">&lt;=</span> <span class="va">pA</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"B"</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"C"</span><span class="op">)</span>
      
  <span class="co"># Bucle de simulación</span>
  <span class="kw">while</span><span class="op">(</span><span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;=</span> <span class="va">tfin</span><span class="op">)</span>
  <span class="op">{</span>
    <span class="va">i</span><span class="op">&lt;-</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="va">uniforme</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">==</span> <span class="st">"A"</span><span class="op">)</span>
      <span class="op">{</span>
        <span class="co"># Calculamos tiempo de permanencia</span>
        <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasaA</span><span class="op">)</span>
        <span class="co"># Actualizamos y valoramos si hemos alcanzado el tiempo límite</span>
        <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
        <span class="kw">if</span><span class="op">(</span><span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&gt;</span> <span class="va">tfin</span><span class="op">)</span><span class="op">{</span>
            <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tfin</span> <span class="op">-</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> 
            <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
            <span class="kw">break</span>
          <span class="op">}</span>
        <span class="co"># Si no hemos alcanzado el límite realizamos un nuevo salto</span>
        <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">uniforme</span> <span class="op">&lt;=</span> <span class="va">pA</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"B"</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"C"</span><span class="op">)</span>
      <span class="op">}</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">==</span> <span class="st">"B"</span><span class="op">)</span>
      <span class="op">{</span>
        <span class="co"># Calculamos tiempo de permanencia</span>
        <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasaB</span><span class="op">)</span>
        <span class="co"># Actualizamos y valoramos si hemos alcanzado el tiempo límite</span>
        <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
        <span class="kw">if</span><span class="op">(</span><span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&gt;</span> <span class="va">tfin</span><span class="op">)</span><span class="op">{</span>
            <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tfin</span> <span class="op">-</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> 
            <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
            <span class="kw">break</span>
          <span class="op">}</span>
        <span class="co"># Si no hemos alcanzado el límite realizamos un nuevo salto</span>
        <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">uniforme</span> <span class="op">&lt;=</span> <span class="va">pB</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"A"</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"C"</span><span class="op">)</span>
      <span class="op">}</span>  
    <span class="kw">if</span><span class="op">(</span><span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">==</span> <span class="st">"C"</span><span class="op">)</span>
      <span class="op">{</span>
        <span class="co"># Calculamos tiempo de permanencia</span>
        <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasaC</span><span class="op">)</span>
        <span class="co"># Actualizamos y valoramos si hemos alcanzado el tiempo límite</span>
        <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
        <span class="kw">if</span><span class="op">(</span><span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&gt;</span> <span class="va">tfin</span><span class="op">)</span><span class="op">{</span>
            <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">tfin</span> <span class="op">-</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> 
            <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="va">tsis</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>
            <span class="kw">break</span>
          <span class="op">}</span>
        <span class="co"># Si no hemos alcanzado el límite realizamos un nuevo salto</span>
        <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">uniforme</span> <span class="op">&lt;=</span> <span class="va">pC</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"A"</span>, <span class="va">ciudad</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"C"</span><span class="op">)</span>
      <span class="op">}</span>
  <span class="op">}</span>
  <span class="co"># Devolvemos resultados del sistema </span>
  <span class="va">ciudad</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html">factor</a></span><span class="op">(</span><span class="va">ciudad</span><span class="op">)</span>
  <span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span><span class="va">tiempo</span>, <span class="va">ciudad</span>, <span class="va">tsis</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Supongamos que estamos interesados en aproximar el comportamiento del vendedor durante el próximo año (52 semanas) para poder contestar a las preguntas siguientes:</p>
<ul>
<li>Proporción de tiempo que el vendedor pasa en cada ciudad.</li>
<li>Número de ocasiones en que visita cada ciudad.</li>
</ul>
<p>Simulamos pues el sistema y contestamos a las preguntas planteadas:</p>
<div class="sourceCode" id="cb426"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tasaA</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>
<span class="va">tasaB</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">1</span>
<span class="va">tasaC</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">/</span><span class="fl">3</span>
<span class="va">tfin</span> <span class="op">&lt;-</span> <span class="fl">52</span>
<span class="va">simulacion</span> <span class="op">&lt;-</span> <span class="fu">TSIM_viajante</span><span class="op">(</span><span class="va">tasaA</span>, <span class="va">tasaB</span>, <span class="va">tasaC</span>, <span class="va">tfin</span><span class="op">)</span>  
<span class="co"># Análisis del sistema</span>
<span class="va">simulacion</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">ciudad</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>visita <span class="op">=</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/context.html">n</a></span><span class="op">(</span><span class="op">)</span>, estancia <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tiempo</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>proporcion <span class="op">=</span> <span class="va">estancia</span><span class="op">/</span><span class="fl">52</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 4
##   ciudad visita estancia proporcion
##   &lt;fct&gt;   &lt;int&gt;    &lt;dbl&gt;      &lt;dbl&gt;
## 1 A          16    32.1       0.617
## 2 B           7     6.27      0.121
## 3 C          10    13.6       0.262</code></pre>
</div>
<div id="análisis-con-simmer" class="section level3" number="4.3.3">
<h3>
<span class="header-section-number">4.3.3</span> Análisis con simmer<a class="anchor" aria-label="anchor" href="#an%C3%A1lisis-con-simmer"><i class="fas fa-link"></i></a>
</h3>
<p>Si bien dedicamos en este curso un capítulo entero para contar el funcionamiento de la librería <code>simmer</code>, puesto que estos ejemplos son relativamente sencillos, podemos introducir sin demasiada complicación el algoritmo de simulación con <code>simmer</code>.</p>
<p>La libreria <code>simmer</code> permite simular de sistemas tanto continuos como discretos bajos dos premisas fundamentales:</p>
<ul>
<li>Proceso de llegadas (“arrivals”) al sistema.</li>
<li>Proceso de servicio (“server”): en el que a cada una de las llegadas se les asigna una serie de actividades a realizar (integradas en ‘trayectorias’) y unos recursos o servidores que resuelven con ellas las actividades.</li>
</ul>
<p>Para el sistema descrito en ejemplo <a href="CMTC.html#exm:excmtc005">4.5</a> el proceso de llegadas viene identificado por las averías que se producen en determinados instantes de tiempo. El proceso de servicio se corresponde con las reparaciones de las máquinas, a las que se dedica cierto tiempo. En este caso el recurso es el reparador encargado de resolver la avería y poner en marcha la máquina de nuevo.</p>
<p>El primer paso del algoritmo de simulación es cargar las librerías y definir la semilla de simulación:</p>
<div class="sourceCode" id="cb428"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-simmer.org">simmer</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-simmer.org">simmer.plot</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://r-simmer.org">simmer.bricks</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">parallel</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></code></pre></div>
<p>Definimos ahora el entorno de simulación del sistema:</p>
<div class="sourceCode" id="cb429"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Sistema</span>
<span class="co">#################################################</span>
<span class="va">sistema.1m</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>, <span class="va">mu</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># tarea dentro de sistema: reparación de las averías</span>
  <span class="va">reparar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-simmer.org/reference/trajectory.html">trajectory</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="co"># la máquina estropeada se asigna a un reparador</span>
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">seize</a></span><span class="op">(</span><span class="st">"reparador"</span>, amount <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>              
    <span class="co"># el tiempo de reparación es aleatorio</span>
    <span class="fu"><a href="https://r-simmer.org/reference/timeout.html">timeout</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">lambda</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>   
    <span class="co"># la máquina ya ha sido reparada</span>
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">release</a></span><span class="op">(</span><span class="st">"reparador"</span>, amount <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>               

  <span class="co"># Configuración del sistema </span>
  <span class="co">#################################################</span>
  <span class="fu"><a href="https://r-simmer.org/reference/simmer.html">simmer</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="co"># Se definen los recursos: un único reparador y cola infinita</span>
    <span class="fu"><a href="https://r-simmer.org/reference/add_resource.html">add_resource</a></span><span class="op">(</span><span class="st">"reparador"</span>, capacity <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>           
    <span class="co"># Simulador de los tiempos entre averías, dirigidas a "reparar"</span>
    <span class="fu"><a href="https://r-simmer.org/reference/add_generator.html">add_generator</a></span><span class="op">(</span><span class="st">"averia"</span>, <span class="va">reparar</span>, <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">mu</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
    <span class="co"># Tiempo funcionamiento del sistema</span>
    <span class="fu"><a href="https://r-simmer.org/reference/run.html">run</a></span><span class="op">(</span>until <span class="op">=</span> <span class="va">t</span><span class="op">)</span>     
<span class="op">}</span>
<span class="co">####################################</span>
<span class="co"># Tasas de permanencia del sistema</span>
<span class="co">######</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">4</span>  <span class="co"># tasa reparación</span>
<span class="va">mu</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">60</span>     <span class="co"># tasa funcionamiento</span>

<span class="co">### Simulación del sistema durante 365 días</span>
<span class="va">operar</span> <span class="op">&lt;-</span> <span class="fu">sistema.1m</span><span class="op">(</span><span class="fl">365</span>, <span class="va">lambda</span>,<span class="va">mu</span><span class="op">)</span></code></pre></div>
<p>Analizamos ahora los resultados que proporciona el sistema simulado. Podemos acceder a las información de dos formas diferentes mediante las funciones <code><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals()</a></code> para describir las llegadas (averías) y <code><a href="https://r-simmer.org/reference/get_mon.html">get_mon_resources()</a></code> para describir la ocupación de los servidores recursos (técnicos reparadores).</p>
<div class="sourceCode" id="cb430"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">reparacion</span> <span class="op">=</span> <span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals</a></span><span class="op">(</span><span class="va">operar</span><span class="op">)</span>
<span class="va">reparacion</span></code></pre></div>
<pre><code>##      name start_time end_time activity_time finished replication
## 1 averia0   150.1055 150.1318    0.02632783     TRUE           1
## 2 averia1   164.9110 166.4598    1.54873033     TRUE           1
## 3 averia2   269.4758 272.7721    3.29632606     TRUE           1
## 4 averia3   274.8728 278.2250    3.35216128     TRUE           1
## 5 averia4   287.0299 294.5502    7.52030671     TRUE           1
## 6 averia5   332.6557 339.2903    6.63464954     TRUE           1</code></pre>
<p>El objeto resultante tiene las columnas siguientes:</p>
<ul>
<li>
<code>name</code>: nombre de las llegadas (averías), numeradas correlativamente</li>
<li>
<code>star_time</code>: instante en el que llega al sistema (se produce la avería)</li>
<li>
<code>end_time</code>: instante en el que sale del sistema (se ha reparado)</li>
<li>
<code>activity_time</code>: tiempo dedicado a la tarea (tiempo de reparación)</li>
<li>
<code>finished</code>: si la tarea ha finalizado dentro del periodo de tiempo de simulación establecido.</li>
<li>
<code>replication</code>: número de replicas del sistema (1 porque sólo hemos lanzado una cadena).</li>
</ul>
<div class="sourceCode" id="cb432"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">recursos</span> <span class="op">=</span> <span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_resources</a></span><span class="op">(</span><span class="va">operar</span><span class="op">)</span>
<span class="va">recursos</span></code></pre></div>
<pre><code>##     resource     time server queue capacity queue_size system limit replication
## 1  reparador 150.1055      1     0        1        Inf      1   Inf           1
## 2  reparador 150.1318      0     0        1        Inf      0   Inf           1
## 3  reparador 164.9110      1     0        1        Inf      1   Inf           1
## 4  reparador 166.4598      0     0        1        Inf      0   Inf           1
## 5  reparador 269.4758      1     0        1        Inf      1   Inf           1
## 6  reparador 272.7721      0     0        1        Inf      0   Inf           1
## 7  reparador 274.8728      1     0        1        Inf      1   Inf           1
## 8  reparador 278.2250      0     0        1        Inf      0   Inf           1
## 9  reparador 287.0299      1     0        1        Inf      1   Inf           1
## 10 reparador 294.5502      0     0        1        Inf      0   Inf           1
## 11 reparador 332.6557      1     0        1        Inf      1   Inf           1
## 12 reparador 339.2903      0     0        1        Inf      0   Inf           1</code></pre>
<p>Con la función <code><a href="https://r-simmer.org/reference/get_mon.html">get_mon_resources()</a></code> tenemos una descripción continua de los recursos del proceso con las columnas:</p>
<ul>
<li>
<code>resource</code>: recurso (numerado correlativamente si hubiera más de uno)</li>
<li>
<code>time</code>: instante de tiempo en que se ha registrado alguna actividad (avería, reparación, puesta en marcha)</li>
<li>
<code>server</code>: número de servidores (recursos) ocupados (como sólo hay un técnico, es igual a 1)</li>
<li>
<code>queue</code>: llegadas en la cola (averías que están esperando ser reparadas porque el técnico está ocupado)</li>
<li>
<code>capacity</code>: capacidad del sistema o número de reparadores en el sistema</li>
<li>
<code>queue_size</code>: tamaño de la cola de espera (averías en espera para ser reparadas)</li>
<li>
<code>system</code>: llegadas en el sistema (número de averías en ese instante, en reparación o en cola)</li>
<li>
<code>limit</code>: capacidad + tamaño de la cola</li>
<li>
<code>replication</code>: número de replica del sistema (1 porque sólo se ha lanzado una cadena).</li>
</ul>
<p>A partir de los resultados podemos responder a las mismas preguntas que ya planteamos antes:</p>
<ul>
<li>Proporción del tiempo que la máquina está funcionando y en reparación.</li>
<li>Número de ocasiones en que la máquina debe ser reparada.</li>
<li>Si el beneficio neto es de 100 euros por cada día que la máquina está funcionando y una pérdida de 1500 euros por cada día que está en reparación ¿cuál es el beneficio esperado para el próximo año?</li>
</ul>
<p>Para responder al primer pregunta basta con sumar los tiempos de actividad y calcular su proporción sobre los 365 días de simulación:</p>
<div class="sourceCode" id="cb434"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tiempo_reparacion</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">reparacion</span><span class="op">$</span><span class="va">activity_time</span><span class="op">)</span>
<span class="va">propor</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">100</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="op">(</span><span class="va">tiempo_reparacion</span><span class="op">/</span><span class="fl">365</span><span class="op">)</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span>
<span class="va">propor</span></code></pre></div>
<pre><code>## [1] 93.87</code></pre>
<p>La proporción de tiempo en que la máquina está funcionando es del 93.87% y el tiempo que está en reparación es del 6.13%.</p>
<p>El número de ocasiones en que la máquina está en reparación corresponde al número de veces que accedemos a la tarea de reparación, que viene identificado por el número de averías, o lo que es equivalente, el número de veces que el reparador está ocupado (server=1), esto es,</p>
<div class="sourceCode" id="cb436"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">recursos</span><span class="op">$</span><span class="va">server</span><span class="op">==</span><span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 6</code></pre>
<div class="sourceCode" id="cb438"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">reparacion</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>Para calcular el beneficio obtenido a lo largo del año utilizamos el tiempo de reparación obtenido:</p>
<div class="sourceCode" id="cb440"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="fl">365</span><span class="op">-</span><span class="va">tiempo_reparacion</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span> <span class="op">-</span> <span class="va">tiempo_reparacion</span><span class="op">*</span><span class="fl">1500</span></code></pre></div>
<pre><code>## [1] 694.3972</code></pre>
<p>Como se puede ver, los resultados no son muy similares a los obtenidos con el algoritmo que programamos nosotros. Para conseguir estimaciones eficientes deberíamos realizar diferentes replicaciones del sistema (lanzar varias cadenas) y promediar los beneficios obtenidos mediante un estimador Monte-Carlo. Podemos replicar fácilmente el sistema añadiendo dos líneas de código. Cada cadena replicada tendrá un distintivo diferente en el argumento ‘replicate’ cuando monitorizamos los resultados.</p>
<div class="sourceCode" id="cb442"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># lanzamos 'nreplicas' de la cadena, que se almacenan en una lista</span>
<span class="va">nreplicas</span> <span class="op">&lt;-</span> <span class="fl">500</span>
<span class="va">envs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">nreplicas</span>, <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">{</span>
  <span class="fu">sistema.1m</span><span class="op">(</span><span class="fl">365</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">60</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/wrap.html">wrap</a></span><span class="op">(</span><span class="op">)</span><span class="op">}</span>,mc.set.seed <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p>Ahora almacenamos todas las simulaciones a modo de matriz, en concreto ‘tibble,’ para poder realizar los cálculos oportunos agrupando por réplicas y con ellos poder calcular las estimaciones Monte-Carlo del tiempo total de reparación y del número de reparaciones.</p>
<div class="sourceCode" id="cb443"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># guardamos todas las llegadas en formato 'tibble'</span>
<span class="va">simulaciones</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals</a></span><span class="op">(</span><span class="va">envs</span><span class="op">)</span><span class="op">)</span>

<span class="co"># agrupamos por 'replication' para calcular los descriptivos de interés en cada réplica</span>
<span class="va">salida</span> <span class="op">&lt;-</span> <span class="va">simulaciones</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">replication</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="co"># Calculamos los descriptivos por cada réplica</span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>nreparaciones <span class="op">=</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/context.html">n</a></span><span class="op">(</span><span class="op">)</span>, 
            tiempoparada <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">activity_time</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="co"># Calculamos las estimaciones Monte-Carlo con los descriptivos de las réplicas</span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>mmedia_nrepara <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">nreparaciones</span><span class="op">)</span>,
            min_nrepara <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">nreparaciones</span><span class="op">)</span>,
            max_nrepara <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">nreparaciones</span><span class="op">)</span>,
            media_taveria <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">tiempoparada</span><span class="op">)</span>,
            q25_taveria <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">tiempoparada</span>, <span class="fl">0.25</span><span class="op">)</span>,
            q50_taveria <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">tiempoparada</span>, <span class="fl">0.50</span><span class="op">)</span>,
            q75_taveria <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">tiempoparada</span>, <span class="fl">0.75</span><span class="op">)</span>,
            sd_taveria <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">tiempoparada</span><span class="op">)</span> 
            <span class="op">)</span>
<span class="va">salida</span></code></pre></div>
<pre><code>## # A tibble: 1 × 8
##   mmedia_nrepara min_nrepara max_nrepara media_taveria q25_taveria q50_taveria q75_taveria
##            &lt;dbl&gt;       &lt;int&gt;       &lt;int&gt;         &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;
## 1           5.96           1          14          23.6        12.9        21.3        32.1
## # … with 1 more variable: sd_taveria &lt;dbl&gt;</code></pre>
<p>En ‘mmedia_nrepara’ tenemos la estimación del número de reparaciones en un año, en ‘min_nrepara’ y ‘max_nrepara’ el mínimo y el máximo respectivamente; en ‘media_taveria’ tenemos una estimación del tiempo medio acumulado en reparaciones en un año, con sus cuartiles (q25, q50 y q75) y desviación típica (sd).</p>
<p>Así podemos calcular los beneficios esperados en función del número de días que la máquina funciona y los que está estropeada:</p>
<div class="sourceCode" id="cb445"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># número de días en funcionamiento vs número de días en reparación</span>
<span class="op">(</span><span class="fl">365</span><span class="op">-</span><span class="va">salida</span><span class="op">$</span><span class="va">media_taveria</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span> <span class="op">-</span> <span class="va">salida</span><span class="op">$</span><span class="va">media_taveria</span><span class="op">*</span><span class="fl">1500</span></code></pre></div>
<pre><code>## [1] -1221.145</code></pre>
<p>Podemos considerar también otros dos escenarios posibles: uno pesimista, con un mayor tiempo acumulado de reparación (cuantil 75), y uno optimisma, con un menor tiempo (con el cuantil 25), y calcular con ellos los beneficios:</p>
<div class="sourceCode" id="cb447"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="fl">365</span><span class="op">-</span><span class="va">salida</span><span class="op">$</span><span class="va">q75_taveria</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span> <span class="op">-</span> <span class="va">salida</span><span class="op">$</span><span class="va">q75_taveria</span><span class="op">*</span><span class="fl">1500</span></code></pre></div>
<pre><code>##      75% 
## -14854.3</code></pre>
<div class="sourceCode" id="cb449"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="fl">365</span><span class="op">-</span><span class="va">salida</span><span class="op">$</span><span class="va">q25_taveria</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span> <span class="op">-</span> <span class="va">salida</span><span class="op">$</span><span class="va">q25_taveria</span><span class="op">*</span><span class="fl">1500</span></code></pre></div>
<pre><code>##      25% 
## 15835.39</code></pre>
<p>¿Qué conclusiones podemos extraer de este análisis?</p>
<p>Para finalizar este apartado presentamos un nuevo ejemplo donde el espacio de estados está compuesto por una pareja de valores y no por un único valor como en los ejemplos que hemos presentado hasta ahora.</p>
</div>
<div id="mantAeronaves" class="section level3" number="4.3.4">
<h3>
<span class="header-section-number">4.3.4</span> Mantenimiento de aronaves<a class="anchor" aria-label="anchor" href="#mantAeronaves"><i class="fas fa-link"></i></a>
</h3>
<p>Una empresa de mantenimiento de aeronaves está interesada en el proceso de avería-reparación de cierto tipo de aviones. El tipo de avión de interés es un avión comercial a reacción con cuatro motores, dos en cada ala. Cuando un motor se enciende, el tiempo que se puede mantener en funcionamiento hasta que falla es una variable aleatoria exponencial con parámetro <span class="math inline">\(\lambda\)</span>. Si el fallo se produce en vuelo, no puede haber reparación, pero el avión necesita al menos un motor en cada ala para funcionar correctamente y poder volar con seguridad. En concreto, la empresa está interesada en poder predecir la probabilidad de un vuelo sin problemas.</p>
<p>Si denotamos por <span class="math inline">\(X_L(t)\)</span> y <span class="math inline">\(X_R(t)\)</span> el número de motores funcionando en el instante <span class="math inline">\(t\)</span> en el ala izquierda y el ala derecha respectivamente, podemos considerar el estado del sistema en el instante <span class="math inline">\(t\)</span> como <span class="math inline">\(X_t = (X_L(t), X_R(t))\)</span>. Si asumimos que los fallos en los motores son independientes entre sí, podemos ver que el proceso <span class="math inline">\(\{X_t, t \geq 0\}\)</span> es una CMTC con espacio de estados:</p>
<p><span class="math display">\[S = \{ (0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2,2) \}\]</span></p>
<p>En esta situación, el avión sigue funcionando en el subconjunto de estados <span class="math inline">\(S = \{ (1, 1), (1, 2), (2, 1), (2,2) \}\)</span>.</p>
<p>Vamos a asumir (aunque no es real) que el sistema sigue funcionando, incluso cuando hay posibilidad de un accidente, hasta que llegamos al estado <span class="math inline">\((0, 0)\)</span>. Dado que no hay reparación posible, la matriz de tasas entre estados del sistema viene dada por</p>
<p><span class="math display">\[R = 
\begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\lambda &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 2\lambda &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\lambda &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \lambda &amp; 0 &amp; \lambda &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \lambda &amp; 0 &amp; 2\lambda &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 2\lambda &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 2\lambda &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2\lambda &amp; 0 &amp; 2\lambda &amp; 0
\end{pmatrix} \]</span></p>
<p>y el diagrama que representa el sistema resulta:</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:05-022"></span>
<img src="04-CMTC_files/figure-html/05-022-1.png" alt="Diagrama de tasas para el sistema motores de aviones" width="95%"><p class="caption">
Figura 4.4: Diagrama de tasas para el sistema motores de aviones
</p>
</div>
<p>Para facilitar el algoritmo de simulación en esta situación, vamos a asignar un código a cada uno de los posibles estados del sistema:</p>
<p><span class="math display">\[S = \{ 1 = (0, 0), 2 = (0, 1), 3 = (0, 2), 4 = (1, 0), 5 = (1, 1), 6 = (1, 2), 7 = (2, 0), 8 = (2, 1), 9 = (2,2) \}\]</span></p>
<p>y asumimos que la media del tiempo hasta que un motor falla cuando está encendido es de 20 horas, es decir, <span class="math inline">\(\lambda = 1/20\)</span>. A continuación hemos construido una función para simular el sistema descrito:</p>
<div class="sourceCode" id="cb451"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">TSIM_aviones</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">tasa</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Parámetros de la función</span>
  <span class="co"># =========================</span>
  <span class="co"># tasa: tasa de fallo de un motor</span>
  
  <span class="co"># Valores fijos del sistema</span>
  <span class="co"># codigos de motores funcionando obviando el estado inicial</span>
  <span class="va">codigo</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">8</span>
  <span class="co"># motores con fallo de acuerdo al código</span>
  <span class="va">motoresOFF</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">3</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">2</span>, <span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">1</span><span class="op">)</span>
  
  <span class="co"># inicialización de parámetros del sistema </span>
  <span class="va">tiempo</span> <span class="op">=</span>  <span class="va">estado</span> <span class="op">=</span> <span class="va">fallos</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="op">)</span>
  <span class="va">i</span><span class="op">&lt;-</span><span class="fl">1</span>
  <span class="co"># Primer fallo</span>
  <span class="co"># Posibles estados de salto</span>
  <span class="va">saltos</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">codigo</span><span class="op">[</span><span class="fl">6</span><span class="op">]</span>, <span class="va">codigo</span><span class="op">[</span><span class="fl">8</span><span class="op">]</span><span class="op">)</span>
  <span class="co"># tiempos asociados a cada fallo</span>
  <span class="va">simula</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">*</span><span class="va">tasa</span><span class="op">)</span>
  <span class="co"># Seleccionamos el salto</span>
  <span class="va">posicion</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.min</a></span><span class="op">(</span><span class="va">simula</span><span class="op">)</span>
  <span class="kw">if</span><span class="op">(</span><span class="va">posicion</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span>
  <span class="op">{</span>
    <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span>
    <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">simula</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span> 
    <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span><span class="op">]</span>
    <span class="co"># nuevo salto</span>
    <span class="va">i</span> <span class="op">&lt;-</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="va">saltos</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">codigo</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>, <span class="va">codigo</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span>
    <span class="va">simula</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span><span class="va">tasa</span><span class="op">)</span><span class="op">)</span>
    <span class="va">posicion</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.min</a></span><span class="op">(</span><span class="va">simula</span><span class="op">)</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">posicion</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span>
    <span class="op">{</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">simula</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span> 
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span><span class="op">]</span>
      <span class="co"># dos últimos saltos</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span>; <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span><span class="va">tasa</span><span class="op">)</span>; <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>; <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>
    <span class="op">}</span>
    <span class="kw">else</span>
    <span class="op">{</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">simula</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span> 
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span><span class="op">]</span>  
      <span class="co"># dos últimos saltos</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span>; <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>; <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>; <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>
    <span class="op">}</span>
  <span class="op">}</span>
  <span class="kw">else</span>
  <span class="op">{</span>
    <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span>
    <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">simula</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span> 
    <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span><span class="op">]</span>
    <span class="co"># nuevo salto</span>
    <span class="va">i</span> <span class="op">&lt;-</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="va">saltos</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">codigo</span><span class="op">[</span><span class="fl">7</span><span class="op">]</span>, <span class="va">codigo</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span>
    <span class="va">simula</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span><span class="va">tasa</span><span class="op">)</span><span class="op">)</span>
    <span class="va">posicion</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.min</a></span><span class="op">(</span><span class="va">simula</span><span class="op">)</span>
    <span class="kw">if</span><span class="op">(</span><span class="va">posicion</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span>
    <span class="op">{</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">simula</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span> 
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span><span class="op">]</span>
      <span class="co"># dos últimos saltos</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span>; <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span><span class="va">tasa</span><span class="op">)</span>; <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>; <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>
    <span class="op">}</span>
    <span class="kw">else</span>
    <span class="op">{</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">simula</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span> 
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">saltos</span><span class="op">[</span><span class="va">posicion</span><span class="op">]</span><span class="op">]</span>  
      <span class="co"># dos últimos saltos</span>
      <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span>; <span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>
      <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>; <span class="va">tiempo</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">tasa</span><span class="op">)</span>
      <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>; <span class="va">fallos</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">motoresOFF</span><span class="op">[</span><span class="va">estado</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>
    <span class="op">}</span>    
  <span class="op">}</span>

  <span class="co"># Devolvemos resultados del sistema </span>
  <span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html">tibble</a></span><span class="op">(</span><span class="va">estado</span>, <span class="va">tiempo</span>, <span class="va">fallos</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Veamos una simulación del sistema:</p>
<div class="sourceCode" id="cb452"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12</span><span class="op">)</span>
<span class="va">tasa</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">20</span>
<span class="va">sistema</span> <span class="op">&lt;-</span> <span class="fu">TSIM_aviones</span><span class="op">(</span><span class="va">tasa</span><span class="op">)</span>
<span class="va">sistema</span></code></pre></div>
<pre><code>## # A tibble: 4 × 3
##   estado tiempo fallos
##    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1      8   6.36      1
## 2      7   2.35      2
## 3      2  18.2       3
## 4      1   5.67      4</code></pre>
<p>El resultado obtenido es el estado en cada paso del algoritmo hasta llegar a la parada total, los tiempos para alcanzar cada estado, y el número de motores con fallo.</p>
<p>Podemos operar los tiempos para saber cuándo tendremos más de dos motores con fallo (últimas dos filas de la simulación).</p>
<p>Si el vuelo que acabamos de empezar es de <span class="math inline">\(x\)</span> horas ¿cómo podemos estimar la probabilidad de no poder terminar el vuelo de forma segura? Para responder esta pregunta podremos calcular la proporción de tiempo que corresponde con un fallo leve (1 o 2 motores con fallo) con respecto a las <span class="math inline">\(x\)</span> horas de duración del vuelo.</p>
<p>Calculamos a continuación el tiempo de fallo del sistema y evaluamos la probabilidad para diferentes tiempos de duración de vuelo.</p>
<div class="sourceCode" id="cb454"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Tiempo de fallo</span>
<span class="va">Tfallo</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">sistema</span><span class="op">$</span><span class="va">tiempo</span><span class="op">[</span><span class="va">sistema</span><span class="op">$</span><span class="va">fallos</span> <span class="op">&lt;=</span> <span class="fl">2</span><span class="op">]</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span>
<span class="co"># Duración del vuelo</span>
<span class="va">td</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">12</span>, by <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span>
<span class="va">prob</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="op">)</span>
<span class="co"># Probabilidad viaje seguro</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">td</span><span class="op">)</span><span class="op">)</span>
<span class="op">{</span>
  <span class="va">prob</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">Tfallo</span> <span class="op">&gt;=</span> <span class="va">td</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">Tfallo</span><span class="op">/</span><span class="va">td</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span>
<span class="co"># Obtenemos el valor mínimo de tiempo para asegurar un viaje seguro</span>
<span class="va">limite</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">td</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">prob</span> <span class="op">!=</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>
<span class="va">limite</span></code></pre></div>
<pre><code>## [1] 8.8</code></pre>
<p>Cualquier viaje inferior a 8.8 horas será un viaje seguro, mientras que si el tiempo es superior, la probabilidad de no tener un viaje seguro aumenta.</p>
<p>Para estudiar la estabilidad de dichas probabilidades realizamos 1000 simulaciones del sistema y estimamos las probabilidades mediante estimadores Monte-Carlo de los tiempos de fallo.</p>
<div class="sourceCode" id="cb456"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">nsim</span> <span class="op">&lt;-</span> <span class="fl">1000</span>
<span class="va">Tfallo</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="op">)</span>
<span class="co"># Repetición del sistema y calculo de tiempo </span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">nsim</span><span class="op">)</span>
<span class="op">{</span>
  <span class="va">sistema</span> <span class="op">&lt;-</span> <span class="fu">TSIM_aviones</span><span class="op">(</span><span class="va">tasa</span><span class="op">)</span>
  <span class="va">Tfallo</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">sistema</span><span class="op">$</span><span class="va">tiempo</span><span class="op">[</span><span class="va">sistema</span><span class="op">$</span><span class="va">fallos</span> <span class="op">&lt;=</span> <span class="fl">2</span><span class="op">]</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span>
<span class="op">}</span>
<span class="co"># Estimador Monte-Carlo</span>
<span class="va">estimMC</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">Tfallo</span><span class="op">)</span>
<span class="co"># Duración del vuelo</span>
<span class="va">td</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">20</span>, by <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span>
<span class="va">prob</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="op">)</span>
<span class="co"># Probabilidad viaje seguro</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">td</span><span class="op">)</span><span class="op">)</span>
<span class="op">{</span>
  <span class="va">prob</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">estimMC</span> <span class="op">&gt;=</span> <span class="va">td</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">estimMC</span><span class="op">/</span><span class="va">td</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span>
<span class="co"># Obtenemos el valor mínimo de tiempo para asegurar un viaje seguro</span>
<span class="va">limite</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">td</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">prob</span> <span class="op">!=</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>
<span class="va">limite</span></code></pre></div>
<pre><code>## [1] 11.9</code></pre>
<p>Cualquier viaje inferior a 11.9 horas será un viaje seguro, mientras que si el tiempo es superior, la probabilidad de no tener un viaje seguro aumenta. Podemos representar el gráfico de probabilidad de un viaje seguro:</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:05-027"></span>
<img src="04-CMTC_files/figure-html/05-027-1.png" alt="Probabilidad de un viaje seguro" width="95%"><p class="caption">
Figura 4.5: Probabilidad de un viaje seguro
</p>
</div>
</div>
</div>
<div id="CMTCD" class="section level2" number="4.4">
<h2>
<span class="header-section-number">4.4</span> Procesos de nacimiento y muerte<a class="anchor" aria-label="anchor" href="#CMTCD"><i class="fas fa-link"></i></a>
</h2>
<p>Los procesos de nacimiento y muerte que estudiamos en este apartado juegan un papel muy importante dentro de las CMTC, ya que son de uso habitual en muchas aplicaciones prácticas que veremos de ahora en adelante.</p>
<p>Veamos cierta propiedad que nos va a resultar de interés.</p>
<div class="bluebox">
<p>Supongamos que en un instante <span class="math inline">\(t\)</span>, el sistema está en estado <span class="math inline">\(i\)</span>, esto es, <span class="math inline">\(X_t=i\)</span>, y qe es posible transitar al estado <span class="math inline">\(j\)</span> a través de la ocurrencia de <span class="math inline">\(m\)</span> eventos independientes, cada uno de los cuales se produce con tiempos independientes <span class="math inline">\(T_i \sim Exp(\lambda_i)\)</span>.</p>
<p><em>Es el caso de que haya 5 máquinas funcionando en un sistema y cualquiera de las 5 puede fallar, de manera que un fallo en cualquiera de ellas produciría una transición al estado 4 (4 máquinas funcionando).</em></p>
<p>Entonces el sistema permanecerá en el estado <span class="math inline">\(i\)</span> hasta que se produzca el primer evento de los <span class="math inline">\(m\)</span> posibles, esto es, el tiempo de permanencia en el estado <span class="math inline">\(i\)</span>, <span class="math inline">\(TP_i\)</span>, será el mínimo de los tiempos de ocurrencia de los <span class="math inline">\(m\)</span> eventos, y su distribución será exponencial de tasa la suma de las tasas de ocurrencia de los <span class="math inline">\(m\)</span> eventos, esto es:</p>
<p><span class="math display">\[TP_i=min\{T_1,\ldots,T_m\} \sim Exp(\lambda), \qquad \text{con } \lambda=\sum_{i=1}^m \lambda_i.\]</span></p>
<p>En este caso, la tasa de permanencia es <span class="math inline">\(r_i=\lambda\)</span>, la probabilidad de salto al estado <span class="math inline">\(j\)</span>, <span class="math inline">\(p_{ij}=1\)</span> y la tasa de transición al estado <span class="math inline">\(j\)</span> es <span class="math inline">\(r_{ij}=\lambda\)</span>.</p>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:cmtc002" class="definition"><strong>Definición 4.2  </strong></span>Una CMTC <span class="math inline">\(\{X_t; t \geq 0\}\)</span> con espacio de estados <span class="math inline">\(S = \{0, 1, 2,...,N\}\)</span> y matriz de tasas dada por:</p>
<p><span class="math display">\[R = 
\begin{pmatrix}
0 &amp; \lambda_0 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; 0 \\
\mu_1 &amp; 0 &amp; \lambda_1 &amp; 0 &amp; \ldots &amp; 0 &amp; 0 \\
0 &amp; \mu_2 &amp; 0 &amp; \lambda_2 &amp; \ldots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ldots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; \lambda_{N-1} \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \ldots &amp;\mu_N &amp; 0
\end{pmatrix} \]</span></p>
<p>se denomina proceso finito de nacimiento y muerte donde los <span class="math inline">\(\lambda_i\)</span> se denominan <strong>parámetros de nacimiento</strong> (transición del estado <span class="math inline">\(i\)</span> al <span class="math inline">\(i+1\)</span>) y los <span class="math inline">\(\mu_i\)</span> se denominan <strong>parámetros de muerte</strong> (transición del estado <span class="math inline">\(i\)</span> al <span class="math inline">\(i-1)\)</span>, donde por conveniencia se asume que <span class="math inline">\(\lambda_N = 0\)</span> y <span class="math inline">\(\mu_0 = 0\)</span> indicando que no hay nacimientos en el estado <span class="math inline">\(N\)</span> y que no hay muertes en el estado <span class="math inline">\(0\)</span>.</p>
</div>
</div>
<p>En esta situación el proceso permanece en el estado <span class="math inline">\(i\)</span> un tiempo <span class="math inline">\(Exp(\lambda_i + \mu_i)\)</span>, de modo que la tasa media de permanencia en el estado <span class="math inline">\(i\)</span> es <span class="math inline">\(r_i=\lambda_i+\mu_i\)</span>. Después salta al estado <span class="math inline">\(i+1\)</span> con probabilidad <span class="math inline">\(p_{i,i+1}=\lambda_i/(\lambda_i + \mu_i)\)</span>, o al estado <span class="math inline">\(i-1\)</span> con probabilidad <span class="math inline">\(p_{i,i-1}=\mu_i/(\lambda_i + \mu_i)\)</span>. Además, la matriz generadora del proceso viene dada por:</p>
<p><span class="math display">\[Q = 
\begin{pmatrix}
- \lambda_0&amp; \lambda_0 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; 0 \\
\mu_1 &amp; -(\mu_1 + \lambda_1) &amp; \lambda_1 &amp; 0 &amp; \ldots &amp; 0 &amp; 0 \\
0 &amp; \mu_2 &amp; -(\mu_2 + \lambda_2) &amp; \lambda_2 &amp; \ldots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ldots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \ldots &amp; -(\mu_{N-1} + \lambda_{N-1}) &amp; \lambda_{N-1} \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \ldots &amp; \mu_N &amp; -\mu_N
\end{pmatrix} \]</span></p>
<p>A continuación presentamos diferentes ejemplos de aplicación de los procesos de nacimiento y muerte.</p>
<div id="cajerobancario" class="section level3" number="4.4.1">
<h3>
<span class="header-section-number">4.4.1</span> Cajero Bancario<a class="anchor" aria-label="anchor" href="#cajerobancario"><i class="fas fa-link"></i></a>
</h3>
<p>Aunque en la unidad siguiente estudiaremos con mucho más detalle los diferentes sistemas de colas de espera, vamos a presentar aquí el modelo más sencillo de colas, para comprobar que se puede modelar como un proceso de nacimiento y muerte.</p>
<p>Imaginemos que tenemos un cajero bancario al que los clientes acuden de acuerdo a un Proceso de Poisson de parámetro <span class="math inline">\(\lambda\)</span>, es decir que las llegadas son aleatorias y se distribuyen según una distribución <span class="math inline">\(Exp(\lambda)\)</span>. El sistema tiene capacidad <span class="math inline">\(K\)</span>: 1 cliente atendido y <span class="math inline">\(K-1\)</span> en la cola de espera. Además, el tiempo de servicio del cajero tiene una distribución <span class="math inline">\(Exp(\mu)\)</span>.</p>
<p>En esta situación la variable <span class="math inline">\(X_t\)</span> que indica el número de sujetos en el sistema en el instante <span class="math inline">\(t\)</span> es una CMTC denominada cola <span class="math inline">\(M/M/1/K\)</span>, donde <span class="math inline">\(M\)</span> hace referencia a los tiempos de llegada y servicio exponenciales, el <span class="math inline">\(1\)</span> hace referencia a la capacidad del servicio (sólo hay un cajero, luego sólo un cliente puede ser atendido en un instante dado), <span class="math inline">\(K\)</span> es la capacidad del sistema (o aforo total), y <span class="math inline">\(S = \{0, 1, 2,...K \}\)</span> el espacio de estados. Este tipo de sistemas son procesos de nacimiento y muerte con:</p>
<span class="math display">\[\begin{eqnarray*}
\lambda_i &amp;=&amp; \lambda, \quad 0 \leq i \leq K-1, \\
\mu_i &amp;=&amp; \mu, \quad 1 \leq i \leq K,
\end{eqnarray*}\]</span>
<p>donde el “nacimiento” y la “muerte” hacen referencia a la llegada y la salida del cajero respectivamente.</p>
<p>Veamos la descripción del sistema:</p>
<ul>
<li><p>En el estado <span class="math inline">\(X_t=0\)</span> el sistema está vacío y el único evento que puede ocurrir es una llegada, que se produce después de un tiempo <span class="math inline">\(h \sim Exp(\lambda)\)</span>, provocando una transición al estado <span class="math inline">\(X_{t+h}=1\)</span>. En este caso <span class="math inline">\(r_{01} = \lambda\)</span>.</p></li>
<li><p>En el estado <span class="math inline">\(i\)</span> (<span class="math inline">\(1 \leq i \leq K-1\)</span>), tenemos dos posibilidades en el sistema: una llegada o una salida. En el primer caso tenemos <span class="math inline">\(r_{i, i+1} = \lambda\)</span>, mientras que en el segundo tenemos <span class="math inline">\(r_{i, i-1} = \mu\)</span>.</p></li>
<li><p>En el estado <span class="math inline">\(X_t=K\)</span> sólo se puede producir una salida de forma que <span class="math inline">\(r_{K, K-1} = \mu\)</span>.</p></li>
</ul>
<p>Por tanto, la matriz de tasas correspondiente a este proceso viene dada por:</p>
<p><span class="math display">\[R = 
\begin{pmatrix}
0 &amp; \lambda &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; 0 \\
\mu &amp; 0 &amp; \lambda &amp; 0 &amp; \ldots &amp; 0 &amp; 0 \\
0 &amp; \mu &amp; 0 &amp; \lambda &amp; \ldots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ldots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; \lambda \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \ldots &amp;\mu &amp; 0
\end{pmatrix} \]</span></p>
<p>El diagrama de tasas para una cola <span class="math inline">\(M/M/1/4\)</span>, es decir con una capacidad de 4 usuarios en el sistema (1 atendido y tres en espera) es:</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:05-028"></span>
<img src="04-CMTC_files/figure-html/05-028-1.png" alt="Diagrama de tasas para cola M/M/1/4." width="95%"><p class="caption">
Figura 4.6: Diagrama de tasas para cola M/M/1/4.
</p>
</div>
<p>Este sistema puede implementarse fácilmente en <code>simmer</code> si entendemos como recursos (<em>resource</em>) el cajero, con un tiempo de servicio dado por <span class="math inline">\(Exp(\mu)\)</span> y como fuentes (<em>generator</em>) la llegada de clientes al cajero, con tiempos entre llegadas <span class="math inline">\(Exp(\lambda)\)</span>. Escribimos el algoritmo de forma general para cualquier valor de <span class="math inline">\(K\)</span>.</p>
<div class="sourceCode" id="cb458"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Sistema</span>
<span class="co">#################################################</span>
<span class="va">cola.MM1K</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>, <span class="va">mu</span>, <span class="va">servidores</span>, <span class="va">usuarios</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># lambda: tasa de llegadas</span>
  <span class="co"># mu: tasa de servicio</span>
  <span class="co"># servidores: número de servidores</span>
  <span class="co"># usuarios: capacidad total del sistema</span>
  <span class="va">cola</span> <span class="op">&lt;-</span> <span class="va">usuarios</span> <span class="op">-</span> <span class="va">servidores</span>
  
  <span class="va">servicio</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-simmer.org/reference/trajectory.html">trajectory</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="co"># empieza a ser atendido</span>
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">seize</a></span><span class="op">(</span><span class="st">"atendiendo"</span>, amount <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>   
    <span class="co"># durante un tiempo exp(mu)</span>
    <span class="fu"><a href="https://r-simmer.org/reference/timeout.html">timeout</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">mu</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
    <span class="co"># termina el servicio de atención</span>
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">release</a></span><span class="op">(</span><span class="st">"atendiendo"</span>, amount <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>               

  <span class="co"># Configuración del sistema </span>
  <span class="co">#################################################</span>
  <span class="fu"><a href="https://r-simmer.org/reference/simmer.html">simmer</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="co"># se crean los recursos (servidores) y se dimensiona la cola</span>
    <span class="fu"><a href="https://r-simmer.org/reference/add_resource.html">add_resource</a></span><span class="op">(</span><span class="st">"atendiendo"</span>, capacity <span class="op">=</span> <span class="va">servidores</span>, queue_size <span class="op">=</span> <span class="va">cola</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>    
    <span class="co"># se generan las llegadas de clientes según Exp(lambda)</span>
    <span class="fu"><a href="https://r-simmer.org/reference/add_generator.html">add_generator</a></span><span class="op">(</span><span class="st">"llegada"</span>, <span class="va">servicio</span>, <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">lambda</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
    <span class="fu"><a href="https://r-simmer.org/reference/run.html">run</a></span><span class="op">(</span>until <span class="op">=</span> <span class="va">t</span><span class="op">)</span>     
<span class="op">}</span></code></pre></div>
<div class="example">
<p><span id="exm:unlabeled-div-38" class="example"><strong>Ejemplo 4.6  </strong></span>Imaginemos que por la mañanas (de 8 a 15) las llegadas de clientes se producen con una tasa de 15 clientes/hora, mientras que el tiempo medio que el cliente permanece en el cajero es de 6 minutos. Expresada en minutos tendríamos una tasa de llegadas <span class="math inline">\(\lambda = 15/60\)</span>, y una tasa de servicio <span class="math inline">\(\mu = 1/6\)</span>. Se ha observado además que cuando la cola de espera es de tres clientes nadie más espera para hacer cola (<span class="math inline">\(K = 4\)</span>). Analizamos el sistema de forma básica para una mañana cualquiera, es decir para un periodo de 7 horas (420 minutos).</p>
</div>
<div class="sourceCode" id="cb459"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12</span><span class="op">)</span>
<span class="co">### Simulación del sistema</span>
<span class="va">t</span><span class="op">=</span><span class="fl">420</span>; 
<span class="va">lambda</span><span class="op">=</span><span class="fl">15</span><span class="op">/</span><span class="fl">60</span>; <span class="va">mu</span><span class="op">=</span><span class="fl">1</span><span class="op">/</span><span class="fl">6</span>
<span class="va">servidores</span><span class="op">=</span><span class="fl">1</span>; <span class="va">usuarios</span><span class="op">=</span><span class="fl">4</span>
<span class="va">cajero</span> <span class="op">&lt;-</span> <span class="fu">cola.MM1K</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>, <span class="va">mu</span>, <span class="va">servidores</span>, <span class="va">usuarios</span><span class="op">)</span>
<span class="co">### Salidas del sistema</span>
<span class="va">cajero.df.res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_resources</a></span><span class="op">(</span><span class="va">cajero</span><span class="op">)</span>  <span class="co"># recursos (servidores)</span>
<span class="va">cajero.df.arr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals</a></span><span class="op">(</span><span class="va">cajero</span><span class="op">)</span>   <span class="co"># llegadas (clientes)</span></code></pre></div>
<p>Veamos con un poco de detalle las salidas que proporciona el sistema. Comenzamos con el proceso de llegadas al sistema viendo las primeras 10 llegadas al sistema:</p>
<div class="sourceCode" id="cb460"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># llegadas</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">cajero.df.arr</span>, n <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></code></pre></div>
<pre><code>##         name start_time  end_time activity_time finished replication
## 1   llegada0   8.756865  9.461164      0.704299     TRUE           1
## 2   llegada1  11.299066 22.198513     10.899446     TRUE           1
## 3   llegada2  22.728061 46.307530     23.579469     TRUE           1
## 4   llegada7  53.191599 53.191599      0.000000    FALSE           1
## 5   llegada3  23.861384 53.496376      7.188846     TRUE           1
## 6   llegada9  57.528321 57.528321      0.000000    FALSE           1
## 7   llegada4  40.759227 59.558394      6.062018     TRUE           1
## 8  llegada11  68.130173 68.130173      0.000000    FALSE           1
## 9  llegada12  74.418248 74.418248      0.000000    FALSE           1
## 10  llegada5  45.814971 75.428935     15.870541     TRUE           1</code></pre>
<p>En la columna <code>name</code> tenemos el identificador de la llegada al sistema (cajero), en las columnas <code>start_time</code> y <code>end_time</code> tenemos el instante de tiempo en el que llega y sale del cajero. La columna <code>activity_time</code> muestra el tiempo de servicio en el cajero (durante el que es atendido el cliente); un valor 0 identifica a un cliente que no ha sido atendido porque sobrepasó la capacidad del sistema (no esperó al ver la cola y se marchó). Estos coinciden con los valores <code>FALSE</code> de la columna <code>finished</code>, que identifica a los clientes que no han podido ser atendidos. Con estas salidas resulta muy fácil calcular el tiempo de servicio del sistema así como el porcentaje de clientes rechazados, y el tiempo esperando en la cola.</p>
<div class="sourceCode" id="cb462"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># llegadas al sistema: número de clientes que han pasado por el cajero</span>
<span class="va">nsis</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">cajero.df.arr</span><span class="op">)</span>;<span class="va">nsis</span></code></pre></div>
<pre><code>## [1] 108</code></pre>
<div class="sourceCode" id="cb464"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># tiempo total de servicio</span>
<span class="va">tserver</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">cajero.df.arr</span><span class="op">$</span><span class="va">activity_time</span><span class="op">)</span>;<span class="va">tserver</span></code></pre></div>
<pre><code>## [1] 407.9837</code></pre>
<div class="sourceCode" id="cb466"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># proporción de tiempo que el sistema está ocupado (atendiendo o en espera)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">100</span><span class="op">*</span><span class="va">tserver</span><span class="op">/</span><span class="va">t</span>,<span class="fl">2</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 97.14</code></pre>
<div class="sourceCode" id="cb468"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># porcentaje de clientes que se marcharon sin ser atendidos</span>
<span class="va">rechazados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">cajero.df.arr</span><span class="op">$</span><span class="va">finished</span> <span class="op">==</span> <span class="cn">FALSE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">100</span><span class="op">*</span><span class="va">rechazados</span><span class="op">/</span><span class="va">nsis</span>,<span class="fl">2</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 48.15</code></pre>
<div class="sourceCode" id="cb470"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Tiempos de espera en cola para ser atendido</span>
<span class="va">tespera</span> <span class="op">&lt;-</span> <span class="va">cajero.df.arr</span><span class="op">$</span><span class="va">end_time</span> <span class="op">-</span> <span class="va">cajero.df.arr</span><span class="op">$</span><span class="va">start_time</span> <span class="op">-</span> <span class="va">cajero.df.arr</span><span class="op">$</span><span class="va">activity_time</span>
<span class="co"># tiempo medio de espera en cola y desv.típica</span>
<span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">tespera</span><span class="op">)</span>;<span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">tespera</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 8.280251</code></pre>
<pre><code>## [1] 10.53434</code></pre>
<p>Podemos estudiar el comportamiento del sistema, y en particular de la cola, también en términos de los servidores.</p>
<div class="sourceCode" id="cb473"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">cajero.df.res</span>, n <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></code></pre></div>
<pre><code>##      resource      time server queue capacity queue_size system limit replication
## 1  atendiendo  8.756865      1     0        1          3      1     4           1
## 2  atendiendo  9.461164      0     0        1          3      0     4           1
## 3  atendiendo 11.299066      1     0        1          3      1     4           1
## 4  atendiendo 22.198513      0     0        1          3      0     4           1
## 5  atendiendo 22.728061      1     0        1          3      1     4           1
## 6  atendiendo 23.861384      1     1        1          3      2     4           1
## 7  atendiendo 40.759227      1     2        1          3      3     4           1
## 8  atendiendo 45.814971      1     3        1          3      4     4           1
## 9  atendiendo 46.307530      1     2        1          3      3     4           1
## 10 atendiendo 48.326016      1     3        1          3      4     4           1</code></pre>
<p>En este caso las columnas nos informan sobre el instante de tiempo (<code>time</code>) en el que se produce alguna actividad en el sistema, la columna <code>server</code> indica el número de servidores ocupados atendiendo a algún cliente, <code>queue</code> el número de clientes en la cola de espera, <code>capacity</code> la capacidad de servicio del sistema, <code>queue_size</code> el tamaño máximo de la cola, <code>system</code> el número de clientes en el sistema, <code>limit</code> la capacidad total de sistema, y finalmente <code>replication</code> da un indicador de la replicación de las simulaciones.</p>
<p>Con estas salidas podemos describir fácilmente el comportamiento de la cola del sistema ya que podemos estudiar el número de clientes en cola a lo largo del tiempo.</p>
<div class="sourceCode" id="cb475"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Evolución del tamaño de la cola</span>
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="va">cajero.df.res</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span><span class="va">time</span>, <span class="va">queue</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html">geom_step</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html">scale_x_continuous</a></span><span class="op">(</span>breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">420</span>, <span class="fl">60</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">labs</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"Tiempo (en minutos)"</span>, y <span class="op">=</span> <span class="st">"Tamaño de la cola"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="04-CMTC_files/figure-html/05-034-1.png" width="95%" style="display: block; margin: auto;"></div>
<div class="sourceCode" id="cb476"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Porcentaje de clientes en cola</span>
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="va">cajero.df.res</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">queue</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_bar.html">geom_bar</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">..prop..</span> , group <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html">scale_y_continuous</a></span><span class="op">(</span>labels <span class="op">=</span> <span class="fu">scales</span><span class="fu">::</span><span class="va"><a href="https://scales.r-lib.org/reference/percent_format.html">percent</a></span><span class="op">)</span> <span class="op">+</span> 
  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">labs</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"Clientes en la cola"</span>, y <span class="op">=</span> <span class="st">"Porcentaje"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="04-CMTC_files/figure-html/05-034-2.png" width="95%" style="display: block; margin: auto;"></div>
<p>Simulamos ahora el sistema para 500 jornadas con las que inferir sobre el comportamiento medio del sistema.</p>
<div class="sourceCode" id="cb477"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Réplicas del sistema</span>
<span class="va">nreplicas</span><span class="op">=</span><span class="fl">500</span>
<span class="va">t</span><span class="op">=</span><span class="fl">420</span>; 
<span class="va">lambda</span><span class="op">=</span><span class="fl">15</span><span class="op">/</span><span class="fl">60</span>; <span class="va">mu</span><span class="op">=</span><span class="fl">1</span><span class="op">/</span><span class="fl">6</span>
<span class="va">servidores</span><span class="op">=</span><span class="fl">1</span>; <span class="va">usuarios</span><span class="op">=</span><span class="fl">4</span>

<span class="va">envs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">replicate</a></span><span class="op">(</span><span class="va">nreplicas</span>,<span class="fu">cola.MM1K</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>, <span class="va">mu</span>, <span class="va">servidores</span>, <span class="va">usuarios</span><span class="op">)</span><span class="op">)</span>
<span class="co"># almacenamos análisis de llegadas del sistema</span>
<span class="va">simarrivals</span><span class="op">&lt;-</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals</a></span><span class="op">(</span><span class="va">envs</span><span class="op">)</span><span class="op">)</span>

<span class="va">salida</span><span class="op">&lt;-</span><span class="va">simarrivals</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">replication</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="co"># Resumen de las simualciones</span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>clientes <span class="op">=</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/context.html">n</a></span><span class="op">(</span><span class="op">)</span>, 
            tiemposervicio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">activity_time</span><span class="op">)</span>,
            proptiemposervicio <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">tiemposervicio</span><span class="op">/</span><span class="fl">420</span>, <span class="fl">2</span><span class="op">)</span>,
            rechazados <span class="op">=</span> <span class="va">clientes</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">finished</span><span class="op">)</span>,
            proprechazados <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">rechazados</span><span class="op">/</span><span class="va">clientes</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>media_clientes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">clientes</span><span class="op">)</span>,
            media_tserver <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">tiemposervicio</span><span class="op">)</span>,
            media_ptserver <span class="op">=</span> <span class="fl">100</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">proptiemposervicio</span><span class="op">)</span>,
            media_rechazados <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">rechazados</span><span class="op">)</span>,
            media_prechazados <span class="op">=</span> <span class="fl">100</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">proprechazados</span><span class="op">)</span>
            <span class="op">)</span>
<span class="va">salida</span></code></pre></div>
<pre><code>## # A tibble: 1 × 5
##   media_clientes media_tserver media_ptserver media_rechazados media_prechazados
##            &lt;dbl&gt;         &lt;dbl&gt;          &lt;dbl&gt;            &lt;dbl&gt;             &lt;dbl&gt;
## 1           102.          377.           89.8             37.9              36.7</code></pre>
<blockquote>
<p>Para comentar: ¿Qué conclusiones extraemos del análisis realizado? ¿Cómo valorarías la ocupación del sistema? ¿Qué ocurriría si añadimos un nuevo cajero y ampliamos la capacidad del sistema a 8 clientes?</p>
</blockquote>
</div>
<div id="excmtc007" class="section level3" number="4.4.2">
<h3>
<span class="header-section-number">4.4.2</span> Mantenimiento de máquinas<a class="anchor" aria-label="anchor" href="#excmtc007"><i class="fas fa-link"></i></a>
</h3>
<p>El problema del mantenimiento de máquinas es muy habitual dentro de las CMTC. Supongamos que disponemos de <span class="math inline">\(N\)</span> máquinas que funcionan durante 24 horas seguidas y <span class="math inline">\(M\)</span> personas que pueden repararlas (<span class="math inline">\(M \leq N\)</span>). Las máquinas son idénticas, y los tiempos de vida de las máquinas (tiempo hasta fallo o mantenimiento) son variables aleatorias independientes <span class="math inline">\(Exp(\lambda)\)</span>. Cuando las máquinas fallan, son reparadas por orden de fallo (la primera que falla es la primera en ser reparada) por los <span class="math inline">\(M\)</span> reparadores. Cada máquina averiada necesita una y sólo una persona para repararla, y los tiempos de reparación se distribuyen como una <span class="math inline">\(Exp(\mu)\)</span>; una vez reparada, la máquina continúa comportándose como una máquina nueva. Si <span class="math inline">\(X_t\)</span> es el número de máquinas estropeadas en el momento <span class="math inline">\(t\)</span>, el proceso <span class="math inline">\(\{X_t, t \geq 0\}\)</span> es un proceso de nacimiento (avería) y muerte (reparación) con parámetros:</p>
<span class="math display">\[\begin{eqnarray*}
\lambda_i &amp;=&amp; \lambda \cdot (N-i), \quad 0 \leq i &lt; N\\
\mu_i &amp;=&amp; \mu \cdot min(i,M), \quad 0 &lt; i \leq N \\
\end{eqnarray*}\]</span>
<div class="example">
<p><span id="exm:unlabeled-div-39" class="example"><strong>Ejemplo 4.7  </strong></span>Supongamos el problema de mantenimiento de máquinas en el que tenemos 4 máquinas y 2 reparadores. El espacio de estados (número de máquinas estropeadas) viene dado por <span class="math inline">\(S = \{0, 1, 2, 3, 4\}\)</span>.</p>
<p>La empresa está interesada en saber:</p>
<ul>
<li>¿Cuántas máquinas estarán en funcionamiento después de una semana?</li>
<li>¿Cuánto tiempo están funcionando a la vez las cuatro máquinas (en términos porcentuales)?</li>
<li>¿Cuánto tiempo de funcionamiento se pierde por averías?</li>
</ul>
</div>
<p>Comprobemos que podemos modelizar el sistema como un proceso de nacimiento-muerte.</p>
<p>Descripción del sistema:</p>
<ul>
<li><p>En el estado <span class="math inline">\(X_t=0\)</span>, ninguna máquina está estropeada. Cuando ocurra una avería en un instante <span class="math inline">\(Exp(\lambda)\)</span>, tendremos 1 máquina estropeada, y la tasa de nacimientos (averías) cuando hay 0 averías es igual a la tasa de averías multiplicada por el número de máquinas que pueden estropearse, esto es, <span class="math inline">\(r_{01}=\lambda_0=4\lambda\)</span>.</p></li>
<li><p>En el estado <span class="math inline">\(X_t=1\)</span> sólo una máquina está estropeada, de modo que entra en reparación. Las otras tres están en funcionamiento, de modo que la tasa de transición al estado 2, esto es, que una máquina más se estropee, será de <span class="math inline">\(r_{12}=\lambda_1=3\lambda\)</span>. Por otro lado, la tasa de reparación será <span class="math inline">\(r_{10}=\mu_1=\mu\)</span>.</p></li>
<li><p>En el estado <span class="math inline">\(X_t=2\)</span>, con razonamientos similares, tendremos que <span class="math inline">\(r_{23} = \lambda_2 = 2\lambda\)</span> y <span class="math inline">\(r_{21} = \mu_2 = 2\mu\)</span>.</p></li>
<li><p>Para el resto de estados tendremos que <span class="math inline">\(r_{34} = \lambda_3 = \lambda\)</span>, <span class="math inline">\(r_{32} = mu_3 = 3\mu\)</span>, y <span class="math inline">\(r_{43} = \mu_4 = 4\mu\)</span>.</p></li>
</ul>
<p>En esta situación el diagrama del proceso viene dado por:</p>
<div class="sourceCode" id="cb479"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">estados</span><span class="op">)</span>

<span class="va">M</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="va">M</span><span class="op">)</span>

<span class="va">R</span><span class="op">[[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"4*lambda"</span> 
<span class="va">R</span><span class="op">[[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"mu"</span> 
<span class="va">R</span><span class="op">[[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"3*lambda"</span> 
<span class="va">R</span><span class="op">[[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"2*mu"</span> 
<span class="va">R</span><span class="op">[[</span><span class="fl">3</span>,<span class="fl">4</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"2*lambda"</span> 
<span class="va">R</span><span class="op">[[</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"2*mu"</span> 
<span class="va">R</span><span class="op">[[</span><span class="fl">4</span>,<span class="fl">5</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"lambda"</span>
<span class="va">R</span><span class="op">[[</span><span class="fl">5</span>,<span class="fl">4</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"2*mu"</span>

<span class="co"># library(diagram)</span>
<span class="va">pp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/diagram/man/plotmat.html">plotmat</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span>,  pos <span class="op">=</span> <span class="fl">5</span>, curve <span class="op">=</span> <span class="fl">0.5</span>, name <span class="op">=</span> <span class="va">estados</span>,
              lwd <span class="op">=</span> <span class="fl">1</span>, box.lwd <span class="op">=</span> <span class="fl">2</span>, cex.txt <span class="op">=</span> <span class="fl">0.8</span>,
              box.type <span class="op">=</span> <span class="st">"circle"</span>, box.prop <span class="op">=</span> <span class="fl">0.5</span>, arr.type <span class="op">=</span> <span class="st">"triangle"</span>,
              arr.pos <span class="op">=</span> <span class="fl">0.55</span>, self.cex <span class="op">=</span> <span class="fl">0.6</span>,  
              shadow.size <span class="op">=</span> <span class="fl">0.01</span>, prefix <span class="op">=</span> <span class="st">""</span>, endhead <span class="op">=</span> <span class="cn">FALSE</span>, main <span class="op">=</span> <span class="st">""</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:05-036"></span>
<img src="04-CMTC_files/figure-html/05-036-1.png" alt="Diagrama de tasas para el mantenimiento de máquinas" width="95%"><p class="caption">
Figura 4.7: Diagrama de tasas para el mantenimiento de máquinas
</p>
</div>
<p>Este sistema se puede modelizar fácilmente en <code>simmer</code> sin más que fijar las tasas correspondientes, el número de máquinas disponibles, y el número de operarios. Supongamos que los tiempos de vida de las máquinas son variables aleatorias exponenciales con media de 3 días, mientras que los tiempos de reparación son variables exponenciales con media de 2 horas. Expresando todo en horas, tendríamos una tasa de reparación de <span class="math inline">\(\mu = 1/2\)</span>, y una tasa de llegadas (averías) <span class="math inline">\(\lambda = 1/72\)</span>.</p>
<p>De nuevo planteamos una función que nos permita cambiar fácilmente los parámetros del sistema si fuera necesario. Para simular el sistema hemos de considerar que tenemos 4 máquinas idénticas que cuando se averían han de ser reparadas hasta volver a estar operativas y, en consecuencia, poder volver a estropearse. Es preciso pues, diferenciar las 4 máquinas y utilizar activadores y desactivadores que avisen al sistema de simulación de qué máquina está estropeada y cuál operativa y puede volver a averiarse.</p>
<div class="sourceCode" id="cb480"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Sistema</span>
<span class="co">#################################################</span>
<span class="va">mantenimiento</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>, <span class="va">mu</span>, <span class="va">capacidad</span>,<span class="va">K</span><span class="op">)</span>
<span class="op">{</span>
  <span class="va">env</span><span class="op">=</span><span class="fu"><a href="https://r-simmer.org/reference/simmer.html">simmer</a></span><span class="op">(</span><span class="op">)</span>
  <span class="co"># lambda: tasa de averías</span>
  <span class="co"># mu: tasa de reparación</span>
  <span class="co"># capacidad: reparadores</span>
  <span class="co"># K: máquinas</span>

  <span class="va">reparacion</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">{</span>
    <span class="fu"><a href="https://r-simmer.org/reference/trajectory.html">trajectory</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="co"># mientras reparo la máquina no se puede producir otro fallo</span>
    <span class="fu"><a href="https://r-simmer.org/reference/activate.html">deactivate</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"maq"</span>,<span class="va">i</span>,<span class="st">"_"</span><span class="op">)</span><span class="op">)</span><span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">seize</a></span><span class="op">(</span><span class="st">"mecanico"</span>,<span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="co"># tiempos de reparación </span>
    <span class="fu"><a href="https://r-simmer.org/reference/timeout.html">timeout</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>,<span class="va">mu</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/activate.html">activate</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"maq"</span>,<span class="va">i</span>,<span class="st">"_"</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">release</a></span><span class="op">(</span><span class="st">"mecanico"</span><span class="op">)</span><span class="op">}</span>

<span class="co"># simulación de averías para K máquinas</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">K</span><span class="op">)</span> <span class="va">env</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/add_generator.html">add_generator</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"maq"</span>,<span class="va">i</span>,<span class="st">"_"</span><span class="op">)</span>,<span class="fu">reparacion</span><span class="op">(</span><span class="va">i</span><span class="op">)</span>,<span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>,<span class="va">lambda</span><span class="op">)</span><span class="op">)</span> 
    
<span class="va">env</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>  
  <span class="fu"><a href="https://r-simmer.org/reference/add_resource.html">add_resource</a></span><span class="op">(</span><span class="st">"mecanico"</span>, capacity <span class="op">=</span> <span class="va">capacidad</span><span class="op">)</span><span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://r-simmer.org/reference/run.html">run</a></span><span class="op">(</span>until <span class="op">=</span> <span class="va">t</span><span class="op">)</span>     
<span class="op">}</span></code></pre></div>
<p>Simulamos el sistema y analizamos la salida.</p>
<div class="sourceCode" id="cb481"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t</span><span class="op">=</span><span class="fl">24</span><span class="op">*</span><span class="fl">7</span> <span class="co">#  tiempo de simulación (en horas)</span>
<span class="va">lambda</span><span class="op">=</span><span class="fl">1</span><span class="op">/</span><span class="fl">72</span>; <span class="va">mu</span><span class="op">=</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>
<span class="va">capacidad</span><span class="op">=</span><span class="fl">2</span> <span class="co"># nº reparadores</span>
<span class="va">K</span><span class="op">=</span><span class="fl">4</span> <span class="co"># nº máquinas</span>

<span class="co">### Simulación del sistema</span>
<span class="va">sim</span> <span class="op">&lt;-</span> <span class="fu">mantenimiento</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>,<span class="va">mu</span>, <span class="va">capacidad</span>,<span class="va">K</span><span class="op">)</span>

<span class="co">### Salidas del sistema</span>
<span class="va">sim.arr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals</a></span><span class="op">(</span><span class="va">sim</span><span class="op">)</span>
<span class="va">sim.res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_resources</a></span><span class="op">(</span><span class="va">sim</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">sim.arr</span>, <span class="fl">10</span><span class="op">)</span></code></pre></div>
<pre><code>##      name start_time  end_time activity_time finished replication
## 1  maq1_0   39.64840  40.91384     1.2654324     TRUE           1
## 2  maq2_0   63.84362  65.62617     1.7825544     TRUE           1
## 3  maq1_1   88.73081  92.10658     3.3757723     TRUE           1
## 4  maq4_0   96.17729  96.27956     0.1022763     TRUE           1
## 5  maq1_2  107.52619 108.46549     0.9393034     TRUE           1
## 6  maq3_0  109.80081 113.18065     3.3798393     TRUE           1
## 7  maq1_3  145.04424 146.34587     1.3016268     TRUE           1
## 8  maq1_4  148.19267 153.96245     5.7697764     TRUE           1
## 9  maq2_1  153.04616 156.24107     3.1949067     TRUE           1
## 10 maq2_2  158.09906 161.24654     3.1474876     TRUE           1</code></pre>
<div class="sourceCode" id="cb483"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">sim.res</span>, <span class="fl">10</span><span class="op">)</span></code></pre></div>
<pre><code>##    resource      time server queue capacity queue_size system limit replication
## 1  mecanico  39.64840      1     0        2        Inf      1   Inf           1
## 2  mecanico  40.91384      0     0        2        Inf      0   Inf           1
## 3  mecanico  63.84362      1     0        2        Inf      1   Inf           1
## 4  mecanico  65.62617      0     0        2        Inf      0   Inf           1
## 5  mecanico  88.73081      1     0        2        Inf      1   Inf           1
## 6  mecanico  92.10658      0     0        2        Inf      0   Inf           1
## 7  mecanico  96.17729      1     0        2        Inf      1   Inf           1
## 8  mecanico  96.27956      0     0        2        Inf      0   Inf           1
## 9  mecanico 107.52619      1     0        2        Inf      1   Inf           1
## 10 mecanico 108.46549      0     0        2        Inf      0   Inf           1</code></pre>
<p>Respondemos en primer lugar al número de máquinas en funcionamiento al cabo del tiempo simulado. Sabemos que el número de máquinas averiadas en un instante dado será igual al número de reparadores ocupados (<code>server</code>) más el número de máquinas en cola esperando ser reparadas (<code>queue</code>), o lo que es lo mismo, las máquinas que están en el sistema de reparación (<code>system</code>, en resources). Veamos pues, qué ocurre en el último instante en que se ha registrado alguna actividad en el sistema simulado, dado por la última fila en el dataframe de recursos.</p>
<div class="sourceCode" id="cb485"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># última iteración del sistema</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">sim.res</span>, <span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>##    resource    time server queue capacity queue_size system limit replication
## 22 mecanico 162.612      0     0        2        Inf      0   Inf           1</code></pre>
<div class="sourceCode" id="cb487"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># las que están estropeadas</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">sim.res</span>, <span class="fl">1</span><span class="op">)</span><span class="op">$</span><span class="va">system</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<div class="sourceCode" id="cb489"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># las que están en funcionamiento</span>
<span class="fl">4</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">sim.res</span>, <span class="fl">1</span><span class="op">)</span><span class="op">$</span><span class="va">system</span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<p>Para saber el tiempo que las cuatro máquinas han estado funcionando simultáneamente, identificamos en primer lugar en qué instantes las cuatro estaban operativas (<code>system=0</code>).</p>
<div class="sourceCode" id="cb491"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># identificamos instantes en que todas las máquinas están operativas</span>
<span class="va">sel</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">sim.res</span><span class="op">$</span><span class="va">system</span><span class="op">==</span><span class="fl">0</span><span class="op">)</span>
<span class="co"># calculamos todas las secciones de tiempo delimitadas por instantes en que se ha producido alguna actividad, junto con el final del periodo, t</span>
<span class="va">tiempos</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diff.html">diff</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">sim.res</span><span class="op">$</span><span class="va">time</span>,<span class="va">t</span><span class="op">)</span><span class="op">)</span>
<span class="co"># y sumamos las franjas en las que se ha mantenido el evento de interés, pasándolo a porcentaje</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tiempos</span><span class="op">[</span><span class="va">sel</span><span class="op">]</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span><span class="op">/</span><span class="va">t</span></code></pre></div>
<pre><code>## [1] 62.44074</code></pre>
<p>Por último buscamos responder la cuestión de cuánto tiempo de funcionamiento se pierde por averías. Para ello calculamos el tiempo total gastado en reparaciones (<code>activity_time</code> en arrivals), más el tiempo de esperas en cola, y lo restamos al tiempo total que deberían haber estado funcionando las máquinas.</p>
<div class="sourceCode" id="cb493"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># utilizamos la información en las llegadas maquinas.df.arr</span>
<span class="co"># tiempo total gastado en reparaciones (`activity_time`)</span>
<span class="va">t.repara</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">sim.arr</span><span class="op">$</span><span class="va">activity_time</span><span class="op">)</span>
<span class="co"># tiempo de esperas en cola</span>
<span class="va">t.cola</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">sim.arr</span><span class="op">$</span><span class="va">end_time</span><span class="op">-</span><span class="va">sim.arr</span><span class="op">$</span><span class="va">start_time</span><span class="op">-</span><span class="va">sim.arr</span><span class="op">$</span><span class="va">activity_time</span><span class="op">)</span>
<span class="co"># Porcentaje del tiempo total de funcionamiento en que han estado paradas las máquinas</span>
<span class="va">t.sinfun</span><span class="op">&lt;-</span> <span class="op">(</span><span class="va">t.repara</span><span class="op">+</span><span class="va">t.cola</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span><span class="op">/</span><span class="op">(</span><span class="fl">4</span><span class="op">*</span><span class="va">t</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">t.sinfun</span>,<span class="fl">2</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 3.63</code></pre>
<p>Para obtener una estimación y su error habremos de realizar estos cálculos para nreplicas (simulaciones) del sistema durante el periodo de interés.</p>
<div class="sourceCode" id="cb495"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">nreplicas</span><span class="op">&lt;-</span><span class="fl">500</span> <span class="co"># réplicas para estimación MC</span>
<span class="va">t</span><span class="op">=</span><span class="fl">24</span><span class="op">*</span><span class="fl">7</span> <span class="co">#  tiempo de simulación (en horas)</span>
<span class="va">lambda</span><span class="op">=</span><span class="fl">1</span><span class="op">/</span><span class="fl">72</span>; <span class="va">mu</span><span class="op">=</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>
<span class="va">capacidad</span><span class="op">=</span><span class="fl">2</span> <span class="co"># nº reparadores</span>
<span class="va">K</span><span class="op">=</span><span class="fl">4</span> <span class="co"># nº máquinas</span>

<span class="va">envs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">nreplicas</span>, <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">{</span>
   <span class="fu">mantenimiento</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>,<span class="va">mu</span>, <span class="va">capacidad</span>,<span class="va">K</span><span class="op">)</span><span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/wrap.html">wrap</a></span><span class="op">(</span><span class="op">)</span><span class="op">}</span>,mc.set.seed<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>

<span class="co"># almacenamos análisis de llegadas del sistema</span>
<span class="va">sim.arr</span><span class="op">&lt;-</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals</a></span><span class="op">(</span><span class="va">envs</span><span class="op">)</span><span class="op">)</span>
<span class="co"># almacenamos análisis de recursos del sistema</span>
<span class="va">sim.res</span><span class="op">&lt;-</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_resources</a></span><span class="op">(</span><span class="va">envs</span><span class="op">)</span><span class="op">)</span>

<span class="co"># y procedemos con los cálculos</span>
<span class="co"># número de máquinas operativas al final</span>
<span class="va">operativas</span><span class="op">=</span><span class="va">sim.res</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">replication</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarize</a></span><span class="op">(</span>n<span class="op">=</span><span class="fl">4</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">system</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span>
<span class="va">m</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">operativas</span><span class="op">$</span><span class="va">n</span><span class="op">)</span>
<span class="va">error</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">operativas</span><span class="op">$</span><span class="va">n</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">nreplicas</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n Máquinas operativas después de una semana: "</span>,<span class="va">m</span>,<span class="st">"(error="</span>,<span class="va">error</span>,<span class="st">")"</span><span class="op">)</span></code></pre></div>
<pre><code>## 
##  Máquinas operativas después de una semana:  3.872 (error= 0.01648562 )</code></pre>
<div class="sourceCode" id="cb497"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># tiempo en funcionamiento todas las máquinas a la vez</span>
<span class="va">fun.todas</span> <span class="op">=</span> <span class="va">sim.res</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">replication</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>dif<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/diff.html">diff</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">time</span>,<span class="va">t</span><span class="op">)</span><span class="op">)</span>,
         system0<span class="op">=</span><span class="op">(</span><span class="va">system</span><span class="op">==</span><span class="fl">0</span><span class="op">)</span><span class="op">*</span><span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">system0</span><span class="op">==</span><span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>tiempos<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">dif</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span><span class="op">/</span><span class="va">t</span><span class="op">)</span>

<span class="va">m</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">fun.todas</span><span class="op">$</span><span class="va">tiempos</span><span class="op">)</span>
<span class="va">error</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">fun.todas</span><span class="op">$</span><span class="va">tiempos</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">nreplicas</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n % Tiempo en que han funcionado simultáneamente todas las máquinas: "</span>,<span class="va">m</span>,<span class="st">"% (error="</span>,<span class="va">error</span>,<span class="st">"%)"</span><span class="op">)</span></code></pre></div>
<pre><code>## 
##  % Tiempo en que han funcionado simultáneamente todas las máquinas:  77.98291 % (error= 0.5439864 %)</code></pre>
<div class="sourceCode" id="cb499"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># tiempo perdido en averías</span>
<span class="va">tpo.averias</span> <span class="op">=</span> <span class="va">sim.arr</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">replication</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>parones<span class="op">=</span><span class="va">end_time</span><span class="op">-</span><span class="va">start_time</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>tpo.parones<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">parones</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span><span class="op">/</span><span class="op">(</span><span class="fl">4</span><span class="op">*</span><span class="va">t</span><span class="op">)</span><span class="op">)</span> 

<span class="va">m</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">tpo.averias</span><span class="op">$</span><span class="va">tpo.parones</span><span class="op">)</span>
<span class="va">error</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">tpo.averias</span><span class="op">$</span><span class="va">tpo.parones</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">nreplicas</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n % Tiempo perdido por averías: "</span>,<span class="va">m</span>,<span class="st">"% (error="</span>,<span class="va">error</span>,<span class="st">"%)"</span><span class="op">)</span></code></pre></div>
<pre><code>## 
##  % Tiempo perdido por averías:  2.727233 % (error= 0.04885752 %)</code></pre>
</div>
<div id="centralTelefonica" class="section level3" number="4.4.3">
<h3>
<span class="header-section-number">4.4.3</span> Central telefónica<a class="anchor" aria-label="anchor" href="#centralTelefonica"><i class="fas fa-link"></i></a>
</h3>
<p>Una centralita telefónica puede atender <span class="math inline">\(K\)</span> llamadas a la vez en un momento dado. Las llamadas llegan según un proceso de Poisson con tasa <span class="math inline">\(\lambda\)</span>. Si la centralita ya está atendiendo <span class="math inline">\(K\)</span> llamadas cuando llega una nueva llamada, ésta se pierde. Si una llamada es aceptada, dura un tiempo <span class="math inline">\(Exp(\mu)\)</span> y luego termina. Todas las llamadas son independientes entre sí. Sea <span class="math inline">\(X_t\)</span> el número de llamadas que la centralita gestiona en el momento <span class="math inline">\(t\)</span>.</p>
<p>El proceso <span class="math inline">\(\{X_t; t \geq 0\}\)</span> es una CMTC con espacio de estados <span class="math inline">\(S = \{0, 1, 2,...,K\}\)</span> de forma que:</p>
<ul>
<li><p>En el estado <span class="math inline">\(i\)</span>, con <span class="math inline">\(0 \leq i \leq K-1\)</span> la llegada de una llamada desencadena una transición al estado <span class="math inline">\(i+1\)</span> con tasa <span class="math inline">\(r_{i, i+1} = \lambda\)</span>, mientras que en el estado <span class="math inline">\(K\)</span> no se pueden recibir llamadas, <span class="math inline">\(\lambda_K=0\)</span>.</p></li>
<li><p>En el estado <span class="math inline">\(i\)</span>, con <span class="math inline">\(1 \leq i \leq K\)</span> cualquiera de las llamadas <span class="math inline">\(i\)</span> puede completarse y desencadenar una transición al estado <span class="math inline">\(i-1\)</span>. La tasa de transición es <span class="math inline">\(r_{i ,i-1} = i\mu\)</span>. En el estado 0 no hay salidas, <span class="math inline">\(\mu_0=0\)</span>.</p></li>
</ul>
<p>El sistema <span class="math inline">\(\{X_t; t \geq 0\}\)</span> es un proceso de nacimiento y muerte con:</p>
<span class="math display">\[\begin{eqnarray*}
\lambda_i &amp;=&amp; \lambda, \quad 0 \leq i \leq K-1 \\
\mu_i&amp;=&amp; i\mu, \quad 0 &lt; i \leq K,
\end{eqnarray*}\]</span>
<p>que como veremos más adelante se denomina cola <span class="math inline">\(M/M/K/K\)</span>, es decir, llegadas y servicios exponenciales con <span class="math inline">\(K\)</span> servidores y de capacidad <span class="math inline">\(K\)</span>.</p>
<p>La función de <code>simmer</code> para estudiar este sistema viene dada por:</p>
<div class="sourceCode" id="cb501"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Sistema</span>
<span class="co">#################################################</span>
<span class="va">cola.MMKK</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t</span>, <span class="va">lambda</span>, <span class="va">mu</span>, <span class="va">servidores</span>, <span class="va">usuarios</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># lambda: tasa de llegadas</span>
  <span class="co"># mu: tasa de servicio</span>
  <span class="co"># servidores: número de servidores</span>
  <span class="co"># usuarios: capacidad total del sistema</span>
  <span class="va">cola</span> <span class="op">&lt;-</span> <span class="va">usuarios</span> <span class="op">-</span> <span class="va">servidores</span>
  
  <span class="va">servicio</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-simmer.org/reference/trajectory.html">trajectory</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">seize</a></span><span class="op">(</span><span class="st">"atendiendo"</span>, amount <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>              
    <span class="fu"><a href="https://r-simmer.org/reference/timeout.html">timeout</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">mu</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>   
    <span class="fu"><a href="https://r-simmer.org/reference/seize.html">release</a></span><span class="op">(</span><span class="st">"atendiendo"</span>, amount <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>               

  <span class="co"># Configuración del sistema </span>
  <span class="co">#################################################</span>
  <span class="fu"><a href="https://r-simmer.org/reference/simmer.html">simmer</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/add_resource.html">add_resource</a></span><span class="op">(</span><span class="st">"atendiendo"</span>, capacity <span class="op">=</span> <span class="va">servidores</span>, queue_size <span class="op">=</span> <span class="va">cola</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>           
    <span class="fu"><a href="https://r-simmer.org/reference/add_generator.html">add_generator</a></span><span class="op">(</span><span class="st">"llegada"</span>, <span class="va">servicio</span>, <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Exponential.html">rexp</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">lambda</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> 
    <span class="fu"><a href="https://r-simmer.org/reference/run.html">run</a></span><span class="op">(</span>until <span class="op">=</span> <span class="va">t</span><span class="op">)</span>     
<span class="op">}</span></code></pre></div>
</div>
<div id="call-center" class="section level3" number="4.4.4">
<h3>
<span class="header-section-number">4.4.4</span> Call Center<a class="anchor" aria-label="anchor" href="#call-center"><i class="fas fa-link"></i></a>
</h3>
<p>El sistema de reservas telefónicas de una aerolínea es un “call center” formado por <span class="math inline">\(s\)</span> empleados de reservas llamados agentes. Una llamada entrante para una reserva es atendida por un agente si hay uno disponible; de lo contrario, la persona que llama es puesta en espera. El sistema puede poner en espera a un máximo de <span class="math inline">\(H\)</span> personas. Cuando un agente está disponible, las llamadas en espera se atienden por orden de llegada. Cuando todos los agentes están ocupados y hay <span class="math inline">\(H\)</span> llamadas en espera, cualquier llamada adicional recibe una señal de ocupado y se pierde permanentemente. Sea <span class="math inline">\(X_t\)</span> la variable aleatoria que registra el número de llamadas en el sistema (atendidas y en espera). Si las llamadas entrantes se comportan como un <span class="math inline">\(PP(\lambda)\)</span> y los tiempos de procesamiento de las llamadas son variables aleatorias iid <span class="math inline">\(Exp(\mu)\)</span>, el sistema <span class="math inline">\(\{X_t; t \geq 0\}\)</span> es una CMTC con espacio de estados <span class="math inline">\(S = \{0, 1, 2,...,K\}\)</span>, donde <span class="math inline">\(K = s + H\)</span>.</p>
<p>Se puede demostrar fácilmente que este sistema, comúnmente conocido como cola <span class="math inline">\(M/M/s/K\)</span>, es un proceso de nacimiento y muerte con tasas:</p>
<span class="math display">\[\begin{eqnarray*}
\lambda_i &amp;=&amp; \lambda, \quad 0 \leq i \leq K-1 \\
\mu_i&amp;=&amp; min(i,s) \cdot \mu, \quad 0 &lt; i \leq K,
\end{eqnarray*}\]</span>
<p>Para simular este proceso podemos utilizar la función del ejemplo anterior.</p>
</div>
</div>
<div id="CMTCE" class="section level2" number="4.5">
<h2>
<span class="header-section-number">4.5</span> Otros tipos de sistemas<a class="anchor" aria-label="anchor" href="#CMTCE"><i class="fas fa-link"></i></a>
</h2>
<p>Presentamos a continuación otros sistemas que no se corresponden con procesos de nacimiento y muerte, pero que son muy habituales en el mundo real.</p>
<div id="gestInventcmtc" class="section level3" number="4.5.1">
<h3>
<span class="header-section-number">4.5.1</span> Gestión de inventarios<a class="anchor" aria-label="anchor" href="#gestInventcmtc"><i class="fas fa-link"></i></a>
</h3>
<p>Una tienda minorista gestiona el inventario de un tipo de producto, que denominamos <span class="math inline">\(P\)</span>, de la forma siguiente. Cuando el número de elementos de <span class="math inline">\(P\)</span> disminuye a un número fijo <span class="math inline">\(l\)</span>, se hace un pedido al fabricante de <span class="math inline">\(m\)</span> repuestos de <span class="math inline">\(P\)</span>. El pedido tarda un tiempo aleatorio en ser entregado al minorista. Si cuando se entrega el pedido, y una vez incluida la entrega, el inventario es a lo sumo de <span class="math inline">\(l\)</span>, entonces se realiza inmediatamente otro pedido de <span class="math inline">\(m\)</span> artículos. Supongamos que que los plazos de entrega son variables aleatorias iid <span class="math inline">\(Exp(\lambda)\)</span> y que la demanda se produce según un <span class="math inline">\(PP(\mu)\)</span>. Las demandas que no pueden ser satisfechas inmediatamente se pierden.</p>
<p>Sea <span class="math inline">\(X_t\)</span> el número de elementos de <span class="math inline">\(P\)</span> en stock en el momento <span class="math inline">\(t\)</span>. Obsérvese que el número máximo de elementos de <span class="math inline">\(P\)</span> en stock es <span class="math inline">\(K = l + m\)</span>, de modo que el espacio de estados es <span class="math inline">\(S = \{0, 1, 2,...,K\}\)</span>.</p>
<ul>
<li>En el estado <span class="math inline">\(0\)</span>, las demandas se pierden, y el stock salta a <span class="math inline">\(m\)</span> cuando se entrega el pedido pendiente actual, por lo que <span class="math inline">\(r_{0m} = \lambda\)</span>.</li>
<li>En el estado <span class="math inline">\(i\)</span>, <span class="math inline">\((1 \leq i \leq l)\)</span>, hay un pedido pendiente. El estado cambia a <span class="math inline">\(i-1\)</span> si se produce una demanda (a tasa <span class="math inline">\(\mu\)</span>) y a <span class="math inline">\(i + m\)</span> si se entrega el pedido. Por lo tanto, tenemos <span class="math inline">\(r_{i, i+m} = \lambda\)</span> y <span class="math inline">\(r_{i, i-1} = \mu\)</span>. Finalmente, si <span class="math inline">\(X_t = i\)</span>, con <span class="math inline">\(l + 1 \leq i \leq K\)</span>, no hay pedidos pendientes, y la única transición posible es de <span class="math inline">\(i\)</span> a <span class="math inline">\(i- 1\)</span> cuando se produce una demanda. Por lo tanto, <span class="math inline">\(r_{i, i-1} = \mu\)</span>.</li>
</ul>
<p>El proceso <span class="math inline">\(X_t, t \geq 0\)</span> definido de esta forma es pues una CMTC.</p>
<p>Si <span class="math inline">\(m=3\)</span> y <span class="math inline">\(l=2\)</span>, su matriz de tasas viene dada por:
<span class="math display">\[R=
\begin{pmatrix}
0&amp;0&amp;0&amp;\lambda&amp;0&amp;0 \\
\mu&amp;0&amp;0&amp;0&amp;\lambda&amp;0 \\
0&amp;\mu&amp;0&amp;0&amp;0&amp;\lambda \\
0&amp;0&amp;\mu&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;\mu&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;\mu&amp;0
\end{pmatrix}
\]</span>
Además, si <span class="math inline">\(0&lt;i\leq 2\)</span>, el tiempo de permanencia en un estado <span class="math inline">\(i\)</span> es el mínimo de los tiempos en que se recibe un pedido y aparece un cliente, por lo que se distribuye <span class="math inline">\(Exp(\lambda+\mu)\)</span> y la tasa de permanencia es <span class="math inline">\(r_i=\lambda+\mu\)</span>. Si <span class="math inline">\(i&gt;2\)</span>, entonces <span class="math inline">\(r_i=\mu\)</span> y <span class="math inline">\(r_0=\lambda\)</span>. La matriz generadora del proceso es:</p>
<p><span class="math display">\[Q=
\begin{pmatrix}
-\lambda&amp;0&amp;0&amp;\lambda&amp;0&amp;0 \\
\mu&amp;-(\lambda+\mu)&amp;0&amp;0&amp;\lambda&amp;0 \\
0&amp;\mu&amp;-(\lambda+\mu)&amp;0&amp;0&amp;\lambda \\
0&amp;0&amp;\mu&amp;-\mu&amp;0&amp;0\\
0&amp;0&amp;0&amp;\mu&amp;-\mu&amp;0\\
0&amp;0&amp;0&amp;0&amp;\mu&amp;-\mu
\end{pmatrix}
\]</span>
Tienes un ejemplo incompleto de sistema de inventario en esta <a href="https://stackoverflow.com/questions/51680140/immediate-inventory-restock-in-r-simmer">web</a>.</p>
</div>
<div id="fabricaCMTC" class="section level3" number="4.5.2">
<h3>
<span class="header-section-number">4.5.2</span> Proceso de fabricación<a class="anchor" aria-label="anchor" href="#fabricaCMTC"><i class="fas fa-link"></i></a>
</h3>
<p>Un proceso de de fabricación sencilla consiste en una sola máquina que puede estar encendida o apagada. Si la máquina está encendida, produce artículos según un proceso de Poisson con tasa <span class="math inline">\(\lambda\)</span>. La demanda de artículos llega según un <span class="math inline">\(PP(\mu)\)</span>. La máquina se controla de la siguiente manera. Si el número de artículos en stock alcanza un número máximo <span class="math inline">\(K\)</span> (la capacidad máxima del stock), la máquina se apaga. La máquina se enciende cuando el número de artículos en stock disminuye hasta un nivel preestablecido <span class="math inline">\(l &lt; K\)</span>. Si la variable aleatoria <span class="math inline">\(X_t\)</span> nos indica el número de artículos en stock en el momento <span class="math inline">\(t\)</span>, el proceso <span class="math inline">\(\{X_t, t \geq 0\}\)</span> no es una CMTC porque no sabemos si la máquina está apagada o encendida cuando <span class="math inline">\(l &lt; X_t &lt; K\)</span>. Si se considera <span class="math inline">\(Y_t\)</span> como el estado en el que se encuentra la máquina en el momento <span class="math inline">\(t\)</span>, de forma que un <span class="math inline">\(1\)</span> indica encendido y un <span class="math inline">\(0\)</span> apagado, entonces el proceso <span class="math inline">\(\{X_t, Y_t, t\geq 0\}\)</span> con espacio de estados <span class="math inline">\(S = \{(i, 1), 0 \leq i &lt; K\} \cup \{(i, 0), l &lt; i \leq K\}\)</span> sí que es modelizable como una CMTC.</p>
<p>Hay que tener en cuenta que la máquina siempre está encendida si el número de elementos es <span class="math inline">\(l\)</span> o menos, por lo que no aparecen los estados <span class="math inline">\(\{(i, 0), 0 \leq i \leq l\}\)</span>. El análisis habitual de los eventos desencadenantes arroja las siguientes tasas de transición:</p>
<span class="math display">\[\begin{eqnarray*}
r_{(i, 1),(i+1, 1)} &amp;=&amp; \lambda, \quad 0 \leq i &lt; K-1\\
r_{(K-1, 1),(K, 0)}&amp;=&amp; \lambda\\
r_{(i, 1),(i-1, 1)} &amp;=&amp; \mu, \quad 1\leq i\leq K-1\\
r_{(i, 0),(i-1, 0)} &amp;=&amp;  \mu, \quad l+1 &lt; i\leq K\\
r_{(l+1, 0),(l, 1)} &amp;=&amp;  \mu.
\end{eqnarray*}\]</span>
</div>
</div>
<div id="CMTCF" class="section level2" number="4.6">
<h2>
<span class="header-section-number">4.6</span> Análisis de transición<a class="anchor" aria-label="anchor" href="#CMTCF"><i class="fas fa-link"></i></a>
</h2>
<p>El aspecto fundamental para estudiar el comportamiento de cualquier CMTC es la obtención y análisis de la <strong>distribución de transición</strong> entre los estados del proceso, a partir de la matriz de tasas. Aunque haremos un desarrollo teórico de este problema, veremos que es necesario un algoritmo de computación para obtener dichas probabilidades.</p>
<p>Sea <span class="math inline">\(X_t, t \geq 0\)</span> una CMTC con espacio de estados <span class="math inline">\(S = \{1,2,...,N\}\)</span> y con matriz de tasas <span class="math inline">\(R = (r_{ij})_{i,j \in S}\)</span>. Si asumimos que la distribución de probabilidad en el estado inicial, <span class="math inline">\(X_0\)</span> es conocida, entonces tenemos que la distribución marginal que nos permite predecir la probabilidad de que en un instante dado <span class="math inline">\(t\)</span> el sistema esté en un estado cualquiera <span class="math inline">\(j\)</span>, viene dada por:</p>
<p><span class="math display">\[Pr[X_t = j] = \sum_{i=1}^N Pr[X_t = j | X_0 = i]\cdot Pr[X_0 = i], \quad 1 \leq j \leq N.\]</span> Es necesario pues para calcularla, obtener la distribución condicionada <span class="math inline">\(Pr[X_t = j | X_0 = i] = p_{ij}(t)\)</span>. Antes de ver cómo obtener dichas probabilidades, introducimos la notación necesaria.</p>
<p>Ya hemos visto antes que una CMTC permanece un tiempo <span class="math inline">\(Exp(r_i)\)</span> en el estado <span class="math inline">\(i\)</span> con <span class="math inline">\(r_i = \sum_{j=1}^N r_{ij}\)</span>, y si <span class="math inline">\(r_i &gt; 0\)</span> entonces pasamos al estado <span class="math inline">\(j\)</span> con probabilidad <span class="math inline">\(p_{ij} = r_{ij}/r_i\)</span>. Si <span class="math inline">\(r\)</span> es cualquier número finito mayor o igual que cualquiera de las tasas de permanencia <span class="math inline">\(r_i\)</span>,</p>
<p><span class="math display">\[r \geq max\{r_i, 1\leq i \leq N\}, \quad \]</span> podemos definir la matriz estocástica <span class="math inline">\(\hat{P} = (\hat{p}_{ij})\)</span> como:</p>
<span class="math display" id="eq:phatTransicion">\[\begin{equation}
\hat{p}_{ij} = 
\begin{cases} 
1-r_i/r &amp; \text{, si } i=j\\
r_{ij}/r &amp; \text{, si } i \neq j
\end{cases}
\tag{4.4}
\end{equation}\]</span>
<div class="theorem">
<p><span id="thm:unlabeled-div-40" class="theorem"><strong>Teorema 4.2  </strong></span>La matriz de probabilidades de transición <span class="math inline">\(P(t)=(p_{ij}(t))\)</span> de una CMTC, que contiene las probabilidades de pasar de un estado <span class="math inline">\(i\)</span> a otro <span class="math inline">\(j\)</span> en un periodo de amplitud <span class="math inline">\(t\)</span>, viene dada por:</p>
<p><span class="math display" id="eq:uniformizacion">\[\begin{equation}
P(t) = \sum_{k=0}^{\infty} e^{-rt}\frac{(rt)^k}{k!} \hat{P}^k
\tag{4.5}
\end{equation}\]</span> donde <span class="math inline">\(\hat{P}\)</span> es la matriz definida en la ecuación <a href="CMTC.html#eq:phatTransicion">(4.4)</a>.</p>
</div>
<p>Esta forma de obtener <span class="math inline">\(P(t)\)</span> dada en <a href="CMTC.html#eq:uniformizacion">(4.5)</a> se denomina <strong>método de uniformización</strong>, y proporciona un método numérico para obtener las probabilidades de transición deseadas, sin más que usar los <span class="math inline">\(m\)</span> primeros términos de la suma infinita definida en <a href="CMTC.html#eq:uniformizacion">(4.5)</a>:</p>
<span class="math display" id="eq:uniformizacionM">\[\begin{equation}
P(t)^* = \sum_{k=0}^{m} e^{-rt}\frac{(rt)^k}{k!} \hat{P}^k
\tag{4.6}
\end{equation}\]</span>
<p>Para asegurar la convergencia de la suma finita <a href="CMTC.html#eq:uniformizacionM">(4.6)</a>, se usan como reglas habituales:</p>
<p><span class="math display">\[m \approx max\{rt + r\sqrt{rt}, 20\},\]</span></p>
<p>y cuando <span class="math inline">\(rt\)</span> es pequeño, es más conveniente utilizar el valor de <span class="math inline">\(r\)</span> más pequeño que es mayor que todas las tasas de permanencia,</p>
<span class="math display" id="eq:rmax">\[\begin{equation}
r= max\{r_i, 1\leq i \leq N\}.
\tag{4.7}
\end{equation}\]</span>
<p>Con todo, en algunos casos es más conveniente utilizar un valor de <span class="math inline">\(r\)</span> que sea mayor que el anterior, como <span class="math inline">\(r=\sum_{i=1}^N r_i\)</span>.</p>
<div class="silverbox">
<p>Algoritmo de uniformización para obtener <span class="math inline">\(P\)</span> con una suma finita</p>
<ol style="list-style-type: decimal">
<li>Fijar la matriz de tasas <span class="math inline">\(R\)</span>, el instante de tiempo <span class="math inline">\(t\)</span>, y <span class="math inline">\(0 &lt; \epsilon &lt; 1\)</span> la tolerancia deseada (máximo error permitido). Por defecto fijamos <span class="math inline">\(\epsilon=0.00001\)</span>.</li>
<li>Obtener <span class="math inline">\(r\)</span> con <a href="CMTC.html#eq:rmax">(4.7)</a>.</li>
<li>Calcular <span class="math inline">\(\hat{P}=Phat\)</span> con la ecuación @ref(eq:phatTransicion}.</li>
<li>Inicializar <span class="math inline">\(A = \hat{P}\)</span>; <span class="math inline">\(c = e^{rt}\)</span>; <span class="math inline">\(B = e^{rt}I\)</span>; <span class="math inline">\(sum = c\)</span>; <span class="math inline">\(k=1\)</span>.</li>
<li>Mientras que <span class="math inline">\(sum &lt;1-\epsilon\)</span>, calcular:</li>
</ol>
<!-- --><pre><code>c = c*(rt)/k
B = B + cA
A = A * Phat
sum = sum + c
k = k + 1</code></pre>
<p>Al finalizar, la matriz <span class="math inline">\(B\)</span> es una aproximación de <span class="math inline">\(P(t)\)</span>, con error acotado por <span class="math inline">\(\epsilon \geq \sum_{k=m+1}^{\infty} e^{-rt} \frac{(rt)^k}{k!}\)</span>.</p>
</div>
<p>En nuestro algoritmo añadiremos un parámetro extra para indicar cómo se debe calcular el valor de <span class="math inline">\(r\)</span>, bien como el máximo o como la suma de las tasas de permanencia.</p>
<div class="sourceCode" id="cb503"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">matriz.prob.trans</span><span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">Rmat</span>, <span class="va">ts</span>, <span class="va">cal</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Algoritmo de uniformización para obtener P(t)</span>
  <span class="co">################################################</span>
  
  <span class="co"># Parámetros de la función</span>
  <span class="co"># Rmat: matriz de tasas </span>
  <span class="co"># ts: instante de tiempo</span>
  <span class="co"># epsilon: error en la aproximación</span>
  <span class="co"># cal: forma de obtener r, con dos valores 1 = máximo, 2 = suma finita</span>
  <span class="va">epsilon</span> <span class="op">&lt;-</span> <span class="fl">1e-05</span>
  <span class="co"># Paso 2. Cálculo de r</span>
  <span class="va">ris</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">Rmat</span>, <span class="fl">1</span>, <span class="va">sum</span><span class="op">)</span>
  <span class="va">rlimit</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">cal</span> <span class="op">==</span> <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">ris</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">Rmat</span><span class="op">)</span><span class="op">)</span>
  <span class="co"># Paso 3. Cálculo de hat(P)</span>
  <span class="va">hatP</span> <span class="op">&lt;-</span> <span class="va">Rmat</span><span class="op">/</span><span class="va">rlimit</span>
  <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">hatP</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">ris</span><span class="op">/</span><span class="va">rlimit</span>
  <span class="co"># Paso 4. Cálculo de matrices y vectores accesorios</span>
  <span class="va">rts</span> <span class="op">&lt;-</span> <span class="va">rlimit</span><span class="op">*</span><span class="va">ts</span>
  <span class="va">A</span> <span class="op">&lt;-</span> <span class="va">hatP</span>
  <span class="va">c</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">rts</span><span class="op">)</span>
  <span class="va">B</span> <span class="op">&lt;-</span> <span class="va">c</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">Rmat</span><span class="op">)</span><span class="op">)</span>
  <span class="va">suma</span> <span class="op">&lt;-</span> <span class="va">c</span>
  <span class="va">k</span> <span class="op">&lt;-</span> <span class="fl">1</span>
  <span class="co"># Bucle simulación</span>
  <span class="kw">while</span><span class="op">(</span><span class="va">suma</span> <span class="op">&lt;</span> <span class="op">(</span><span class="fl">1</span><span class="op">-</span> <span class="va">epsilon</span><span class="op">)</span><span class="op">)</span>
  <span class="op">{</span>
    <span class="va">c</span> <span class="op">&lt;-</span> <span class="va">c</span><span class="op">*</span><span class="va">rts</span><span class="op">/</span><span class="va">k</span>
    <span class="va">B</span> <span class="op">&lt;-</span> <span class="va">B</span> <span class="op">+</span> <span class="va">c</span><span class="op">*</span><span class="va">A</span>
    <span class="va">A</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span><span class="va">hatP</span>
    <span class="va">suma</span> <span class="op">&lt;-</span> <span class="va">suma</span> <span class="op">+</span> <span class="va">c</span>
    <span class="va">k</span> <span class="op">&lt;-</span> <span class="va">k</span> <span class="op">+</span> <span class="fl">1</span>
  <span class="op">}</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">B</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Veamos un ejemplo donde la matriz de tasas viene dada por:</p>
<div class="sourceCode" id="cb504"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">R</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">0</span>, <span class="fl">4</span>, <span class="fl">0</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">2</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">3</span>, <span class="fl">0</span><span class="op">)</span>, byrow <span class="op">=</span> <span class="cn">TRUE</span>, ncol <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></code></pre></div>
<p>Si estamos interesados en las probabilidades de transición entre estados cuando han transcurrido 2 unidades de tiempo, podemos calcular (ambas versiones):</p>
<div class="sourceCode" id="cb505"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ts</span><span class="op">=</span><span class="fl">2</span>
<span class="va">Pmat1</span><span class="op">&lt;-</span><span class="fu">matriz.prob.trans</span><span class="op">(</span><span class="va">R</span>, <span class="va">ts</span>, <span class="fl">1</span><span class="op">)</span>; <span class="va">Pmat1</span></code></pre></div>
<pre><code>##        [,1]   [,2] [,3]   [,4]
## [1,] 0.2001 0.2001  0.4 0.1998
## [2,] 0.2002 0.2001  0.4 0.1997
## [3,] 0.1999 0.2000  0.4 0.2001
## [4,] 0.1998 0.1999  0.4 0.2003</code></pre>
<div class="sourceCode" id="cb507"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">Pmat2</span><span class="op">&lt;-</span><span class="fu">matriz.prob.trans</span><span class="op">(</span><span class="va">R</span>, <span class="va">ts</span>, <span class="fl">2</span><span class="op">)</span>; <span class="va">Pmat2</span></code></pre></div>
<pre><code>##        [,1]   [,2] [,3]   [,4]
## [1,] 0.2001 0.2001  0.4 0.1998
## [2,] 0.2002 0.2001  0.4 0.1997
## [3,] 0.1999 0.2000  0.4 0.2001
## [4,] 0.1998 0.1999  0.4 0.2003</code></pre>
<p>Ambas matrices proporcionan un resultado prácticamente idéntico. Estas matrices nos permiten obtener las probabilidades de pasar del estado 1 a cualquiera de los otros estados en dos unidades de tiempo, sin más que tomar los elementos de la fila 1 de la matriz obtenida.</p>
<div class="sourceCode" id="cb509"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">Pmat1</span><span class="op">[</span><span class="fl">1</span>,<span class="op">]</span>; <span class="va">Pmat2</span><span class="op">[</span><span class="fl">1</span>,<span class="op">]</span></code></pre></div>
<pre><code>## [1] 0.2001 0.2001 0.4000 0.1998</code></pre>
<pre><code>## [1] 0.2001 0.2001 0.4000 0.1998</code></pre>
<blockquote>
<p>¿Cómo interpretamos esas probabilidades?</p>
</blockquote>
<p>Veamos ahora la aplicación de este algoritmo a alguno de los ejemplos con los que hemos trabajado ya en esta unidad.</p>
<div class="example">
<p><span id="exm:unlabeled-div-41" class="example"><strong>Ejemplo 4.8  </strong></span>Para los datos correspondientes al cajero bancario en la sección <a href="CMTC.html#cajerobancario">Cajero Bancario</a>, estamos interesados en conocer la probabilidad de que después de 50 minutos de funcionamiento el sistema esté completamente ocupado (1 usuario atendido y tres en cola), sabiendo que en el instante inicial partimos de <span class="math inline">\(0\)</span> clientes en el sistema. La matriz de tasas viene dada por:</p>
</div>
<div class="sourceCode" id="cb512"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">estados</span><span class="op">)</span>

<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">15</span><span class="op">/</span><span class="fl">60</span>
<span class="va">mu</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">6</span> 

<span class="va">R</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span></code></pre></div>
<p>Queremos calcular pues, <span class="math inline">\(P(50)\)</span>, y en particular el elemento <span class="math inline">\(p_{04}(50)\)</span>.
Obtenemos la distribución de probabilidad asociada al estado 4 para <span class="math inline">\(t = 50\)</span>:</p>
<div class="sourceCode" id="cb513"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Matriz de probabilidades de transición</span>
<span class="va">Pmat</span><span class="op">&lt;-</span><span class="fu">matriz.prob.trans</span><span class="op">(</span><span class="va">R</span>, <span class="fl">50</span>, <span class="fl">2</span><span class="op">)</span>
<span class="va">Pmat</span></code></pre></div>
<pre><code>##        [,1]   [,2]   [,3]   [,4]   [,5]
## [1,] 0.0812 0.1190 0.1730 0.2528 0.3741
## [2,] 0.0793 0.1172 0.1722 0.2539 0.3775
## [3,] 0.0769 0.1148 0.1711 0.2553 0.3819
## [4,] 0.0749 0.1128 0.1702 0.2565 0.3856
## [5,] 0.0739 0.1118 0.1698 0.2571 0.3874</code></pre>
<p>La probabilidad de interés es 0.3741 (que representa la probabilidad <span class="math inline">\(p_{04}(50)\)</span>), lo que demuestra que es factible que el sistema llegue al estado 4 partiendo del estado 0 después de 4 horas.</p>
<p>Aunque el cálculo teórico es muy preciso, hay situaciones en que los sistemas reales con los que estamos trabajando hacen bastante costoso obtener la matriz <span class="math inline">\(R\)</span>, y resulta más sencillo tratar de aproximar las probabilidades de transición mediante simulación. Para ello basta con replicar el sistema de simulación un número lo suficientemente grande de veces, y aproximar mediante Monte-Carlo.</p>
<p>En nuestro ejemplo deberíamos simular el estado del sistema durante 50 minutos, replicarlo varias veces y aproximar la probabilidad como el número de réplicas en que se alcanza la ocupación completa del sistema en el instante 50, dividido por el número de réplicas realizadas. La precisión de esta aproximación depende en gran medida del número de réplicas, como siempre en la estimación Monte Carlo. La única puntualización a considerar es que hemos de modificar el algoritmo de simulación para inicializar el sistema en el estado que deseemos. De no hacerlo así, obtendremos resultados dispares. Veamos cuál es el resultado si simulamos sin especificar el estado inicial del que arranca el sistema.</p>
<div class="sourceCode" id="cb515"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">replicas</span> <span class="op">&lt;-</span> <span class="fl">2500</span>
<span class="co">#simulamos SIN especificar el estado inicial</span>
<span class="va">envs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">nreplicas</span>, <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">{</span>
   <span class="fu">cola.MM1K</span><span class="op">(</span><span class="fl">50</span>, <span class="fl">15</span><span class="op">/</span><span class="fl">60</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">6</span>, <span class="fl">1</span>, <span class="fl">4</span><span class="op">)</span><span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/wrap.html">wrap</a></span><span class="op">(</span><span class="op">)</span><span class="op">}</span>,mc.set.seed<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>
  
<span class="co"># almacenamos el análisis de recursos del sistema</span>
<span class="va">simresource</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_resources</a></span><span class="op">(</span><span class="va">envs</span><span class="op">)</span><span class="op">)</span>
<span class="co"># Almacenamos el estado final de la cola en el último instante del sistema</span>
<span class="va">salida</span> <span class="op">&lt;-</span> <span class="va">simresource</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">replication</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>estado <span class="op">=</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/nth.html">last</a></span><span class="op">(</span><span class="va">system</span><span class="op">)</span><span class="op">)</span>
<span class="co"># Estimamos la probabilidad de acabar en cualquiera de los estados</span>
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">salida</span><span class="op">$</span><span class="va">estado</span><span class="op">)</span><span class="op">/</span><span class="va">replicas</span>, <span class="fl">3</span><span class="op">)</span></code></pre></div>
<pre><code>## 
##     0     1     2     3     4 
## 0.016 0.023 0.027 0.047 0.086</code></pre>
<p>Claramente, la probabilidad estimada es <span class="math inline">\(Pr(X_{50}=4)\)</span>, que es distinta a la pretendida, <span class="math inline">\(Pr(X_{50}=4|X_0=0)\)</span>.</p>
<blockquote>
<p><strong>Para practicar la obtención de la matriz de probabilidades de transición puedes resolver los ejercicios B4.1 a B4.4 de la colección al final de la unidad.</strong></p>
</blockquote>
</div>
<div id="CMTCG" class="section level2" number="4.7">
<h2>
<span class="header-section-number">4.7</span> Análisis de tiempos de ocupación<a class="anchor" aria-label="anchor" href="#CMTCG"><i class="fas fa-link"></i></a>
</h2>
<p>En esta sección, nos centramos en el análisis de los tiempos de ocupación de un estado determinado en un intervalo de tiempo finito <span class="math inline">\((0, T]\)</span>, es decir, el tiempo esperado que el sistema pasa en ese estado. Como ocurre con las probabilidades de transición, presentamos un algoritmo para obtener los tiempos de ocupación a partir de la matriz de tasas, y veremos también cómo la simulación del proceso nos puede ayudar a dar respuesta a las mismas cuestiones.</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-42" class="theorem"><strong>Teorema 4.3  </strong></span>Si <span class="math inline">\(P(t)\)</span> es la matriz de probabilidades de transición del proceso <span class="math inline">\(\{X_t, t \geq 0\}\)</span> con espacio de estados <span class="math inline">\(S = \{1, 2,...,N\}\)</span>, se define la cantidad <span class="math inline">\(m_{ij}(T)\)</span> como el tiempo de ocupación del estado <span class="math inline">\(j\)</span> hasta el instante <span class="math inline">\(T\)</span> partiendo del estado <span class="math inline">\(i\)</span> como:</p>
<span class="math display" id="eq:ocupacionCMTC">\[\begin{equation}
m_{ij}(T) = \int_0^T p_{ij}(t)dt, \quad 1 \leq i, j \leq N.
\tag{4.8}
\end{equation}\]</span>
</div>
<p>Cuando tenemos formas explícitas para cada uno de los elementos de <span class="math inline">\(P(t)\)</span>, como es el caso para la mayoría de los sistemas de colas de espera, este problema se puede resolver teóricamente. Sin embargo, en la mayoria de ocasiones es necesario un algoritmo de computación para aproximarlos. A continuación se presenta el algoritmo necesario, pero antes veamos la aproximación mediante series de la matriz <span class="math inline">\(M(T) = (m_{ij}(T))\)</span>.</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-43" class="theorem"><strong>Teorema 4.4  </strong></span>Si <span class="math inline">\(Y\)</span> es una variable aleatoria Poisson de parámetro <span class="math inline">\(r\cdot T\)</span>, entonces:</p>
<span class="math display" id="eq:ocupPoissonCMTC">\[\begin{equation}
M(T) = \frac{1}{r} \sum_{k = 0}^{\infty} Pr(Y &gt; k) \hat{P}^k, \quad T \geq 0.
\tag{4.9}
\end{equation}\]</span>
<p>y se puede aproximar con una suma finita de orden <span class="math inline">\(m\)</span> utilizando el algoritmo de uniformización a continuación.</p>
</div>
<div class="silverbox">
<p>Algoritmo de uniformización para obtener <span class="math inline">\(M(T)\)</span> como una suma finita:</p>
<ol style="list-style-type: decimal">
<li>Fijar <span class="math inline">\(R\)</span>, <span class="math inline">\(T\)</span>, y <span class="math inline">\(0 &lt; \epsilon &lt; 1\)</span> máximo error tolerable. Por defecto fijamos <span class="math inline">\(\epsilon = 0.00001\)</span>.</li>
<li>Obtener r.</li>
<li>Calcular <span class="math inline">\(\hat{P}\)</span>.</li>
<li>Calcular <span class="math inline">\(A = \hat{P}\)</span>; <span class="math inline">\(k = 0\)</span>
</li>
<li>Inicializar <span class="math inline">\(yek = exp(-r*t)\)</span>, <span class="math inline">\(ygk = 1 - yek\)</span>, <span class="math inline">\(suma = ygk\)</span>
</li>
<li>Calcular <span class="math inline">\(B = ygk * I\)</span>
</li>
<li>Mientras que <span class="math inline">\(suma/r &lt; T-\epsilon\)</span>, calcular:</li>
</ol>
<!-- --><pre><code>k = k + 1
yek = yek*(rT)/k
ygk = ygk - yek
B = B + ygk*A
A = A\hat{P}
suma = suma + ygk</code></pre>
<p>Al finalizar, la matriz <span class="math inline">\(B/r\)</span> es una aproximación de <span class="math inline">\(M(T)\)</span> con error inferior a <span class="math inline">\(\epsilon\)</span>.</p>
</div>
<p>En nuestro algoritmo añadiremos un parámetro extra para indicar cómo se debe calcular el valor de <span class="math inline">\(r\)</span>, bien como el máximo o la suma de las tasas de permanencia.</p>
<div class="sourceCode" id="cb518"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tiempos.ocupacion</span><span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">Rmat</span>, <span class="va">Ts</span>, <span class="va">cal</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Algortimo de uniformización para obtener M(T)</span>
  <span class="co">################################################</span>
  
  <span class="co"># Parámetros de la función</span>
  <span class="co"># Rmat: matriz de tasas</span>
  <span class="co"># ts: instante de tiempo</span>
  <span class="co"># epsilon: error en la aproximación</span>
  <span class="co"># cal: forms de obtener r con dos valores 1 = máximo, 2 = suma</span>
  <span class="va">epsilon</span> <span class="op">&lt;-</span> <span class="fl">1e-05</span>
  <span class="co"># Paso 2. Calculo de r</span>
  <span class="va">ris</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">Rmat</span>, <span class="fl">1</span>, <span class="va">sum</span><span class="op">)</span>
  <span class="va">rlimit</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">cal</span> <span class="op">==</span> <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">ris</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">Rmat</span><span class="op">)</span><span class="op">)</span>
  <span class="co"># Paso 3. Calculo de hat(P)</span>
  <span class="va">hatP</span> <span class="op">&lt;-</span> <span class="va">Rmat</span><span class="op">/</span><span class="va">rlimit</span>
  <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">hatP</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">ris</span><span class="op">/</span><span class="va">rlimit</span>
  <span class="co"># Paso 4. </span>
  <span class="va">k</span> <span class="op">&lt;-</span> <span class="fl">0</span>
  <span class="va">A</span> <span class="op">&lt;-</span> <span class="va">hatP</span>
  <span class="co"># Paso 5.</span>
  <span class="va">yek</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">*</span><span class="va">rlimit</span><span class="op">*</span><span class="va">Ts</span><span class="op">)</span>
  <span class="va">ygk</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">yek</span>
  <span class="va">suma</span> <span class="op">&lt;-</span> <span class="va">ygk</span>
  <span class="co"># Paso 6.</span>
  <span class="va">B</span> <span class="op">&lt;-</span> <span class="va">ygk</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">Rmat</span><span class="op">)</span><span class="op">)</span>
  <span class="co"># Bucle simulación</span>
  <span class="va">cota</span> <span class="op">&lt;-</span> <span class="va">Ts</span><span class="op">-</span> <span class="va">epsilon</span>
  <span class="kw">while</span><span class="op">(</span><span class="va">suma</span><span class="op">/</span><span class="va">rlimit</span> <span class="op">&lt;</span> <span class="va">cota</span><span class="op">)</span>
  <span class="op">{</span>
    <span class="va">k</span> <span class="op">&lt;-</span> <span class="va">k</span> <span class="op">+</span> <span class="fl">1</span>
    <span class="va">yek</span> <span class="op">&lt;-</span> <span class="va">yek</span><span class="op">*</span><span class="op">(</span><span class="va">rlimit</span><span class="op">*</span><span class="va">Ts</span><span class="op">)</span><span class="op">/</span><span class="va">k</span>
    <span class="va">ygk</span> <span class="op">&lt;-</span> <span class="va">ygk</span> <span class="op">-</span> <span class="va">yek</span>
    <span class="va">B</span> <span class="op">&lt;-</span> <span class="va">B</span> <span class="op">+</span> <span class="va">ygk</span><span class="op">*</span><span class="va">A</span>
    <span class="va">A</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span><span class="va">hatP</span>
    <span class="va">suma</span> <span class="op">&lt;-</span> <span class="va">suma</span> <span class="op">+</span> <span class="va">ygk</span>
  <span class="op">}</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">B</span><span class="op">/</span><span class="va">rlimit</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<div class="example">
<p><span id="exm:unlabeled-div-44" class="example"><strong>Ejemplo 4.9  </strong></span>Retomando el sistema sobre el tiempo de vida de una máquina descrito en el ejemplo <a href="CMTC.html#exm:excmtc005">4.5</a>, supongamos que el tiempo esperado hasta que falla una máquina son 10 días, mientras que el tiempo esperado de reparación es de 1 día. Si la máquina funciona el primer día de enero, ¿cuánto tiempo estará en funcionamiento la máquina al finalizar el mes de enero?</p>
</div>
<p>Dado que el proceso (número de máquinas averiadas) sólo tiene espacio de estados <span class="math inline">\(S = \{0, 1\}\)</span>, 0=parada y 1=funcionando, la cantidad de interés es <span class="math inline">\(m_{11}(31)\)</span>. Con <span class="math inline">\(\lambda = 1\)</span> y <span class="math inline">\(\mu = 0.1\)</span>, la matriz de tasas del proceso viene dada por:</p>
<div class="sourceCode" id="cb519"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fl">2</span>
<span class="va">estados</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">1</span><span class="op">)</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">1</span>
<span class="va">mu</span> <span class="op">&lt;-</span> <span class="fl">0.1</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>,<span class="va">estados</span><span class="op">)</span><span class="op">)</span>

<span class="va">R</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span> </code></pre></div>
<p>Obtenemos ahora la matriz de tiempos de ocupación tras 31 días, <span class="math inline">\(M(31)\)</span>, que nos dará la cantidad de interés; en concreto nos fijaremos en la segunda fila, teniendo en cuenta que partimos de que la máquina está en marcha inicialmente.</p>
<div class="sourceCode" id="cb520"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ocupacion</span><span class="op">=</span><span class="fu">tiempos.ocupacion</span><span class="op">(</span><span class="va">R</span>, <span class="fl">31</span>, <span class="fl">1</span><span class="op">)</span>
<span class="va">ocupacion</span></code></pre></div>
<pre><code>##        0       1
## 0 3.6446 27.3554
## 1 2.7355 28.2645</code></pre>
<p>Por tanto, el tiempo esperado de funcionamiento es de 28.3 días, mientras que el tiempo dedicado a reparaciones es de 2.7 días.</p>
<p>Utilizando el simulador del proceso a continuación, sin especificar el estado inicial, obtenemos resultados aproximados, que relacionarán la distribución estacionaria con los tiempos de ocupación. Lo estudiamos a continuación.</p>
<div class="sourceCode" id="cb522"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Réplicas del proceso</span>
<span class="va">replicas</span> <span class="op">&lt;-</span> <span class="fl">2500</span>
<span class="va">envs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">replicas</span>, <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">{</span>
    <span class="fu">sistema.1m</span><span class="op">(</span><span class="fl">31</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">10</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
    <span class="fu"><a href="https://r-simmer.org/reference/wrap.html">wrap</a></span><span class="op">(</span><span class="op">)</span><span class="op">}</span>,mc.set.seed<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>

<span class="co"># almacenamos análisis de llegadas del sistema</span>
<span class="va">simarrivals</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html">as_tibble</a></span><span class="op">(</span><span class="fu"><a href="https://r-simmer.org/reference/get_mon.html">get_mon_arrivals</a></span><span class="op">(</span><span class="va">envs</span><span class="op">)</span><span class="op">)</span>
<span class="co"># Almacenamos el estado final de la cola en el último instante del sistema</span>
<span class="va">simarrivals</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>tOFF <span class="op">=</span> <span class="va">end_time</span> <span class="op">-</span> <span class="va">start_time</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">replication</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>totalOFF <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tOFF</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">ungroup</a></span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>
  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span>mOFF <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">totalOFF</span><span class="op">)</span>, mON <span class="op">=</span> <span class="fl">31</span> <span class="op">-</span> <span class="va">mOFF</span><span class="op">)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 2
##    mOFF   mON
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  3.21  27.8</code></pre>
<blockquote>
<p><strong>Para practicar el cálculo de los tiempos de ocupación puedes resolver los ejercicios B4.5 a B4.8 de la colección al final de la unidad.</strong></p>
</blockquote>
</div>
<div id="CMTCH" class="section level2" number="4.8">
<h2>
<span class="header-section-number">4.8</span> Comportamiento límite del proceso<a class="anchor" aria-label="anchor" href="#CMTCH"><i class="fas fa-link"></i></a>
</h2>
<p>En el análisis del comportamiento límite de una CMTD analizamos la distribución de probabilidad límite, la distribución estacionaria, y la distribución de los tiempos de ocupación. En el caso de las CMTC estas distribuciones coinciden.</p>
<p>En primer lugar analizamos las probabilidades límite:</p>
<p><span class="math display">\[\lim_{t \rightarrow \infty} Pr[X_t = j], \quad 1 \leq j \leq N.\]</span></p>
<p>Si existen dichos límites, el vector <span class="math inline">\(p = (p_1, p_2,...,p_N)\)</span> se conoce como <strong>distribución límite</strong> de la CMTC.</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-45" class="theorem"><strong>Teorema 4.5  </strong></span>Una CMTC <span class="math inline">\(\{X_t, t \geq 0\}\)</span> irreducible con matriz de tasas <span class="math inline">\(R\)</span> tiene una única distribución límite <span class="math inline">\(p = (p_1, p_2,...,p_N)\)</span>, que se puede obtener como solución de las ecuaciones de balance:</p>
<span class="math display" id="eq:ecubalanceCMTC">\[\begin{eqnarray} 
p_j  r_j &amp;=&amp; \sum_{i=1}^N p_i  r_{ij}, \quad 1 \leq j \leq N \\
\sum_{i=1}^N p_i &amp;=&amp; 1. \nonumber
\tag{4.10}
\end{eqnarray}\]</span>
<p>Podemos interpretar <span class="math inline">\(p_j r_j\)</span> como la tasa a la que la CMTC deja el estado <span class="math inline">\(j\)</span>, y <span class="math inline">\(p_i r_{ij}\)</span> como la tasa a la que la CMTC entra al estado <span class="math inline">\(j\)</span> desde el estado <span class="math inline">\(i\)</span>. Por lo tanto, esta ecuación de balance <a href="CMTC.html#eq:ecubalanceCMTC">(4.10)</a> nos dice que las probabilidades límite son tales que la tasa de entrada al estado <span class="math inline">\(j\)</span> desde todos los estados restantes es igual a la tasa a la cual el sistema deja el estado <span class="math inline">\(j\)</span>, es decir, se produce un balance entre las entradas y las salidas.</p>
</div>
<div class="theorem">
<p><span id="thm:unlabeled-div-46" class="theorem"><strong>Teorema 4.6  </strong></span>Dada una CMTC <span class="math inline">\(\{X_t, t \geq 0\}\)</span> irreducible con distribución límite <span class="math inline">\(p\)</span>, se tiene que la distribución estacionaria de la CMTC viene dada por <span class="math inline">\(p\)</span>, es decir, <span class="math inline">\(p_j\)</span> es la probabilidad de que el sistema esté en estado <span class="math inline">\(j\)</span> en el largo plazo.</p>
</div>
<p>La siguiente cuestión es sobre si ocurre en la CMTC lo mismo que ocurría ya en las CMTD con la distribución de ocupación, esto es, si coincidía con la distribución límite y con la distribución estacionaria. La respuesta la tenemos en el siguiente teorema.</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-47" class="theorem"><strong>Teorema 4.7  </strong></span>Sea <span class="math inline">\(m_{ij}(T)\)</span> el tiempo total esperado que la cadena permanece en el estado <span class="math inline">\(j\)</span> hasta el instante <span class="math inline">\(T\)</span> para una CMTC irreducible que comienza en el estado <span class="math inline">\(i\)</span>. Entonces tenemos la siguiente igualdad que relaciona la distribución límite con la distribución estacionaria dada por <span class="math inline">\(\{p_j; j \in S\}\)</span>:</p>
<p><span class="math display">\[\lim_{T \rightarrow \infty} \frac{m_{ij}(T)}{T} = p_j.\]</span></p>
</div>
<p>Así pues, una CMTC ireducible tiene una única distribución límite, que es también su distribución estacionaria y su distribución de ocupación. Se puede calcular pues, resolviendo las ecuaciones de balance <a href="CMTC.html#eq:ecubalanceCMTC">(4.10)</a>.</p>
<p>A continuación se presenta la solución de la distribución límite para los procesos de nacimiento y muerte. En el resto de sistemas se deberán plantear las ecuaciones de balance y resorverlas. En ambas situaciones presentamos las correspondientes funciones que nos permiten obtener las cantidades de interés.</p>
<div class="bluebox">
<p>Sea <span class="math inline">\(\{X_t, t \geq 0\}\)</span> un proceso de nacimiento y muerte con espacio de estados <span class="math inline">\(S = \{0, 1,...,K\}\)</span>, y tasas de nacimiento <span class="math inline">\(\{\lambda_i, 0 \leq i &lt; K\}\)</span> y tasas de muerte <span class="math inline">\(\{\mu_i, 1 \leq i \leq K\}\)</span>. Entonces la CMTC así definida es irreducible y tiene una única distribución límite con:</p>
<p><span class="math display">\[p_i = \frac{\rho_i}{\sum_{j = 0}^K \rho_j}, \quad 0 \leq i \leq K,\]</span> donde <span class="math inline">\(\rho_0 = 1,\)</span> y</p>
<p><span class="math display">\[\rho_i = \frac{\prod_{j=0}^{i-1}\lambda_j}{\prod_{j=1}^{i}\mu_j}, \quad 1 \leq i \leq K.\]</span></p>
</div>
<p>Antes de comenzar con los ejemplos, vamos a crear una función que permita obtener la distribución límite y la distribución de ocupación para los procesos de nacimiento y muerte.</p>
<div class="sourceCode" id="cb524"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Obtención de distribuciones límite </span>
<span class="va">distr.lim.nm</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">estados</span>, <span class="va">lambdas</span>, <span class="va">mus</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Parámetros de la función</span>
  <span class="co"># ========================</span>
  <span class="co"># estados: número de estados del sistema (K)</span>
  <span class="co"># lambdas: vector de tasas de nacimiento lambda0,..., lambda(K-1)</span>
  <span class="co"># mus: vector de tasas de muerte mu1,...,muK</span>
  
  <span class="co"># definimos vector de rho</span>
  <span class="va">rhos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">estados</span><span class="op">)</span>
  <span class="co"># calculamos productos acumulados para lambda y mu</span>
  <span class="va">prl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cumsum.html">cumprod</a></span><span class="op">(</span><span class="va">lambdas</span><span class="op">)</span>
  <span class="va">prm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cumsum.html">cumprod</a></span><span class="op">(</span><span class="va">mus</span><span class="op">)</span>
  <span class="co"># rellenamos rho con los productos acumulados</span>
  <span class="va">rhos</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="va">estados</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">prl</span><span class="op">/</span><span class="va">prm</span>
  <span class="co"># suma de rhos</span>
  <span class="va">sumarhos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">rhos</span><span class="op">)</span>
  <span class="co"># vector de probabilidades</span>
  <span class="va">ps</span> <span class="op">&lt;-</span> <span class="va">rhos</span><span class="op">/</span><span class="va">sumarhos</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">ps</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<div class="example">
<p><span id="exm:unlabeled-div-48" class="example"><strong>Ejemplo 4.10  </strong></span>Retomando el sistema descrito en el ejemplo <a href="CMTC.html#exm:excmtc005">4.5</a>, supongamos que el tiempo esperado hasta que falla una máquina son 10 días, mientras que el tiempo esperado de reparación es de 1 día. ¿Cuál es la distribución límite del proceso y cómo ha de interpretarse?</p>
<p>Este sistema es un proceso de nacimiento y muerte donde podemos aplicar la función anterior para obtener la distribución límite con dos estados y tasas <span class="math inline">\(\lambda = 1\)</span>, <span class="math inline">\(\mu = 1/10\)</span> (expresadas en días).</p>
</div>
<div class="sourceCode" id="cb525"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lambda</span><span class="op">=</span><span class="fl">1</span>
<span class="va">mu</span><span class="op">=</span><span class="fl">0.1</span>
<span class="va">estados</span><span class="op">=</span><span class="fl">2</span>
<span class="va">probs</span> <span class="op">&lt;-</span> <span class="fu">distr.lim.nm</span><span class="op">(</span><span class="va">estados</span>,<span class="va">lambda</span>,<span class="va">mu</span><span class="op">)</span>
<span class="va">probs</span></code></pre></div>
<pre><code>## [1] 0.09090909 0.90909091</code></pre>
<p>El comportamiento límite nos indica que la máquina está el 90.9% del tiempo en funcionamiento, mientras que sólo el 9.1% en reparación. Para un periodo de un año tendríamos que los días esperados de reparación y funcionamiento serían, respectivamente:</p>
<div class="sourceCode" id="cb527"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">365</span><span class="op">*</span><span class="va">probs</span><span class="op">)</span></code></pre></div>
<pre><code>## [1]  33 332</code></pre>
<p>Veamos ahora cómo obtener la distribución límite para procesos más generales. Definimos una función que nos permite obtener la distribución límite de un CMTC a partir de cualquier matriz de tasas <span class="math inline">\(R\)</span>, resolviendo las ecuaciones de balance <a href="CMTC.html#eq:ecubalanceCMTC">(4.10)</a> matricialmente. Estas ecuaciones equivalen a resolver el sistema:</p>
<p><span class="math display">\[A\cdot p= C\]</span></p>
<p>donde A es una matriz construida a partir de la traspuesta de la matriz generadora <span class="math inline">\(Q=R-diag(r)\)</span>, con <span class="math inline">\(r\)</span> un vector con las tasas de permanencia <span class="math inline">\(r_1,...,r_N\)</span>, a la que se le añade en la última fila un vector de unos,
y <span class="math inline">\(C\)</span> es una matriz columna de ceros, con la última fila igual a 1 para introducir la restricción de que los <span class="math inline">\(p_j\)</span> definen una distribución de probabilidad y suman 1. Esto es,</p>
<p><span class="math display">\[A=\begin{pmatrix}
Q' \\
1 1 ... 1
\end{pmatrix} \]</span></p>
<p><span class="math display">\[\begin{eqnarray}
A \cdot p &amp;=&amp; C \nonumber \\
\begin{pmatrix}
-r_1 &amp; r_{21} &amp; ... &amp; r_{N1} \\
r_{12} &amp; -r_2 &amp; ... &amp; r_{N2} \\
. &amp; . &amp; .&amp; \\
r_{1N} &amp; r_{2N} &amp; ... &amp; -r_{N} \\
1 &amp; 1 &amp; ... &amp; 1 \\
\end{pmatrix} \cdot
\begin{pmatrix}
p_1 \\
p_2 \\
. \\
p_N
\end{pmatrix} &amp;=&amp; 
\begin{pmatrix}
0 \\
0 \\
. \\
1
\end{pmatrix} 
\end{eqnarray}\]</span></p>
<div class="sourceCode" id="cb529"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Función para la resolución numérica de las ecuaciones de balance</span>
<span class="va">distr.lim.general</span><span class="op">&lt;-</span><span class="kw">function</span><span class="op">(</span><span class="va">Rmat</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Parámetros de la función</span>
  <span class="co">#=========================</span>
  <span class="co"># Rmat: matriz de tasas del sistema</span>
  
  <span class="co"># número de estados del sistema</span>
  <span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">Rmat</span><span class="op">)</span>
  <span class="co"># Calculamos r_i y lo colocamos en formato matriz</span>
  <span class="va">sumarows</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">Rmat</span>, <span class="fl">1</span>, <span class="va">sum</span><span class="op">)</span>, <span class="va">estados</span><span class="op">)</span>
  <span class="co"># Matriz de coeficientes del sistema de ecuaciones de balance</span>
  <span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">R</span><span class="op">)</span><span class="op">-</span><span class="va">sumarows</span>
  <span class="co"># Completamos la matriz añadiendo la restricción de suma de p`s igual a 1</span>
  <span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">A</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
  <span class="co"># Vector de términos independientes del sistema</span>
  <span class="va">CS</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">estados</span><span class="op">)</span>, <span class="fl">1</span><span class="op">)</span>
  <span class="co"># Resolución del sistema</span>
  <span class="va">ps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/qr.html">qr.solve</a></span><span class="op">(</span><span class="va">A</span>, <span class="va">CS</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">ps</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<div class="example">
<p><span id="exm:unlabeled-div-49" class="example"><strong>Ejemplo 4.11  </strong></span>Para el sistema del <a href="CMTC.html#fabricaCMTC">Proceso de fabricación</a> se está interesado en conocer cuándo la máquina estará parada a largo plazo. Dado que el espacio de estados es <span class="math inline">\(S = \{1, 2,...,6\}\)</span>. La máquina estará parada cuando nos encontremos en los estados <span class="math inline">\(5 = (4, 0)\)</span> y <span class="math inline">\(6 = (3, 0)\)</span>. A partir de la información del sistema podemos obtener la distribución límite del proceso, pero en este caso, como no se trata de un proceso de nacimiento y muerte debemos plantear las ecuaciones de balance a partir de la matriz de tasas, y resolver el sistema numéricamente con la función <code>distr.lim.general()</code> definida anteriormente.</p>
</div>
<p>Resolvemos las ecuaciones de balance para el sistema del proceso de fabricación. Definimos la matriz de tasas y ejecutamos la función anterior para obtener las probabilidades límite del proceso:</p>
<div class="sourceCode" id="cb530"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Estados del sistema</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fl">6</span>
<span class="co"># Matriz de tasas</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">6</span>
<span class="va">mu</span> <span class="op">&lt;-</span> <span class="fl">5</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">R</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span>
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span>
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span>
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">6</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span>
<span class="va">R</span><span class="op">[</span><span class="fl">6</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span>
<span class="co"># Resolución  de las ecuaciones de balance</span>
<span class="va">ps</span> <span class="op">&lt;-</span> <span class="fu">distr.lim.general</span><span class="op">(</span><span class="va">R</span><span class="op">)</span>
<span class="va">ps</span></code></pre></div>
<pre><code>## [1] 0.1584649 0.1901579 0.2281895 0.1244670 0.1493604 0.1493604</code></pre>
<p>La probabilidad de interés viene dada por 0.2987, de forma que la máquina permanecerá apagada aproximadamente el 30% del tiempo.</p>
<blockquote>
<p><strong>Para practicar con el cálculo de la distribución estacionaria, puedes resolver los ejercicios B4.9 a B4.12 de la colección al final de la unidad.</strong></p>
</blockquote>
</div>
<div id="CMTCI" class="section level2" number="4.9">
<h2>
<span class="header-section-number">4.9</span> Análisis de costes<a class="anchor" aria-label="anchor" href="#CMTCI"><i class="fas fa-link"></i></a>
</h2>
<p>En este punto vemos cómo podemos introducir costes en las CMTC y los procedimientos numéricos necesarios para su análisis. Seguimos considerando <span class="math inline">\(\{X_t, t \geq 0\}\)</span> una CMTC con espacio de estados <span class="math inline">\(S = \{1, 2,...,N\}\)</span> y matriz de tasas <span class="math inline">\(R\)</span>. Además, siempre que la CMTC está en el estado <span class="math inline">\(i\)</span> se incurre en costes de modo continuo según una tasa <span class="math inline">\(c(i), 1 \leq i \leq N\)</span>.</p>
<div id="coste-total-esperado-hasta-t" class="section level3" number="4.9.1">
<h3>
<span class="header-section-number">4.9.1</span> Coste total esperado hasta <span class="math inline">\(T\)</span><a class="anchor" aria-label="anchor" href="#coste-total-esperado-hasta-t"><i class="fas fa-link"></i></a>
</h3>
<p>Estudiamos en primer lugar el <em>coste total esperado</em>, <strong>CTE</strong> hasta un instante finito <span class="math inline">\(T\)</span>, llamado horizonte. Nótese que la tasa de coste en el tiempo <span class="math inline">\(t\)</span> es <span class="math inline">\(c(X_t)\)</span>. Por lo tanto, el coste total hasta el instante <span class="math inline">\(T\)</span> viene dado por:</p>
<p><span class="math display">\[\int_0^T c(X_t)dt.\]</span></p>
<p>De esta forma el coste esperado total hasta el instante <span class="math inline">\(T\)</span>, empezando en el estado <span class="math inline">\(i\)</span>, viene dado por:</p>
<p><span class="math display">\[\begin{equation}
g(i, T) = E\left[ \int_0^T c(X_t)dt \mid X_0 = i \right], \quad 1 \leq i \leq N.
\end{equation}\]</span></p>
<div class="theorem">
<p><span id="thm:unlabeled-div-50" class="theorem"><strong>Teorema 4.8  </strong></span>Si <span class="math inline">\(M(T) = (m_{ij}(T))\)</span> es la matriz de ocupación entonces:</p>
<p><span class="math display">\[\begin{equation}
g(T) = M(T) \cdot \begin{pmatrix} c(1) \\ c(2) \\ ... \\ c(N)\end{pmatrix}
\end{equation}\]</span></p>
<p>donde <span class="math inline">\(c(i)\)</span> representa el coste por permanecer en el estado <span class="math inline">\(i\)</span> y <span class="math inline">\(g(T) = [g(1, T), g(2,T),..., g(N-1, T), g(N, T)]'\)</span>, donde <span class="math inline">\(g(i,T)\)</span> representa el coste esperado total hasta el instante <span class="math inline">\(T\)</span> cuando el sistema se inicia en estado <span class="math inline">\(i\)</span>.</p>
</div>
<div class="example">
<p><span id="exm:excmtc007bis" class="example"><strong>Ejemplo 4.12  </strong></span>Para el sistema de <a href="CMTC.html#excmtc007">Mantenimiento de máquinas</a>, se sabe que el beneficio por cada hora que la máquina está funcionando es de 50 euros, mientras que el coste de que la máquina este apagada es de 15 euros por hora, al que hay que sumar 10 euros por cada hora de reparación. Estamos interesados en conocer el coste-beneficio de un periodo de 24 horas, si sabemos que al inicio del día todas las máquinas están funcionando.</p>
</div>
<p>Si <span class="math inline">\(X_t\)</span> es el número de máquinas estropeadas en el instante <span class="math inline">\(t\)</span>, el espacio de estados para 4 máquinas viene dado por <span class="math inline">\(S = \{0, 1, 2, 3, 4\}\)</span> y el vector de costes es:</p>
<p><span class="math display">\[
\begin{matrix}
c(4) = &amp; 0\cdot 50 - 4\cdot 15 - 2\cdot 10 = - 80,\\
c(3) = &amp; 1\cdot 50 - 3\cdot 15 - 2\cdot 10 = - 15,\\
c(2) = &amp; 2\cdot 50 - 2\cdot 15 - 2\cdot 10 = 50,\\
c(1) = &amp; 3\cdot 50 - 1\cdot 15 - 1\cdot 10 = 125,\\
c(0) = &amp; 4\cdot 50 - 0\cdot 15 - 0\cdot 10 = 200.
\end{matrix}
\]</span></p>
<p>Veamos cómo obtener los costes acumulados en un día utilizando el código correspondiente.</p>
<div class="sourceCode" id="cb532"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Matriz de tasas</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fl">5</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>
<span class="va">mu</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">72</span> 

<span class="va">R</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">4</span><span class="op">*</span><span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mu</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">3</span><span class="op">*</span><span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">mu</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">3</span><span class="op">*</span><span class="va">mu</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">4</span><span class="op">*</span><span class="va">mu</span>

<span class="co"># Matriz de ocupación</span>
<span class="va">mmat</span> <span class="op">&lt;-</span> <span class="fu">tiempos.ocupacion</span><span class="op">(</span><span class="va">R</span>, <span class="fl">24</span>, <span class="fl">1</span><span class="op">)</span>
<span class="co"># Vector de costes</span>
<span class="va">costes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">200</span>, <span class="fl">125</span>, <span class="fl">50</span>,<span class="op">-</span><span class="fl">15</span>, <span class="op">-</span><span class="fl">80</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>
<span class="co"># Matriz de beneficios acumulados</span>
<span class="va">beneficios</span> <span class="op">&lt;-</span> <span class="va">mmat</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span><span class="va">costes</span>
<span class="va">beneficios</span></code></pre></div>
<pre><code>##           [,1]
## [1,] -1242.097
## [2,] -1378.587
## [3,] -1511.844
## [4,] -1638.507
## [5,] -1765.011</code></pre>
<p>Luego si se inicia el estado con todas las máquinas funcionando, el coste acumulado tras un día de funcionamiento es de 1242.0975 euros.</p>
</div>
<div id="tasas-de-coste-a-largo-plazo" class="section level3" number="4.9.2">
<h3>
<span class="header-section-number">4.9.2</span> Tasas de coste a largo plazo<a class="anchor" aria-label="anchor" href="#tasas-de-coste-a-largo-plazo"><i class="fas fa-link"></i></a>
</h3>
<p>Para el sistema de <a href="CMTC.html#vidautil-maquina">Vida útil de una máquina</a>, supongamos que se da el coste <span class="math inline">\(C\)</span> del tiempo de inactividad. Queremos saber cuál debe ser la tasa de ingresos durante el tiempo de actividad (ingresos percibidos por unidad de tiempo cuando la máquina está operativa), para que sea económicamente rentable operar la máquina. Si nos guiamos por el coste total, la respuesta dependerá del horizonte de planificación <span class="math inline">\(T\)</span> y también del estado inicial de la máquina. Una alternativa es calcular los ingresos netos a largo plazo por unidad de tiempo para esta máquina e insistir en que sea positivo para la rentabilidad. Esta respuesta no dependerá de <span class="math inline">\(T\)</span>, y como veremos ni siquiera del estado inicial de la máquina. Por lo tanto, el cálculo de estos índices de costes o ingresos a largo plazo es muy útil. En esta subsección mostraremos cómo calcular estas cantidades.</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-51" class="theorem"><strong>Teorema 4.9  </strong></span>Sea <span class="math inline">\(\{X_t, t \geq 0\}\)</span> una CMTC irreducible con estados <span class="math inline">\(\{1, 2,...,N\}\)</span>, distribución límite <span class="math inline">\(p = [p_1, p_2,...,p_N]\)</span> y vector de costes <span class="math inline">\(c = (c_1, c_2,..., c_N)\)</span>, entonces la tasa de coste a largo plazo viene dada por:</p>
<p><span class="math display">\[\begin{equation}
g(i) = \sum_{j = 1}^N p_j \cdot c(j), \quad 1 \leq i \leq N.
\end{equation}\]</span></p>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-52" class="example"><strong>Ejemplo 4.13  </strong></span>Si consideramos el sistema de <a href="CMTC.html#vidautil-maquina">Vida útil de una máquina</a>, supongamos que cuesta <span class="math inline">\(C\)</span> que la máquina esté apagada cada unidad de tiempo. ¿Cuál es la tasa mínima de ingresos <span class="math inline">\(I\)</span> a percibir por cada instante de tiempo que la máquina está operativa, para que el sistema no genere pérdidas (es decir, para alcanzar el punto de equilibrio a largo plazo)?</p>
</div>
<p>Utilizando las tasas definidas anteriormente (<span class="math inline">\(\lambda = 1, \mu = 0.1\)</span>), la distribución límite del sistema <span class="math inline">\(p = [0.0909, 0.9091]\)</span>, y el vector de costes <span class="math inline">\(c =(-C, I)\)</span> para el espacio de estados <span class="math inline">\(S = \{0, 1\}\)</span>, la tasa de coste a largo plazo por unidad de tiempo viene dada por la expresión:</p>
<p><span class="math display">\[ g = - 0.0909*C+0.9091*I \]</span>
de forma que para mantener el sistema en equilibrio, <span class="math inline">\(g \geq 0\)</span>, se debe cumplir que:</p>
<p><span class="math display">\[I \geq \frac{0.0909}{0.9091} \cdot C = 0.099989 \cdot C \approx 0.1 \cdot C\]</span></p>
<p>Así, obtener unos ingresos por unidad de tiempo operativo superiores a 0.1 veces el coste por unidad de tiempo de que la máquina está parada resulta en pérdidas no negativas.</p>
<blockquote>
<p>Verifica si se cumple la condición de equilibrio y cuáles son los beneficios si la empresa ha establecido un ingreso por hora de 50 euros, cuando sabe que el coste por hora es de 10 euros cuando está apagada.</p>
</blockquote>
<div class="example">
<p><span id="exm:unlabeled-div-53" class="example"><strong>Ejemplo 4.14  </strong></span>Consideramos el sistema de la <a href="CMTC.html#centralTelefonica">Central telefónica</a> en que la capacidad máxima de la centralita es de seis llamadas. Las llamadas llegan según un <span class="math inline">\(PP\)</span> a razón de 4 por minuto, y la duración media de cada llamada es exponencial de media 2 minutos. Consideramos como <span class="math inline">\(X_t\)</span> al número de llamadas que están siendo atendidas en el instante <span class="math inline">\(t\)</span>.</p>
<ol style="list-style-type: decimal">
<li>Queremos saber el beneficio por unidad de tiempo si la facturación por minuto de cada llamada es de 10 céntimos.</li>
<li>Queremos estimar la pérdida que sufrimos por todas las llamadas que no pueden ser atendidas.</li>
</ol>
</div>
<p>En primer lugar calculamos la distribución límite del proceso <span class="math inline">\(X_t\)</span> que representa el número de llamadas en el sistema en un instante <span class="math inline">\(t\)</span>. Dado que se trata de un proceso de nacimiento y muerte, utilizamos la función <code>distr.lim.nm</code> que ya construimos previamente en la sección <a href="CMTC.html#CMTCH">Comportamiento límite del proceso</a>.</p>
<div class="sourceCode" id="cb534"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Matriz de tasas</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fl">7</span>
<span class="va">lambdas</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">6</span><span class="op">)</span> 
<span class="va">mus</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span>
<span class="co"># Probabilidades del sistema</span>
<span class="va">probs</span> <span class="op">&lt;-</span> <span class="fu">distr.lim.nm</span><span class="op">(</span><span class="va">nestados</span>, <span class="va">lambdas</span>, <span class="va">mus</span><span class="op">)</span>;<span class="va">probs</span></code></pre></div>
<pre><code>## [1] 0.001070486 0.008563884 0.034255537 0.091348098 0.182696196 0.292313914 0.389751885</code></pre>
<p>Establecemos los beneficios por unidad de tiempo para cada uno de los estados, <span class="math inline">\(c(i) = 10i\)</span>, y calculamos el coste global por unidad de tiempo:</p>
<div class="sourceCode" id="cb536"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># vector de beneficios c(i)</span>
<span class="va">beneficio</span> <span class="op">&lt;-</span> <span class="fl">10</span><span class="op">*</span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span> 
<span class="co"># beneficio por unidad de tiempo</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">beneficio</span><span class="op">*</span><span class="va">probs</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 48.81985</code></pre>
<p>El beneficio esperado por unidad de tiempo (minuto) es de 48.82 céntimos.</p>
<p>En términos esperados, si el sistema funcionara según sus medias, esto es, a razón de 4 llamadas por minuto, 4, y la duración media de cada llamada, 2 minutos, tendríamos que el beneficio medio esperado por minuto sería de 80 céntimos. Esto implica que el sistema está funcionando por debajo de su capacidad debido a las llamadas que se rechazan, lo que genera unas pérdidas de <span class="math inline">\(80 - 48.82 = 31.18\)</span> céntimos por minuto.</p>
</div>
</div>
<div id="CMTCJ" class="section level2" number="4.10">
<h2>
<span class="header-section-number">4.10</span> Tiempos de primer paso<a class="anchor" aria-label="anchor" href="#CMTCJ"><i class="fas fa-link"></i></a>
</h2>
<p>Como ocurría con las CMTD podemos hablar de los tiempos de primer paso en las CMTC. Si <span class="math inline">\(\{X_t, t \geq 0\}\)</span> es una CMTC con espacio de estados <span class="math inline">\(\{1, 2,...,N\}\)</span> y matriz de tasas <span class="math inline">\(R\)</span>, entonces se define como el <strong>tiempo de primer paso por el estado</strong> <span class="math inline">\(N\)</span> como:</p>
<p><span class="math display">\[T = min\{t \geq 0: X_t = N\}.\]</span></p>
<p>Más concretamente estudiamos el valor esperado de <span class="math inline">\(T\)</span>, <span class="math inline">\(E(T)\)</span>. Para ello definimos los tiempos esperados a partir de cada uno de los estados del sistema como:</p>
<p><span class="math display">\[m_i = E(T \mid X_0 = i), \quad 1 \leq i \leq N-1; \qquad m_N = 0.\]</span></p>
<div class="theorem">
<p><span id="thm:unlabeled-div-54" class="theorem"><strong>Teorema 4.10  </strong></span>Los tiempos de primer paso por el estado <span class="math inline">\(N\)</span> cuando el sistema se inicia en el estado <span class="math inline">\(i\)</span>, <span class="math inline">\(\{m_i, 1 \leq i \leq N-1\}\)</span>, satisfacen:</p>
<p><span class="math display">\[r_i \cdot m_i = 1 + \sum_{j=1}^{N-1} r_{ij} \cdot m_j, \quad 1\leq i \leq N-1.\]</span></p>
</div>
<p>Si deseamos calcular los tiempos de primer paso por un subconjunto de estados <span class="math inline">\(A\)</span>, el teorema anterior se adapta según:</p>
<p><span class="math display">\[r_i \cdot m_i(A) = 1 + \sum_{j \notin A} r_{ij} \cdot m_j(A), \quad 1\leq i \leq N-1.\]</span></p>
<p>A continuación presentamos un algoritmo para calcular los valores de <span class="math inline">\(m_i\)</span> a partir de la matriz de tasas del sistema, donde debemos indicar el estado o estados para los que queremos calcular el tiempo hasta el primer paso.</p>
<div class="sourceCode" id="cb538"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Función para la resolución numérica de los tiempos de primer paso en cmtc</span>
<span class="va">tiempos.primer.paso</span><span class="op">&lt;-</span><span class="kw">function</span><span class="op">(</span><span class="va">Rmat</span>, <span class="va">A</span>, <span class="va">estados</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Parámetros de la función</span>
  <span class="co">#=========================</span>
  <span class="co"># Rmat: matriz de tasas del sistema</span>
  <span class="co"># A: vector de estados que queremos alcanzar</span>
  <span class="co"># estados: conjunto de estados total (como carácter)</span>
  
  <span class="co"># Estados como texto</span>
  
  <span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="va">estados</span><span class="op">)</span>
  <span class="co"># Tasas r</span>
  <span class="va">rts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">Rmat</span>, <span class="fl">1</span>, <span class="va">sum</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">Rmat</span><span class="op">)</span><span class="op">)</span>
  <span class="co"># Seleccionamos el subconjunto de la matriz quitando fila y columna</span>
  <span class="va">Rmod</span> <span class="op">&lt;-</span> <span class="va">Rmat</span><span class="op">[</span><span class="op">-</span><span class="va">A</span>, <span class="op">-</span><span class="va">A</span><span class="op">]</span>
  <span class="va">rates</span> <span class="op">&lt;-</span> <span class="va">rts</span><span class="op">[</span><span class="op">-</span><span class="va">A</span>, <span class="op">-</span><span class="va">A</span><span class="op">]</span>
  <span class="co"># Número de m´s a estimar</span>
  <span class="va">lms</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">Rmod</span><span class="op">)</span>
  <span class="co"># Matriz de coeficientes del sistema de ecuaciones de balance</span>
  <span class="va">B</span> <span class="op">&lt;-</span> <span class="va">rates</span> <span class="op">-</span> <span class="va">Rmod</span>
  <span class="co"># Vector de términos independientes del sistema</span>
  <span class="va">CS</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">lms</span><span class="op">)</span>
  <span class="co"># Resolución del sistema</span>
  <span class="va">ps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/qr.html">qr.solve</a></span><span class="op">(</span><span class="va">B</span>, <span class="va">CS</span><span class="op">)</span><span class="op">)</span>
  <span class="fu"><a href="https://tibble.tidyverse.org/reference/rownames.html">rownames</a></span><span class="op">(</span><span class="va">ps</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="st">"estado"</span>, <span class="va">estados</span><span class="op">)</span><span class="op">[</span><span class="op">-</span><span class="va">A</span><span class="op">]</span>
  <span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">ps</span><span class="op">)</span> <span class="op">&lt;-</span><span class="st">"tiempo"</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">ps</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<div class="example">
<p><span id="exm:unlabeled-div-55" class="example"><strong>Ejemplo 4.15  </strong></span>En las condiciones del sistema <span class="math inline">\(M/M/1/K\)</span> del <a href="CMTC.html#cajerobancario">Cajero Bancario</a> descrito anteriormente, estamos interesados en conocer el tiempo que debe transcurrir hasta que la cola esté vacía, si ahora mismo hay un cliente en el sistema y cero en la cola (<span class="math inline">\(X_0 = 1\)</span>). Recordemos que el espacio de estados hace referencia al número de clientes en la cola y viene dado por <span class="math inline">\(\{0, 1, 2, 3, 4, 5\}.\)</span></p>
</div>
<div class="sourceCode" id="cb539"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definición matriz de tasas</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fl">6</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">R</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">10</span>
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">15</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">10</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">15</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">10</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">15</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">10</span>
<span class="va">R</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">15</span>
<span class="va">R</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">6</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">10</span>
<span class="va">R</span><span class="op">[</span><span class="fl">6</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">15</span>

<span class="co"># Tiempos de primer paso el estado 1 (0 clientes en el sistema) que deseamos alcanzar (corresponde con el primer elemento del espacio de estados)</span>
<span class="fu">tiempos.primer.paso</span><span class="op">(</span><span class="va">R</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span></code></pre></div>
<pre><code>##             tiempo
## estado 1 0.1736626
## estado 2 0.3341564
## estado 3 0.4748971
## estado 4 0.5860082
## estado 5 0.6526749</code></pre>
<p>El tiempo esperado hasta que la cola esté vacía de nuevo es de 0.1736 horas, o lo que es lo mismo, 10.42 minutos.</p>
<div class="example">
<p><span id="exm:unlabeled-div-56" class="example"><strong>Ejemplo 4.16  </strong></span>En las condiciones del sistema de <a href="CMTC.html#mantAeronaves">Mantenimiento de aronaves</a> descrito anteriormente. Supongamos que en un experimento de prueba, el avión despega con cuatro motores que funcionan correctamente y sigue volando hasta que se estrella. Estamos interesados en conocer el tiempo esperado hasta el primer accidente.</p>
<p>El espacio de estados del sistema es <span class="math inline">\(\{1, 2,...,,9\}\)</span>, y sabemos que el avión se estrellará si en algún momento accedemos al subconjunto de estados <span class="math inline">\(\{1, 2, 3, 4, 7\}\)</span>. Calculamos los tiempos de primer paso cuando <span class="math inline">\(X_0 = \{5, 6, 8, 9\}\)</span>, aunque como el avión está en condiciones óptimas para despegar nos debemos fijar en el valor correspondiente al estado 9. Recordemos que el tiempo medio hasta que falla un motor es de 200 horas, de forma que <span class="math inline">\(\lambda = 1/200 = 0.005\)</span>.</p>
</div>
<div class="sourceCode" id="cb541"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definición matriz de tasas</span>
<span class="va">nestados</span> <span class="op">&lt;-</span> <span class="fl">9</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">0.005</span>
<span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">nestados</span>, ncol <span class="op">=</span> <span class="va">nestados</span>, data <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="va">R</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">6</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span> 
<span class="va">R</span><span class="op">[</span><span class="fl">6</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">7</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">8</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">8</span>,<span class="fl">7</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">9</span>,<span class="fl">6</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">lambda</span>
<span class="va">R</span><span class="op">[</span><span class="fl">9</span>,<span class="fl">8</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">lambda</span>

<span class="co"># Conjunto que debemos alcanzar</span>
<span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>, <span class="fl">7</span><span class="op">)</span>
<span class="co"># Tiempos de primer paso </span>
<span class="fu">tiempos.primer.paso</span><span class="op">(</span><span class="va">R</span>, <span class="va">A</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">9</span><span class="op">)</span></code></pre></div>
<pre><code>##            tiempo
## estado 5 100.0000
## estado 6 133.3333
## estado 8 133.3333
## estado 9 183.3333</code></pre>
<p>De esta forma, si el avión parte en condiciones óptimas (estado 9) el tiempo hasta que ocurra un accidente que le impida volar es de 183.33 horas, o lo que es lo mismo 183 horas y 20 minutos.</p>
</div>
<div id="ejer-u4" class="section level2" number="4.11">
<h2>
<span class="header-section-number">4.11</span> Ejercicios<a class="anchor" aria-label="anchor" href="#ejer-u4"><i class="fas fa-link"></i></a>
</h2>
<div id="básicos-3" class="section level3" number="4.11.1">
<h3>
<span class="header-section-number">4.11.1</span> Básicos<a class="anchor" aria-label="anchor" href="#b%C3%A1sicos-3"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Ejercicio B4.1.</strong> Para el proceso de <a href="CMTC.html#excmtc007">Mantenimiento de máquinas</a> estamos interesados en calcular el valor esperado del número de máquinas en funcionamiento después de 9 horas de funcionamiento, suponiendo que el sistema empieza con todas las máquinas paradas.</p>
<p><strong>Ejercicio B4.2.</strong> Para el proceso de <a href="CMTC.html#mantAeronaves">Mantenimiento de aronaves</a> supongamos que cada motor funciona en promedio unas 200h antes de detectarse cualquier problema. Si los cuatro motores están funcionando antes de comenzar un vuelo de seis horas, ¿cuál es la probabilidad de que el vuelo llegue de forma segura? (Ayuda: Para resolver este ejercico ten en cuenta la codificación de estados establecida en la definición del sistema).</p>
<p><strong>Ejercicio B4,3.</strong> Para el proceso de <a href="CMTC.html#centralTelefonica">Central telefónica</a> supongamos que la capacidad total de la centralita es de 10 llamadas y que se reciben llamadas a una tasa de 1 por minuto, y que el tiempo medio de atención de cada llamada es de 10 minutos. Si ahora mismo la centralita está atendiendo a 3 llamadas:</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la probabilidad de que la centralita esté como máximo al 50% de su capacidad dentro de media hora? ¿Y dentro de una hora?</li>
<li>Si la centralita está activa durante 6 horas más, ¿cuántas llamadas estarán pendientes al finalizar el tiempo de trabajo?</li>
</ol>
<p><strong>Ejercicio B4.4.</strong> Para el proceso de <a href="CMTC.html#gestInventcmtc">Gestión de inventarios</a> supongamos que la capacidad máxima de stock del producto <span class="math inline">\(KD\)</span> es 20, y que se solicitan nuevas piezas cuando el stock es inferior a 6. Además tenemos que la tasa de entrega de nuevos productos es de tres días, mientras que la demanda de dicho producto es de 3 piezas/dia.</p>
<ol style="list-style-type: decimal">
<li>Si en estos momentos no hay stock de la pieza <span class="math inline">\(KD\)</span>, la empresa está interesada en saber cuál es el stock más probable dentro de 8 días.</li>
<li>¿Cuál es la probabilidad de que tenga que reabastecerse en esa fecha?</li>
</ol>
<p><strong>Ejercicio B4.5.</strong> Para el proceso <span class="math inline">\(M/M/1/K\)</span> del <a href="CMTC.html#cajerobancario">Cajero Bancario</a> supongamos que los clientes llegan con una tasa de 10 por hora y que tardan en promedio unos cuatro minutos en realizar las operaciones con el cajero. Supongamos que hay espacio para una cola de cinco clientes mientras un cliente está siendo atendido. Si el cajero está inactivo ahora mismo, ¿cuánto tiempo permanecerá inactivo durante la próxima hora?</p>
<p><strong>Ejercicio B4.6.</strong> Para el <a href="CMTC.html#fabricaCMTC">Proceso de fabricación</a> consideramos la situación siguiente. Supongamos que el sistema funciona las 24 horas del día, las demandas se producen a cinco por hora y el tiempo medio de fabricación de un artículo es de 10 minutos. La máquina se pone en marcha cuando el stock de artículos fabricados se reduce a dos, y permanece encendida hasta que las existencias aumentan a cuatro, momento en el que se apaga. Supongamos que el stock es de cuatro (y la máquina está apagada) al principio. Estamos interesados en cuánto tiempo estará la máquina está encendida durante las siguientes 24 horas.</p>
<p><strong>Ejercicio B4.7.</strong> Para el proceso de <a href="CMTC.html#gestInventcmtc">Gestión de inventarios</a> supongamos que la capacidad máxima de stock del producto <span class="math inline">\(KD\)</span> es 20, y que se solicitan nuevas piezas cuando el stock es inferior a 6. Además tenemos que la tasa de entrega de nuevos productos es de tres días, mientras que la demanda de dicho producto es de 3 piezas/dia. Si en estos momentos no hay stock de la pieza <span class="math inline">\(KD\)</span>, la empresa esta interesada en saber cuánto tiempo tardará en tener que reabastecerse durante los próximos 8 días.</p>
<p><strong>Ejercicio B4.8.</strong> Para el proceso de <a href="CMTC.html#centralTelefonica">Central telefónica</a> supongamos que la capacidad total de la centralita es de 10 llamadas y que se reciben llamadas a una tasa de 1 por minuto, y que el tiempo medio de atención de cada llamada es de 10 minutos.</p>
<ol style="list-style-type: decimal">
<li>Si ahora mismo la centralita está atendiendo a 3 llamadas, ¿cuál es el tiempo esperado de que el sistema esté por encima del 80% de ocupación?</li>
<li>¿Y por debajo del 20%?</li>
<li>¿Cuánto tiempo el sistema estará a plena capacidad?</li>
</ol>
<p><strong>Ejercicio B4.9.</strong> Para el sistema de <a href="CMTC.html#excmtc007">Mantenimiento de máquinas</a> consideramos cuatro máquinas disponibles y dos operarios para repararlas en caso de fallo, con tiempos de vida de las máquinas exponenciales con media de 3 días, y tiempos medios de reparación de 2 horas. Estamos interesados en:</p>
<ol style="list-style-type: decimal">
<li>la probabilidad a largo plazo de que todas las máquinas estén en funcionamiento,</li>
<li>la fracción de tiempo a largo plazo que los dos operarios están ocupados.</li>
</ol>
<p><strong>Ejercicio B4.10.</strong> Para el proceso <span class="math inline">\(M/M/1/K\)</span> del <a href="CMTC.html#cajerobancario">Cajero Bancario</a> supongamos que los clientes llegan con una tasa de 10 por hora y que tardan en promedio unos cuatro minutos en realizar las operaciones con el cajero. Supongamos que hay espacio como máximo para cinco clientes en cola mientras que un cliente está siendo atendido.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la probabilidad de que tengamos más de dos clientes en la cola?</li>
<li>¿Y de que tengamos como máximo 2?</li>
<li>¿Cómo interpretamos estas probabilidades?</li>
</ol>
<p><strong>Ejercicio B4.11.</strong> Para el sistema de <a href="CMTC.html#mantAeronaves">Mantenimiento de aronaves</a> estamos interesados en conocer cuál es la probabilidad de que el avión no pueda finalizar el vuelo.</p>
<p><strong>Ejercicio B4.12.</strong> Para el sistema del <a href="CMTC.html#viajanteCMTC">Sistema del viajante</a> estamos interesados en saber cuánto tiempo permanecerá en cada ciudad (en términos porcentuales y a largo plazo). En este caso la matriz de tasas debe tener en cuenta las probabilidades de moverse de una ciudad a otra. Si el beneficio que obtiene el vendedor es de 80 euros/día en la ciudad A, 100 euros/día en la ciudad B, 125 euros/día en C, y que además se incurre en un gasto por desplazamiento de 25 céntimos por kilómetro cuando hay 50 kilómetros entre A y B, 65 kilómetros entre A y C, y 80 kilómetros entre B y C.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es el beneficio total esperado del sistema para un periodo de un mes?</li>
<li>¿Cuál es el beneficio/coste diario a largo plazo?</li>
<li>Si el viajante comienza su viaje en la ciudad A ¿cuánto tiempo transcurrirá hasta que el viajante vuelva a esa ciudad?</li>
</ol>
<p><strong>Ejercicio B4.13.</strong> Un taller mecánico tiene dos taladradoras y dos tornos. Los tiempos de vida de las taladradoras son v.a. <span class="math inline">\(Exp(\mu_a)\)</span> y las de los tornos <span class="math inline">\(Exp(\mu_o)\)</span>. El taller mecánico tiene dos reparadores: Alberto y Roberto. Alberto puede reparar tanto tornos como taladros, mientras que Roberto sólo puede reparar tornos. Los tiempos de reparación de las taladradoras son <span class="math inline">\(Exp(\lambda_a)\)</span> y para los tornos <span class="math inline">\(Exp(\lambda_o)\)</span>, independientemente de quién repare las máquinas. Las taladradoras tienen prioridad en las reparaciones. Las reparaciones pueden adelantarse. Haciendo las suposiciones de independencia apropiadas, modelar este taller mecánico como un CMTC, considerando el proceso <span class="math inline">\(A(t) = (a, o)\)</span> que indica el número de taladros y tornos en funcionamiento en el instante <span class="math inline">\(t\)</span> y obtener la correspondiente matriz de tasas.</p>
</div>
<div id="avanzados-3" class="section level3" number="4.11.2">
<h3>
<span class="header-section-number">4.11.2</span> Avanzados<a class="anchor" aria-label="anchor" href="#avanzados-3"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Ejercicio A4.1</strong> Un fondo de inversión se clasifica en cuatro estados según los beneficios que produce por unidad de tiempo: altos, medios, bajos, y pérdidas. Además, el movimiento entre estados puede ser visto como una CMTC con matriz de tasas:</p>
<p><span class="math display">\[R = \begin{pmatrix}
0 &amp; 0.1 &amp; 0.1 &amp; 0\\
0 &amp; 0 &amp; 0.3 &amp; 0.1\\
0 &amp; 0 &amp; 0.5 &amp; 0.5\\
1.5 &amp; 0 &amp; 0  &amp; 0 
\end{pmatrix}\]</span></p>
<p>Mientras que el sistema está en cada uno de los estados, el beneficio respectivo estimado es de 500, 250, 100, y -600 euros por unidad de tiempo.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es el coste total esperado para un periodo de 10 unidades de tiempo?</li>
<li>¿Cuál será la tasa de coste a largo plazo?</li>
<li>Si ahora mismo estamos en pérdidas, ¿cuánto tiempo tiene que pasar hasta que alcanzemos beneficios altos?</li>
<li>La empresa considera que si el coste del estado de pérdidas se duplicara, esto es, pasara de 600 a 1200, mejorarían los datos de las cuestiones anteriores. ¿Qué le podemos decir a la empresa?</li>
</ol>
<p><strong>Ejercicio A4.2.</strong> Sea <span class="math inline">\(\{X_t, t \geq 0\}\)</span> una CMTC con estados <span class="math inline">\(\{1, 2, 3, 4, 5\}\)</span> y matriz de tasas</p>
<p><span class="math display">\[
R = \begin{pmatrix}
0 &amp; 4 &amp; 4 &amp; 0 &amp; 0\\
5 &amp; 0 &amp; 5 &amp; 5 &amp; 0\\
5 &amp; 5 &amp; 0 &amp; 4 &amp; 4\\
0 &amp; 5 &amp; 5  &amp; 0 &amp; 4\\
0 &amp; 0&amp; 5&amp; 5&amp; 0
\end{pmatrix}
\]</span></p>
<ol style="list-style-type: decimal">
<li>Calcular la matriz de tiempos de ocupación para <span class="math inline">\(t=0.2\)</span>.</li>
<li>Obtener la distribución límite del proceso.</li>
<li>Si el sistema incurre en costes de acuerdo a la ecuación <span class="math inline">\(c(i) = 2i+1, \quad 1\leq i\leq 5\)</span>, ¿cuál es el coste total esperado acumulado en 10 unidades de tiempo, si el sistema está ahora mismo en el estado 2?</li>
<li>¿Cuál sería la tasa de coste a largo plazo?</li>
<li>¿Cuál es el tiempo esperado para pasar del estado 1 al estado 5?</li>
</ol>
<p><strong>Ejercicio A4.3.</strong> Sea <span class="math inline">\(\{X_t, t \geq 0\}\)</span> una CMTC con estados <span class="math inline">\(\{1, 2, 3, 4, 5, 6\}\)</span> y matriz de tasas</p>
<p><span class="math display">\[
R = \begin{pmatrix}
0 &amp; 6 &amp; 6 &amp; 8 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 6 &amp; 8 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 6 &amp; 4 &amp; 0\\
0 &amp; 6 &amp; 8  &amp; 0 &amp; 0 &amp; 0\\
6 &amp; 0&amp; 0&amp; 0&amp; 6 &amp; 0
\end{pmatrix}
\]</span></p>
<ol style="list-style-type: decimal">
<li>Calcular la matriz de tiempos de ocupación para <span class="math inline">\(t=0.1\)</span>.</li>
<li>Obtener la distribución límite del proceso.</li>
<li>Si el sistema incurre en costes de acuerdo a la ecuación <span class="math inline">\(c(i) = 2i^2+3, \quad 1\leq i\leq 6\)</span>, ¿cuál el coste total esperado en el intervalo de tiempo <span class="math inline">\([0, 15]\)</span>, si el sistema está ahora mismo en el estado 4?</li>
<li>¿Cuál sería la tasa de coste a largo plazo?</li>
<li>¿Cuál es el tiempo esperado para pasar del estado 6 al estado 4?</li>
</ol>
<p><strong>Ejercicio A4.4.</strong> Un peso de <span class="math inline">\(18\)</span> toneladas está sostenido por <span class="math inline">\(3\)</span> cables que se reparten la carga por igual. Cuando uno de los cables se rompe, los restantes que no se han roto, se reparten la carga a partes iguales. Cuando se rompe el último cable, se produce un fallo. La tasa de fallos de un cable es <span class="math inline">\(0.2\)</span> por año y tonelada. Los tiempos de vida de los <span class="math inline">\(3\)</span> cables son independientes entre sí. Se considera <span class="math inline">\(X_t\)</span> como el número de cables que siguen sin romperse en el momento <span class="math inline">\(t\)</span>.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la probabilidad de que el sistema no falle en dos años?</li>
<li>¿Cuánto tiempo tardará el sistema en fallar si ahora los tres cables están bien?</li>
</ol>
<p><strong>Ejercicio A4.5.</strong> Un ordenador tiene cinco unidades de procesamiento (CPUs). Los tiempos de vida de las CUPs son v.a. iid exponenciales de media 2 años. Cuando una CPU falla, el ordenador intenta aislarla automáticamente y reconfigurar el sistema con las demás CPU. Sin embargo, este proceso tiene éxito con una probabilidad <span class="math inline">\(0.94\)</span>, denominada factor de cobertura. Si la reconfiguración tiene éxito, el sistema continúa con una CPU menos. Si el proceso falla, todo el sistema se bloquea. Supongamos que el proceso de reconfiguración es instantáneo y que una vez que el sistema se bloquea, se detiene definitivamente. Se considera <span class="math inline">\(X_t\)</span> igual a cero si el sistema ha dejado de funcionar en el instante <span class="math inline">\(t\)</span>, o en caso contrario es igual al número de CPUs en funcionamiento en el momento <span class="math inline">\(t\)</span>.</p>
<ol style="list-style-type: decimal">
<li>Si todos los procesadores están en funcionamiento en el instante inicial, ¿cuál es la probabilidad de que los cinco procesadores funcionen 5 años sin fallos?</li>
</ol>
<p>Imaginemos ahora que el sistema puede ser reparado cuando falla. El tiempo necesario para la reparación es una variable aleatoria exponencial de media 5 días, y una vez se finaliza, todas las CPUS funcionan de nuevo.</p>
<ol start="2" style="list-style-type: decimal">
<li>¿Cuál es la probabilidad de que el sistema este en reparación?.</li>
<li>¿Cuánto tiempo tardará el sistema en fallar si en estos momentos funcionan todos los procesadores?</li>
<li>Supongamos que cada hora de trabajo de cada procesador proporciona 100 euros de beneficio, mientras que las reparaciones cuestan 200 euros/hora. ¿Cuál es el beneficio esperado durante el primer año si los cinco procesadores están trabajndo ahora mismo?</li>
</ol>
<p><strong>Ejercicio A4.6.</strong> Una estación de servicio tiene tres servidores (1, 2 y 3). Cuando llega un cliente, es asignado al servidor libre con el índice más bajo. Si los servidores están ocupados, el cliente no se detiene y deja la estación de servicio. Los tiempos de servicio de cada servidor son v.a. <span class="math inline">\(Exp(\mu_i)\)</span> con:</p>
<ul>
<li>media de 8 minutos para el servidor 1,</li>
<li>la media del servidor 2 es dos veces mayor que la del servidor 3,</li>
<li>la media del servidor 1 es dos veces mayor que la del servidor 2.</li>
</ul>
<p>Los clientes llegan de acuerdo a un <span class="math inline">\(PP(\lambda)\)</span> con tasa de 20 clientes por hora.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la probabilidad de que los tres servidores estén ocupados a los 20 minutos, asumiendo que el sistema está vacio en el instante 0?</li>
<li>¿Cuál es el tiempo de ocupación de cada estado del sistema en 50 minutos, asumiendo que el sistema está vacio en el instante 0?</li>
<li>¿Cuál es el tiempo esperado hasta que los tres servidores estén libres, asumiendo que el sistema tiene un cliente?</li>
<li>Si los costes de los tres servidores son 40, 20 y 10 euros por hora respectivamente, ¿cuál es el valor de <span class="math inline">\(c\)</span> más pequeño que hace que el sistema sea rentable a largo plazo?</li>
</ol>
<p><strong>Ejercicio A4.7.</strong> Una estación de servicio monoservicio atiende a dos tipos de clientes. Los clientes de tipo <span class="math inline">\(i, i = 1, 2,\)</span> llegan según un <span class="math inline">\(PP(\lambda_i)\)</span> independientes. La estación tiene espacio para atender como máximo a <span class="math inline">\(K\)</span> clientes. Los tiempos de servicio son variables aleatorias iid <span class="math inline">\(Exp(\mu)\)</span> para ambos tipos de clientes. La política de admisión es la siguiente: si en el momento de una llegada, el número total de clientes en el sistema es <span class="math inline">\(M\)</span> o menos (<span class="math inline">\(M &lt; K\)</span> es un número entero fijo), se permite que el cliente que llega se incorpore a la cola; en caso contrario sólo si es del tipo 1. Esto crea un trato preferente para los clientes de tipo 1. Sea <span class="math inline">\(X_t\)</span> el número de clientes (de ambos tipos) en el sistema en el instante <span class="math inline">\(t\)</span>.Las tasas de llegadas son de 5 minutos, la tasa de servicio de 4 minutos, <span class="math inline">\(K = 5\)</span> y <span class="math inline">\(M = 3\)</span>.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la variable de interés del sistema?</li>
<li>¿Cuáles son los tiempos de ocupación en el periodo de 60 minutos desde el inicio del servicio, si en el instante inicial no hay clientes? ¿Cómo se interpretan?</li>
<li>¿Cuál es la probabilidad a largo plazo de que la estación esté vacía?</li>
<li>Si al abrir la gasolinera tenemos un cliente, ¿cuánto tiempo debe pasar hasta que rechacemos el primer cliente?</li>
</ol>
<p><strong>Ejercicio A4.8</strong> Una pequeña gasolinera tiene un surtidor y espacio para un total de tres coches (uno en el en el surtidor y dos en espera). El tiempo entre las llegadas de los coches a la estación es una v.a. exponencial con una tasa media de llegada de 10 coches por hora. El tiempo que cada coche pasa delante del surtidor es una variable aleatoria exponencial con una media de cinco minutos (es decir, una tasa media de 12 por hora). Si hay tres coches en la estación y llega otro coche, el coche recién llegado sigue su camino y nunca entra en la estación. Considera <span class="math inline">\(X_t\)</span> como el número de coches en la estación en el momento <span class="math inline">\(t\)</span>.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la probabilidad a largo plazo de que la estación esté vacía?</li>
<li>¿Cuál es el número esperado de coches en la estación a largo plazo?</li>
<li>¿Cuál es la proporción de tiempo que la estación estará al completo en un periodo de 8 horas?</li>
<li>Si al abrir la gasolinera tenemos un cliente, ¿cuánto tiempo debe pasar hasta que no tengamos ningún cliente en el sistema? ¿Y más de uno?</li>
</ol>
<p><strong>Ejercicio A4.9</strong> (Cola <span class="math inline">\(M^x/M/1/K\)</span>). Una pequeña tienda de autoservicio 24 horas de carretera tiene espacio para 5 automóviles en el parking. Los vehículos llegan al azar, siendo los tiempos de llegada una v.a. exponencial con una media de 10 vehículos por hora. El número de personas dentro de cada coche es una variable aleatoria, <span class="math inline">\(N\)</span>, donde <span class="math inline">\(P(N = 1) = 0.1\)</span>, <span class="math inline">\(P(N = 2) = 0.7\)</span> y <span class="math inline">\(P(N = 3) = 0.2\)</span>. La gente de los coches entra en la tienda y permanece en ella un tiempo exponencial. La duración media de la estancia en la tienda es de 10 minutos y cada persona actúa de forma independiente a todas las demás, saliendo de la tienda por separado y esperando en sus coches a los demás. Si llega un coche y la tienda está demasiado llena para que todas las personas del coche entren en ella, el coche saldrá y nadie de ese coche entrará en la tienda.</p>
<ol style="list-style-type: decimal">
<li>Si <span class="math inline">\(X_t\)</span> es el número de individuos en la tienda en el momento <span class="math inline">\(t\)</span>, obtén la matriz de tasas correspondiente a este proceso.</li>
<li>¿Cuál es la probabilidad a largo plazo de que la tienda esté vacía?</li>
<li>¿Cuál es la proporción de tiempo que la estación estará completa en un periodo de 24 horas?</li>
</ol>
<p><strong>Ejercicio A4.10.</strong> Un determinado equipo electrónico tiene dos componentes A y B. El tiempo hasta fallo del componente A está descrito por una función de distribución exponencial con un tiempo medio de 100 horas. El componente B tiene una vida media hasta el fallo de 200 horas y también está descrito por una distribución exponencial. Cuando uno de los componentes falla, el equipo se apaga y se realiza el mantenimiento. El tiempo de reparación del componente se distribuye exponencialmente con un tiempo medio de 5 horas si fue A el que falló y 4 horas si es B el que falla. Se considera el proceso <span class="math inline">\(X_t\)</span> con espacio de estados <span class="math inline">\(\{1, 2, 3\}\)</span> donde el estado <span class="math inline">\(1\)</span> denota que el equipo está funcionando, <span class="math inline">\(2\)</span> denota que el componente A ha fallado, y <span class="math inline">\(3\)</span> denota que el componente B ha fallado.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la probabilidad a largo plazo de que el equipo funcione?</li>
<li>¿Cuál es la proporción de tiempo esperado que el sistema estará funcionando durante las próximas 500 horas?</li>
<li>Un contratista externo realiza los trabajos de reparación de los componentes cuando se produce un fallo y cobra 100 euros por hora por el tiempo más los gastos de viaje, lo que supone 500 euros más por cada visita. La empresa ha determinado que puede contratar y formar a su propio propio reparador. Si cuentan con su propio empleado para las reparaciones, les costará 40 euros por hora, tanto cuando la máquina esté en funcionamiento como cuando esté parada. Ignorando el coste de la formación inicial y la posibilidad de que un empleado contratado para los trabajos de reparación pueda hacer otras cosas mientras la máquina está en funcionamiento, ¿merece la pena económicamente contratar y formar a su propio personal?</li>
</ol>
<p><strong>Ejercicio A4.11.</strong> Una pieza de automóvil necesita tres operaciones de mecanizado realizadas en una determinada secuencia. Estas operaciones son realizadas por tres máquinas. La pieza se introduce en la primera máquina, donde la operación de mecanizado dura en media 1 minuto. Una vez finalizada la operación, la pieza pasa a la máquina 2, donde el mecanizado requiere un tiempo medio de 1.2 minutos. A continuación, pasa a la máquina 3, donde la operación dura en promedio 1 minuto. No hay espacio de almacenamiento entre las dos máquinas, por tanto si la máquina 2 esta trabajando, la pieza de la máquina 1 no puede ser retirada aunque la operación en la máquina 1 se haya completado. Decimos que la máquina 1 está bloqueada en este caso. Hay un amplio suministro de piezas sin procesar disponibles, de modo que la máquina 1 siempre puede procesar una nueva pieza cuando una pieza terminada se desplaza a la máquina 2.</p>
<ol style="list-style-type: decimal">
<li>Modelar este sistema como una CMTC. (Ayuda: Tener en cuenta que la máquina 1 puede trabajar o estar bloqueada, la máquina 2 puede estar trabajando, bloqueada o inactiva, y la máquina 3 puede estar trabajando o inactiva).</li>
<li>Calcular la cantidad de tiempo esperada que la máquina 1 está bloqueada durante la primera hora, asumiendo que todas la máquinas están trabajando en el instante inicial.</li>
<li>Calcular la fracción de tiempo a largo plazo en que la última máquina está trabajando en el sistema de producción.</li>
<li>Cada máquina cuesta 40 euros por hora mientras trabaja en un componente, y produce un beneficio de 75 euros/hora a la pieza en la que trabaja. El valor añadido, o el coste de funcionamiento, es cero cuando la máquina está parada o bloqueada. Calcula la contribución neta de las tres máquinas por unidad de tiempo a largo plazo.</li>
</ol>
</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="poissonprocess.html"><span class="header-section-number">3</span> Proceso de Poisson</a></div>
<div class="next"><a href="COLAS.html"><span class="header-section-number">5</span> Sistemas de colas</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#CMTC"><span class="header-section-number">4</span> Cadenas de Markov de Tiempo Contínuo</a></li>
<li><a class="nav-link" href="#CMTCA"><span class="header-section-number">4.1</span> Evolución del proceso</a></li>
<li><a class="nav-link" href="#CMTCB"><span class="header-section-number">4.2</span> Descripción del proceso</a></li>
<li>
<a class="nav-link" href="#CMTCC"><span class="header-section-number">4.3</span> Análisis preliminar del proceso</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#vidautil-maquina"><span class="header-section-number">4.3.1</span> Vida útil de una máquina</a></li>
<li><a class="nav-link" href="#viajanteCMTC"><span class="header-section-number">4.3.2</span> Sistema del viajante</a></li>
<li><a class="nav-link" href="#an%C3%A1lisis-con-simmer"><span class="header-section-number">4.3.3</span> Análisis con simmer</a></li>
<li><a class="nav-link" href="#mantAeronaves"><span class="header-section-number">4.3.4</span> Mantenimiento de aronaves</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#CMTCD"><span class="header-section-number">4.4</span> Procesos de nacimiento y muerte</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#cajerobancario"><span class="header-section-number">4.4.1</span> Cajero Bancario</a></li>
<li><a class="nav-link" href="#excmtc007"><span class="header-section-number">4.4.2</span> Mantenimiento de máquinas</a></li>
<li><a class="nav-link" href="#centralTelefonica"><span class="header-section-number">4.4.3</span> Central telefónica</a></li>
<li><a class="nav-link" href="#call-center"><span class="header-section-number">4.4.4</span> Call Center</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#CMTCE"><span class="header-section-number">4.5</span> Otros tipos de sistemas</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#gestInventcmtc"><span class="header-section-number">4.5.1</span> Gestión de inventarios</a></li>
<li><a class="nav-link" href="#fabricaCMTC"><span class="header-section-number">4.5.2</span> Proceso de fabricación</a></li>
</ul>
</li>
<li><a class="nav-link" href="#CMTCF"><span class="header-section-number">4.6</span> Análisis de transición</a></li>
<li><a class="nav-link" href="#CMTCG"><span class="header-section-number">4.7</span> Análisis de tiempos de ocupación</a></li>
<li><a class="nav-link" href="#CMTCH"><span class="header-section-number">4.8</span> Comportamiento límite del proceso</a></li>
<li>
<a class="nav-link" href="#CMTCI"><span class="header-section-number">4.9</span> Análisis de costes</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#coste-total-esperado-hasta-t"><span class="header-section-number">4.9.1</span> Coste total esperado hasta \(T\)</a></li>
<li><a class="nav-link" href="#tasas-de-coste-a-largo-plazo"><span class="header-section-number">4.9.2</span> Tasas de coste a largo plazo</a></li>
</ul>
</li>
<li><a class="nav-link" href="#CMTCJ"><span class="header-section-number">4.10</span> Tiempos de primer paso</a></li>
<li>
<a class="nav-link" href="#ejer-u4"><span class="header-section-number">4.11</span> Ejercicios</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#b%C3%A1sicos-3"><span class="header-section-number">4.11.1</span> Básicos</a></li>
<li><a class="nav-link" href="#avanzados-3"><span class="header-section-number">4.11.2</span> Avanzados</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Simulación de Procesos y Sistemas</strong>" was written by true, true. It was last built on 2022-05-08.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
