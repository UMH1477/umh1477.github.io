<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Unidad 2 Cadenas de Markov de Tiempo Discreto | Simulación de Procesos y Sistemas</title>
<meta name="description" content="En esta unidad trabajamos con un tipo especial de proceso estocástico de tiempo discreto: las Cadenas de Markov de Tiempo Discreto, a las que aludiremos en adelante como CMTD. Analizamos...">
<meta name="generator" content="bookdown 0.24 with bs4_book()">
<meta property="og:title" content="Unidad 2 Cadenas de Markov de Tiempo Discreto | Simulación de Procesos y Sistemas">
<meta property="og:type" content="book">
<meta property="og:description" content="En esta unidad trabajamos con un tipo especial de proceso estocástico de tiempo discreto: las Cadenas de Markov de Tiempo Discreto, a las que aludiremos en adelante como CMTD. Analizamos...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unidad 2 Cadenas de Markov de Tiempo Discreto | Simulación de Procesos y Sistemas">
<meta name="twitter:description" content="En esta unidad trabajamos con un tipo especial de proceso estocástico de tiempo discreto: las Cadenas de Markov de Tiempo Discreto, a las que aludiremos en adelante como CMTD. Analizamos...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.11/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="bs4_style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Simulación de Procesos y Sistemas</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Antes de comenzar</a></li>
<li><a class="" href="software.html">Software</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> Conceptos básicos</a></li>
<li><a class="active" href="cmtd.html"><span class="header-section-number">2</span> Cadenas de Markov de Tiempo Discreto</a></li>
<li><a class="" href="poissonprocess.html"><span class="header-section-number">3</span> Proceso de Poisson</a></li>
<li><a class="" href="CMTC.html"><span class="header-section-number">4</span> Cadenas de Markov de Tiempo Contínuo</a></li>
<li><a class="" href="COLAS.html"><span class="header-section-number">5</span> Sistemas de colas</a></li>
<li><a class="" href="SIMSIST.html"><span class="header-section-number">6</span> Aplicaciones prácticas</a></li>
<li><a class="" href="bibliograf%C3%ADa.html">Bibliografía</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="cmtd" class="section level1" number="2">
<h1>
<span class="header-section-number">Unidad 2</span> Cadenas de Markov de Tiempo Discreto<a class="anchor" aria-label="anchor" href="#cmtd"><i class="fas fa-link"></i></a>
</h1>
<p>En esta unidad trabajamos con un tipo especial de proceso estocástico de tiempo discreto: las Cadenas de Markov de Tiempo Discreto, a las que aludiremos en adelante como <strong>CMTD</strong>. Analizamos teóricamente este tipo de procesos y presentamos las herramientas de cálculo y simulación necesarias para poder resolver problemas asociados a sistemas reales modelizables con una CMTD. Utilizaremos en <code>R</code> la librería <strong>markovchain</strong>.<span class="citation"><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;a href="bibliograf%C3%ADa.html#ref-R-markovchain" role="doc-biblioref"&gt;Spedicato et al., &lt;em&gt;Markovchain&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;'><sup>29</sup></a></span></p>
<div id="definiciones" class="section level2" number="2.1">
<h2>
<span class="header-section-number">2.1</span> Definiciones<a class="anchor" aria-label="anchor" href="#definiciones"><i class="fas fa-link"></i></a>
</h2>
<div class="yellowbox">
<div class="definition">
<p><span id="def:CMTC" class="definition"><strong>Definición 2.1  </strong></span>Un proceso estocástico <span class="math inline">\(\{X(t), t \in \mathbb{N}^*\}\)</span>, con <span class="math inline">\(\mathbb{N}^*\)</span> el conjunto de todos los números naturales incluido el cero, y con espacio de estados de tipo discreto, <span class="math inline">\(S\)</span>, se denomina Cadena de Markov de Tiempo Discreto, si para cualquier par de estados <span class="math inline">\(i\)</span> y <span class="math inline">\(j\)</span> de <span class="math inline">\(S\)</span> se verifica la propiedad de Markov, esto es, que la probabilidad de que el proceso en un instante <span class="math inline">\(t+1\)</span> se encuentre en un estado <span class="math inline">\(j\)</span>, dado su comportamiento previo, sólo depende del estado en el que el sistema se encontraba justamente en el instante anterior <span class="math inline">\(t\)</span>, esto es, <span class="math inline">\(X(t)=i\)</span>, y no del estado del proceso en los instantes anteriores <span class="math inline">\(t-1, t-2,...,0\)</span>:</p>
<span class="math display" id="eq:cmtd">\[\begin{eqnarray}
&amp;Pr(X(t+1) = j | X(t) = i, X(t-1),...,X(0)) = \nonumber \\
&amp;= Pr(X(t+1) = j | X(t) = i),
\tag{2.1}
\end{eqnarray}\]</span>
<p>Utilizaremos indistintamente la siguiente notación:</p>
<p><span class="math display">\[\{X(n), n \in \mathbb{N}^*\}\equiv \{X_n,  n \geq 0\}\]</span></p>
</div>
</div>
<p>La probabilidad condicionada dada en <a href="cmtd.html#eq:cmtd">(2.1)</a> se denomina <strong>probabilidad de transición de un paso</strong> y se denota por <span class="math inline">\(p_{ij}(t,t+1)\)</span>, y es la probabilidad de que, dado que el proceso en el instante <span class="math inline">\(t\)</span> está en el estado <span class="math inline">\(i\)</span>, un instante más tarde, <span class="math inline">\(t+1\)</span> haya cambiado al estado <span class="math inline">\(j\)</span>:</p>
<p><span class="math display">\[p_{ij}(t,t+1)=Pr(X(t+1) = j | X(t) = i).\]</span></p>
<p>De forma similar podemos definir la probabilidad de transición de <span class="math inline">\(n\)</span> pasos, <span class="math inline">\(p_{ij}(t,t+n)\)</span> como la probabilidad de que, dado que el proceso en el instante <span class="math inline">\(t\)</span> está en el estado <span class="math inline">\(i\)</span>, <span class="math inline">\(n\)</span> instantes más tarde, <span class="math inline">\(t+n\)</span>, esté en el estado <span class="math inline">\(j\)</span> :</p>
<span class="math display" id="eq:probtrans">\[\begin{equation}
p_{ij}(t,t+n)=Pr(X(t+n) = j | X(t) = i).
\tag{2.2}
\end{equation}\]</span>
<p>Las probabilidades de transición así definidas cumplen que:</p>
<span class="math display">\[\begin{eqnarray*}
0 \leq p_{ij}(t,t+n) &amp;\leq &amp; 1 \\
\sum_{j \in S} p_{ij}(t,t+n) &amp;=&amp; 1, \quad n\geq 1.
\end{eqnarray*}\]</span>
<div class="yellowbox">
<div class="definition">
<p><span id="def:CMhomogenea" class="definition"><strong>Definición 2.2  </strong></span>Una <span class="math inline">\(CMTD\)</span> dada por <span class="math inline">\(\{X(t), t \in \mathbb{N}\}\)</span> es <strong>homogénea</strong> cuando tiene probabilidades de transición estacionarias, es decir, cuando <span class="math inline">\(p_{ij}(t, t+n)\)</span> no depende de <span class="math inline">\(t\)</span>, es decir, la probabilidad de cambiar del estado <span class="math inline">\(i\)</span> al estado <span class="math inline">\(j\)</span> en <span class="math inline">\(n\)</span> pasos es independiente del instante temporal en que se encuentre el proceso:</p>
<span class="math display">\[\begin{equation*}
p_{ij}(t, t+n) = p_{ij}(s, s+n).
\end{equation*}\]</span>
</div>
</div>
<p>En este curso sólo estudiaremos <span class="math inline">\(CMTD\)</span> homogéneas, por lo que para simplificar la notación, a partir de ahora las denotaremos como <span class="math inline">\(p_{ij}(n)\)</span> a las probabilidades de transición de <span class="math inline">\(n\)</span> pasos y <span class="math inline">\(p_{ij}\)</span> a las probabilidades de transición de un paso: <span class="math display">\[\begin{eqnarray*}
p_{ij} &amp;=&amp; Pr[X(t+1) = j | X(t) = i] \\
p_{ij}(n) &amp;=&amp; Pr[X(t+n) = j | X(t) = i].
\end{eqnarray*}\]</span></p>
<div class="yellowbox">
<div class="definition">
<p><span id="def:distriproceso" class="definition"><strong>Definición 2.3  </strong></span>El comportamiento aleatorio de una <span class="math inline">\(CMTD\)</span> está completamente determinado por las probabilidades de transición de la cadena y la distribución del estado inicial, de forma que la función de distribución del proceso en un instante de tiempo <span class="math inline">\(t\)</span> se calcula, mediante el teorema de la probabilidad total, según la Ecuación <a href="cmtd.html#eq:probtotal-cmtd">(2.3)</a>.</p>
<span class="math display" id="eq:probtotal-cmtd">\[\begin{equation}
Pr[X(t)= k] =  \sum_{i \in S} p_{ik}(t) p_i(0),
\tag{2.3}
\end{equation}\]</span>
<p>con <span class="math inline">\(p_i(0) = Pr(X(0) = i)\)</span> la probabilidad de que en el instante inicial el proceso se encuentre en el estado <span class="math inline">\(i\)</span>. De hecho, el vector</p>
<p><span class="math display">\[p(0) = \{p_i(0)= Pr[X(0) = i], \ i \in S\}\]</span>
se denomina <strong>distribución inicial de la cadena</strong> e identifica la distribución de probabilidad del proceso en el instante inicial o punto de partida del proceso.</p>
</div>
</div>
<p>De forma habitual se suelen expresar las probabilidades de transición de un paso para <span class="math inline">\(N\)</span> estados en una <span class="math inline">\(CMTD\)</span> mediante la denominada <strong>matriz de transición de un paso</strong> <span class="math inline">\(P\)</span>, que es una matriz estocástica con todos sus elementos constituidos por probabilidades, dada por:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
p_{11} &amp; p_{12} &amp; ... &amp; p_{1N}\\
p_{21} &amp; p_{22} &amp; ... &amp; p_{2N}\\
... &amp; ... &amp; ... &amp; ...\\
p_{N1} &amp; p_{N2} &amp; ... &amp; p_{NN}
\end{pmatrix}\]</span></p>
<p>La información sobre las probabilidades de transición también puede representarse de forma gráfica construyendo un diagrama de transición del <span class="math inline">\(CMTD\)</span>. Un <strong>diagrama de transición</strong> es un grafo dirigido con <span class="math inline">\(N\)</span> nodos, un nodo por cada estado del <span class="math inline">\(CMTD\)</span>. Hay un arco dirigido que va del nodo <span class="math inline">\(i\)</span> al nodo <span class="math inline">\(j\)</span> en el grafo si la transición del estado <span class="math inline">\(i\)</span> al estado <span class="math inline">\(j\)</span> es viable, esto es, <span class="math inline">\(p_{ij} \neq 0\)</span>. Los diagramas de transición se pueden utilizar como herramienta para visualizar la dinámica de la <span class="math inline">\(CMTD\)</span>.</p>
<p>De forma similar podemos definir la <strong>matriz de transición de n pasos</strong> con la matriz estocástica <span class="math inline">\(P(n)\)</span>:</p>
<p><span class="math display">\[P(n) = 
\begin{pmatrix}
p_{11}(n) &amp; p_{12}(n) &amp; ... &amp; p_{1N}(n)\\
p_{21}(n) &amp; p_{22}(n) &amp; ... &amp; p_{2N}(n)\\
... &amp; ... &amp; ... &amp; ...\\
p_{N1}(n) &amp; p_{N2}(n) &amp; ... &amp; p_{NN}(n)
\end{pmatrix}\]</span></p>
<p>con <span class="math display">\[\begin{eqnarray*}
0 \leq p_{ij}(n) &amp;\leq&amp; 1 \\
\sum_{j \in S} p_{ij}(n) &amp;=&amp; 1.
\end{eqnarray*}\]</span></p>
<p>De forma genérica denotamos por <span class="math inline">\(p(n)\)</span> a la distribución del proceso en la n-ésima transición:</p>
<p><span class="math display">\[p(n) = \{p_i(n)=Pr[X(n)=i], \ i \in S\}\]</span></p>
<p>Cualquier <span class="math inline">\(CMTD\)</span> homogénea verifica la denominada <strong>Ecuación de Chapman-Kolmogorov</strong> que permite calcular la probabilidad de transición de un estado <span class="math inline">\(i\)</span> a un estado <span class="math inline">\(j\)</span> en <span class="math inline">\(n\)</span> pasos a través de todas las probabilidades de transición de <span class="math inline">\(s\)</span> y <span class="math inline">\(n-s\)</span> pasos, para cualquier <span class="math inline">\(s&lt;n\)</span> y cualquier <span class="math inline">\(i\)</span> y <span class="math inline">\(j\)</span> en <span class="math inline">\(S\)</span>:</p>
<span class="math display" id="eq:ChapmanKol">\[\begin{equation}
p_{ij}(n) = \sum_{k \in S} p_{ik}(s) p_{kj}(n-s),
\tag{2.4}
\end{equation}\]</span>
<div class="yellowbox">
<div class="definition">
<p><span id="def:p-npasos" class="definition"><strong>Definición 2.4  </strong></span>Haciendo uso de la ecuación <a href="cmtd.html#eq:ChapmanKol">(2.4)</a> se puede demostrar que la matriz de transición de <span class="math inline">\(n\)</span> pasos <span class="math inline">\(P(n)\)</span> se puede obtener como la potencia <span class="math inline">\(n\)</span> de la matriz de transición de un paso <span class="math inline">\(P\)</span>, esto es,</p>
<span class="math display" id="eq:matriznpasos">\[\begin{equation}
P(n) = P^n,
\tag{2.5}
\end{equation}\]</span>
<p>de modo que conociendo la distribución inicial del proceso <span class="math inline">\(p(0)\)</span> y la matriz de transición de un paso <span class="math inline">\(P\)</span>, tenemos perfectamente identificada la distribución del proceso en cualquier momento:</p>
<span class="math display" id="eq:distriproceso">\[\begin{equation}
p(n) = p(0)P^n.
\tag{2.6}
\end{equation}\]</span>
</div>
</div>
</div>
<div id="libMC" class="section level2" number="2.2">
<h2>
<span class="header-section-number">2.2</span> Librería markovchain<a class="anchor" aria-label="anchor" href="#libMC"><i class="fas fa-link"></i></a>
</h2>
<p>Para trabajar con procesos <span class="math inline">\(CMTD\)</span> con <code>R</code> es útil la librería <code>markovchain</code>.<span class="citation"><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;a href="bibliograf%C3%ADa.html#ref-R-markovchain" role="doc-biblioref"&gt;Spedicato et al.&lt;/a&gt;&lt;/p&gt;'><sup>30</sup></a></span> Trabajamos a continuación sobre un problema sencillo, para crear la matriz y el diagrama de transición de la cadena de Markov.</p>
<div class="example">
<p><span id="exm:diagramCMTD" class="example"><strong>Ejemplo 2.1  </strong></span>Tenemos una <span class="math inline">\(CMTD\)</span> <span class="math inline">\(\{X(t), t \in \mathbb{N}\}\)</span> con espacio de estados <span class="math inline">\(S = \{a, b, c\}\)</span> y distribución inicial de la cadena dada por <span class="math inline">\(p_a(0)=0.4, p_b(0)=0.2\)</span> y <span class="math inline">\(p_c(0)=0.4\)</span>. La matriz de transición de un paso viene dada por:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.20 &amp; 0.30 &amp; 0.50\\
0.10 &amp; 0.00 &amp; 0.90\\
0.55 &amp; 0.00 &amp; 0.45
\end{pmatrix}\]</span></p>
</div>
<p>Planteamos resolver las cuestiones siguientes:</p>
<p>(1). Queremos representar el proceso a través de un grafo.</p>
<div class="whitebox">
<p>Para representar el proceso con <code>markovchain</code>, hemos de crear un vector con los estados y la matriz de transición con las probabilidades de transición. Definimos entonces el proceso con la función genérica <code><a href="https://rdrr.io/r/methods/new.html">new()</a></code> para generar un objeto del tipo <code>markovchain</code>:</p>
<p><span class="math display">\[new("markovchain",states,byrow=TRUE,transitionMatrix)\]</span></p>
<p>introduciendo el vector de estados en <code>states</code>, la matriz de transición en <code>transitionMatrix</code>, y especificando si dicha matriz se ha de leer por filas.</p>
<p>A continuación lo pintamos con la función <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>.</p>
</div>
<p>Procedemos con el ejemplo que nos atañe. El grafo en la Figura <a href="cmtd.html#fig:03-001">2.1</a> muestra los tres estados como nodos y las probabilidades de transición para pasar de un estado a otro en un único paso.</p>
<div class="sourceCode" id="cb186"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">require</a></span><span class="op">(</span><span class="va"><a href="https://github.com/spedygiorgio/markovchain/">markovchain</a></span><span class="op">)</span>
<span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span><span class="op">)</span>
<span class="co"># Creamos la matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.20</span>, <span class="fl">0.30</span>, <span class="fl">0.50</span>, <span class="fl">0.10</span>, <span class="fl">0.00</span>, <span class="fl">0.90</span>,<span class="fl">0.55</span>, <span class="fl">0.00</span>, <span class="fl">0.45</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">3</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># Creamos la CMTD</span>
<span class="va">proceso</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">proceso</span></code></pre></div>
<pre><code>## Unnamed Markov chain 
##  A  3 - dimensional discrete Markov Chain defined by the following states: 
##  a, b, c 
##  The transition matrix  (by rows)  is defined as follows: 
##      a   b    c
## a 0.20 0.3 0.50
## b 0.10 0.0 0.90
## c 0.55 0.0 0.45</code></pre>
<div class="sourceCode" id="cb188"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># y obtenemos el diagrama del proceso</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:03-001"></span>
<img src="02-CMTD_files/figure-html/03-001-1.png" alt="Grafo del proceso." width="95%"><p class="caption">
Figura 2.1: Grafo del proceso.
</p>
</div>
<p>(2). Si la <span class="math inline">\(CMTD\)</span> está en el estado <span class="math inline">\(c\)</span> en el momento 17, ¿cuál es la probabilidad de que esté en el estado <span class="math inline">\(a\)</span> en el momento 18?</p>
<ul>
<li>RESPUESTA: Nos preguntan por la probabilidad de transición para pasar, en un solo paso, del estado <span class="math inline">\(c\)</span> (3) al estado <span class="math inline">\(a\)</span> (1), por lo que viene dada por la componente <span class="math inline">\(p_{31}\)</span> de la matriz de transición, es decir, 0.55.</li>
</ul>
<div class="whitebox">
<p>Para resolver el cálculo con el ordenador basta utilizar la función <code><a href="https://rdrr.io/pkg/markovchain/man/transitionProbability.html">transitionProbability()</a></code>, con los argumentos: <code>object</code> (la cadena de markov), <code>t0</code> (el estado en el instante inicial), <code>t1</code> (el estado en el instante final).</p>
</div>
<p>Así la pregunta (2) se responde con:</p>
<div class="sourceCode" id="cb189"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/transitionProbability.html">transitionProbability</a></span><span class="op">(</span>object <span class="op">=</span> <span class="va">proceso</span>, t0 <span class="op">=</span> <span class="st">"c"</span>, t1 <span class="op">=</span> <span class="st">"a"</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.55</code></pre>
<p>(3). Si la <span class="math inline">\(CMTD\)</span> está en el estado <span class="math inline">\(c\)</span> en un momento dado, ¿cuál es la probabilidad de que esté en el estado <span class="math inline">\(a\)</span> transcurridos tres unidades de tiempo? ¿y después de 10?</p>
<ul>
<li>RESPUESTA: Para resolver esta cuestión definimos el estado inicial y lo multiplicamos por la matriz de transición que corresponda, que en este caso, aplicando la Ecuación <a href="cmtd.html#eq:matriznpasos">(2.5)</a>, será <span class="math inline">\(P^n\)</span>, para <span class="math inline">\(n=3\)</span> y <span class="math inline">\(n=10\)</span>. Obtendremos así la distribución de probabilidad en <span class="math inline">\(n\)</span> transiciones, con la probabilidad de llegar a cada uno de los eventos posibles, <span class="math inline">\(\{a,b,c\}\)</span> en <span class="math inline">\(n\)</span>, partiendo de un estado inicial dado.</li>
</ul>
<div class="sourceCode" id="cb191"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Estado inicial en c</span>
<span class="va">sini</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span>
<span class="co"># matriz de transición de 3 pasos</span>
<span class="va">mt3</span> <span class="op">&lt;-</span> <span class="va">proceso</span><span class="op">^</span><span class="fl">3</span>
<span class="co"># Situación del proceso dentro de 3 instantes</span>
<span class="va">sini</span><span class="op">*</span><span class="va">mt3</span></code></pre></div>
<pre><code>##             a       b        c
## [1,] 0.350625 0.10725 0.542125</code></pre>
<div class="sourceCode" id="cb193"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># matriz de transición de 10 pasos</span>
<span class="va">mt10</span> <span class="op">&lt;-</span> <span class="va">proceso</span><span class="op">^</span><span class="fl">10</span>
<span class="co"># Situación del proceso dentro de 10 instantes</span>
<span class="va">sini</span><span class="op">*</span><span class="va">mt10</span></code></pre></div>
<pre><code>##              a         b         c
## [1,] 0.3703899 0.1110948 0.5185153</code></pre>
<p>(4). ¿Cuál es la distribución de probabilidad del proceso transcurridos <span class="math inline">\(10\)</span> instantes de tiempo desde el momento inicial del proceso, sea cual sea su estado?</p>
<ul>
<li>RESPUESTA: Si conocemos la distribución de probabilidad en el estado inicial, <span class="math inline">\(p(0)\)</span>, podemos obtener la distribución de probabilidad en <span class="math inline">\(n\)</span> transiciones con la Ecuación :</li>
</ul>
<div class="sourceCode" id="cb195"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">### Distribución de probabilidad del proceso dentro de 10 instantes</span>
<span class="co"># Distribución de  probabilidad inicial</span>
<span class="va">dini</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.4</span>, <span class="fl">0.2</span>, <span class="fl">0.4</span><span class="op">)</span>
<span class="co"># matriz de transición de 10 pasos</span>
<span class="va">mt10</span> <span class="op">&lt;-</span> <span class="va">proceso</span><span class="op">^</span><span class="fl">10</span>
<span class="co"># distribución de probabilidad en 10 pasos</span>
<span class="va">dini</span><span class="op">*</span><span class="va">mt10</span></code></pre></div>
<pre><code>##             a         b         c
## [1,] 0.370364 0.1111134 0.5185226</code></pre>
<p>En base a la distribución del proceso tras <span class="math inline">\(n=10\)</span> pasos, apreciamos que lo más probable es que el sistema se ecuentre en el estado “c” (prob=0.52), y lo menos probable es que se encuentre en el estado “b” (prob=0.11).</p>
<p>(5). Corroborar los resultados analíticos obtenidos en (4) con simulaciones.</p>
<ul>
<li>RESPUESTA: Para ver el comportamiento de un proceso después de que transcurran <span class="math inline">\(n\)</span> pasos habrá que simularlo durante <span class="math inline">\(n\)</span> instantes de tiempo. Puesto que buscamos una estimación de lo que va a ocurrir en ese momento, simularemos <span class="math inline">\(nsim=100\)</span> veces el proceso hasta el instante <span class="math inline">\(n=10\)</span>, nos quedaremos con el estado en que se encuentra el proceso en ese instante <span class="math inline">\(n\)</span> y evaluaremos las probabilidades obtenidas para los tres estados <span class="math inline">\(\{a,b,c\}\)</span>. Los resultados serán más próximos a la solución analítica, cuanto mayor sea el número de simulaciones (prueba a modificar <span class="math inline">\(nsim\)</span>).</li>
</ul>
<div class="whitebox">
<p>Para simular una CMTD hasta una transición <span class="math inline">\(n\)</span> con la librería <code>markovchain</code>
basta utilizar la función <code>rmarkovchain(n, proceso)</code>, donde proceso ha sido definido previamente con la función <code><a href="https://rdrr.io/r/methods/new.html">new()</a></code>.</p>
</div>
<div class="sourceCode" id="cb197"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">### Simulación del proceso para n=10 instantes </span>
<span class="va">res</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="op">)</span>
<span class="va">nsim</span><span class="op">=</span><span class="fl">100</span>
<span class="va">n</span><span class="op">=</span><span class="fl">10</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">nsim</span><span class="op">)</span><span class="op">{</span>
  <span class="va">res</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/rmarkovchain.html">rmarkovchain</a></span><span class="op">(</span><span class="va">n</span>, <span class="va">proceso</span><span class="op">)</span><span class="op">[</span><span class="va">n</span><span class="op">]</span><span class="op">}</span>
<span class="fu"><a href="https://rdrr.io/r/base/proportions.html">prop.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## res
##    a    b    c 
## 0.31 0.12 0.57</code></pre>
</div>
<div id="ExCMTD" class="section level2" number="2.3">
<h2>
<span class="header-section-number">2.3</span> Aplicaciones<a class="anchor" aria-label="anchor" href="#ExCMTD"><i class="fas fa-link"></i></a>
</h2>
<p>Las aplicaciones de las CMTD son muy numerosas. A continuación presentamos una colección de ejemplos basados en aplicaciones prácticas de estos procesos, con algunos de los cuales trabajaremos a lo largo de la unidad.</p>
<div id="CM01" class="section level3" number="2.3.1">
<h3>
<span class="header-section-number">2.3.1</span> Colas de espera<a class="anchor" aria-label="anchor" href="#CM01"><i class="fas fa-link"></i></a>
</h3>
<p>Supongamos una consulta médica en un centro de salud, en el que los pacientes que llegan se colocan en una única cola de espera, son atendidos consecutivamente y sólo se atiende a un paciente en cada periodo de 5 minutos. Consideramos las variables aleatorias:</p>
<ul>
<li>
<span class="math inline">\(Y_n:\)</span> Número de clientes que acuden a la consulta durante el n-ésimo periodo de servicio, con posibles valores <span class="math inline">\(\{0, 1, 2,...\}\)</span> donde</li>
</ul>
<p><span class="math display">\[Pr(Y_n = k) = a_k, \quad k=0, 1, 2,...; \quad 0 \leq a_k \leq 1; \quad \sum_{k=0}^{\infty} a_k =1\]</span></p>
<ul>
<li>
<span class="math inline">\(X_n:\)</span> Número de pacientes que hay esperando en la cola en el momento que empieza el n-ésimo periodo de servicio, con posibles valores <span class="math inline">\(\{0, 1, 2,...\}\)</span>, que conforman un proceso estocástico discreto con:</li>
</ul>
<span class="math display">\[\begin{equation*}
X_{n+1} = 
\begin{cases}
Y_n &amp; \text{ si } X_n = 0\\
X_n - 1 + Y_n &amp; \text{ si } X_n \neq 0
\end{cases}
\end{equation*}\]</span>
<p>de forma que cada <span class="math inline">\(X_n\)</span> sólo dependerá de lo que haya ocurrido en el periodo inmediatamente anterior, luego <span class="math inline">\(\{X_n, n \in \mathbb{N}\}\)</span> es una <span class="math inline">\(CMTD\)</span>, con probabilidades de transición dadas por:</p>
<span class="math display">\[\begin{eqnarray*}
p_{0j} &amp;=&amp; Pr[X_{n+1} = j | X_{n} = 0] = Pr[Y_n = j] = a_j \\
p_{ij} &amp;=&amp;Pr[X_{n+1} = j | X_{n} = i] = Pr[i - 1 + Y_n = j] = a_{j-i+1}; \quad i\neq 0; \ j \geq i-1 \\
p_{ij} &amp;=&amp; 0; \quad j+1&lt;i\neq0.
\end{eqnarray*}\]</span>
<p>La matriz de transición viene dada por:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
a_0 &amp; a_1 &amp; a_2 &amp; a_3 &amp;...&amp; a_j &amp; ...\\
a_0 &amp; a_1 &amp; a_2 &amp; a_3 &amp;...&amp; a_j &amp; ...\\
0 &amp; a_0 &amp; a_1 &amp; a_2 &amp;...&amp; a_{j-1} &amp; ...\\
0 &amp; 0 &amp; a_0 &amp; a_1 &amp;...&amp; a_{j-2} &amp; ...\\
... &amp; ... &amp; ... &amp; ... &amp;...&amp; ... &amp; ...
\end{pmatrix}\]</span></p>
</div>
<div id="fiabilidad" class="section level3" number="2.3.2">
<h3>
<span class="header-section-number">2.3.2</span> Fiabilidad de máquinas<a class="anchor" aria-label="anchor" href="#fiabilidad"><i class="fas fa-link"></i></a>
</h3>
<p>La empresa <em>Depend-On-Us</em> fabrica una máquina que está encendida o apagada (“On”/“Off”). Si está “On” al principio de un día, entonces está “On” al principio del día siguiente con una probabilidad de 0.98 (independientemente del historial de la máquina), o falla con una probabilidad de 0.02. Una vez que la máquina falla, la empresa envía a una persona para que la repare. Si la máquina está averiada al principio de un día, está “Off” al principio del día siguiente con una probabilidad de 0.03 (independientemente del historial de la máquina), o la reparación se completa y la máquina está “On” con probabilidad de 0.97. Una máquina reparada está como nueva.</p>
<p>Podemos modelar este sistema mediante una <span class="math inline">\(CMTD\)</span> si consideramos la variable aleatoria <span class="math inline">\(X_n\)</span> que refleja el estado de la máquina en el día <span class="math inline">\(n\)</span> definida como:</p>
<span class="math display">\[\begin{equation*}
X_{n} = 
\begin{cases}
0 &amp; \text{ Off}\\
1 &amp; \text{ On}
\end{cases}
\end{equation*}\]</span>
<p>de forma que la matriz de transicción viene dada por:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.03 &amp; 0.97\\
0.02 &amp; 0.98
\end{pmatrix}\]</span></p>
<p>Supongamos ahora que la empresa mantiene dos máquinas de este tipo que son idénticas, se comportan de forma independiente y cada una tiene su propio reparador.</p>
<p>Sea <span class="math inline">\(Y_n\)</span> el número de máquinas en estado “On” al principio del día <span class="math inline">\(n\)</span>, que constituye una CMTD cuyo espacio de estados es <span class="math inline">\(\{0, 1, 2\}\)</span>, puesto que la situación de las máquinas un día cualquiera sólo depende de cómo estaban el día anterior (cumplen la Ecuación <a href="cmtd.html#eq:cmtd">(2.1)</a>.</p>
<p>Calculemos la probabilidad de transición para un caso concreto: <span class="math inline">\(Y_n = i = 1\)</span> e <span class="math inline">\(Y_{n+1} = j = 0\)</span>, que identifica una situación en la que una máquina está en funcionamiento y otra en paro el día <span class="math inline">\(n\)</span>, pero al día siguiente ambas están paradas. Así, la máquina que está “Off” el día <span class="math inline">\(n\)</span> debe permanecer “Off” al día siguiente, y la máquina que está “On” debe cambiar a “Off” el día siguiente. Como las máquinas son independientes, la probabilidad de cambio de estado es:</p>
<p><span class="math display">\[p_{10}=Pr[Y_{n+1} = 0 | Y_n = 1] = 0.03 * 0.02 = 0.0006\]</span> Procediendo de la misma forma obtenemos la matriz completa de transición de un paso del proceso como:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.0009 &amp; 0.0582 &amp; 0.9409\\
0.0006 &amp; 0.0488 &amp; 0.9506\\
0.0004 &amp; 0.0392 &amp; 0.9604
\end{pmatrix}\]</span></p>
<p>Representamos a continuación este sistema en forma de grafo en la Figura <a href="cmtd.html#fig:03-009">2.2</a>. Para ello acudimos a la librería <code>markovchain</code>.</p>
<div class="sourceCode" id="cb199"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"0"</span>, <span class="st">"1"</span>, <span class="st">"2"</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.0009</span>, <span class="fl">0.0582</span>, <span class="fl">0.9409</span>, 
                        <span class="fl">0.0006</span>, <span class="fl">0.0488</span>, <span class="fl">0.9506</span>, 
                        <span class="fl">0.0004</span>, <span class="fl">0.0392</span>, <span class="fl">0.9604</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">3</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">fiabilidad</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, 
                 name <span class="op">=</span> <span class="st">"Fiabilidad"</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">fiabilidad</span></code></pre></div>
<pre><code>## Fiabilidad 
##  A  3 - dimensional discrete Markov Chain defined by the following states: 
##  0, 1, 2 
##  The transition matrix  (by rows)  is defined as follows: 
##       0      1      2
## 0 9e-04 0.0582 0.9409
## 1 6e-04 0.0488 0.9506
## 2 4e-04 0.0392 0.9604</code></pre>
<div class="sourceCode" id="cb201"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Diagrama</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">fiabilidad</span>, vertex.color<span class="op">=</span><span class="st">"steelblue"</span>, 
     vertex.label.font <span class="op">=</span> <span class="fl">2</span>, 
     edge.label.size <span class="op">=</span> <span class="fl">0.1</span>,
     edge.arrow.size<span class="op">=</span><span class="fl">0.5</span>, 
     vertex.shape <span class="op">=</span> <span class="st">"rectangle"</span>, 
     vertex.size <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:03-009"></span>
<img src="02-CMTD_files/figure-html/03-009-1.png" alt="Diagrama del sistema de fiabilidad" width="95%"><p class="caption">
Figura 2.2: Diagrama del sistema de fiabilidad
</p>
</div>
</div>
<div id="meteo" class="section level3" number="2.3.3">
<h3>
<span class="header-section-number">2.3.3</span> Meteorología<a class="anchor" aria-label="anchor" href="#meteo"><i class="fas fa-link"></i></a>
</h3>
<p>El tiempo en la ciudad de Heavenly se clasifica como soleado, nublado o lluvioso. Supongamos que el tiempo de mañana depende sólo del tiempo de hoy de la siguiente manera: si hoy hace sol, mañana estará nublado con una probabilidad de 0.3 y lluvioso con probabilidad 0.2; si hoy está nublado, mañana estará soleado con probabilidad 0.5 y lluvioso con probabilidad 0.3; y finalmente, si hoy está lluvioso, mañana estará soleado con probabilidad 0.4 y nublado con probabilidad 0.5.</p>
<p>Consideramos la variable aleatoria <span class="math inline">\(X_n\)</span> que registra las condiciones meteorológicas del día <span class="math inline">\(n\)</span> como:</p>
<span class="math display">\[\begin{equation*}
X_{n} = 
\begin{cases}
1 &amp; \text{ soleado}\\
2 &amp; \text{ nublado}\\
3 &amp; \text{ lluvioso}
\end{cases}
\end{equation*}\]</span>
<p>de forma que el proceso <span class="math inline">\(\{X_n, n \in \mathbb{N}\}\)</span> con espacio de estados <span class="math inline">\(S = \{1, 2, 3\}\)</span> se puede considerar como una <span class="math inline">\(CMTD\)</span>, cuya matriz de transición se puede obtener de forma muy rápida como:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.50 &amp; 0.30 &amp; 0.20\\
0.50 &amp; 0.20 &amp; 0.30\\
0.40 &amp; 0.50 &amp; 0.10
\end{pmatrix}\]</span></p>
<p>Representamos a continuación este sistema en forma de grafo en la Figura <a href="cmtd.html#fig:03-011">2.3</a>.</p>
<div class="sourceCode" id="cb202"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Soleado"</span>, <span class="st">"Nublado"</span>, <span class="st">"LLuvioso"</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.50</span>, <span class="fl">0.30</span>, <span class="fl">0.20</span>, 
                        <span class="fl">0.50</span>, <span class="fl">0.20</span>, <span class="fl">0.30</span>, 
                        <span class="fl">0.40</span>, <span class="fl">0.50</span>, <span class="fl">0.10</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">3</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">meteo</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, 
             name <span class="op">=</span> <span class="st">"Meteorología"</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">meteo</span></code></pre></div>
<pre><code>## Meteorología 
##  A  3 - dimensional discrete Markov Chain defined by the following states: 
##  Soleado, Nublado, LLuvioso 
##  The transition matrix  (by rows)  is defined as follows: 
##          Soleado Nublado LLuvioso
## Soleado      0.5     0.3      0.2
## Nublado      0.5     0.2      0.3
## LLuvioso     0.4     0.5      0.1</code></pre>
<div class="sourceCode" id="cb204"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Diagrama</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">meteo</span>, vertex.color<span class="op">=</span><span class="st">"steelblue"</span>, 
     vertex.label.font <span class="op">=</span> <span class="fl">2</span>, 
     edge.label.size <span class="op">=</span> <span class="fl">0.1</span>,
     edge.arrow.size<span class="op">=</span><span class="fl">0.5</span>, 
     vertex.shape <span class="op">=</span> <span class="st">"rectangle"</span>, 
     vertex.size <span class="op">=</span> <span class="fl">60</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:03-011"></span>
<img src="02-CMTD_files/figure-html/03-011-1.png" alt="Diagrama del sistema de metereología" width="95%"><p class="caption">
Figura 2.3: Diagrama del sistema de metereología
</p>
</div>
</div>
<div id="inventario" class="section level3" number="2.3.4">
<h3>
<span class="header-section-number">2.3.4</span> Problema de inventario<a class="anchor" aria-label="anchor" href="#inventario"><i class="fas fa-link"></i></a>
</h3>
<p>Computers-R-Us almacena una amplia variedad de PCs para la venta al por menor. La tienda abre de lunes a viernes de 8:00 a.m. a 5:00 p.m., y utiliza la siguiente política operativa para controlar el inventario al inicio de semana, en función del número de PCs que quedan en stock el viernes de la semana anterior a las 5:00 p.m:</p>
<ul>
<li><p>Si el stock al finalizar una semana es inferior a dos, se piden suficientes ordenadores para disponer de un stock total de cinco al inicio la semana siguiente.</p></li>
<li><p>Si el stock al final de la semana es de dos o más, no se realiza ningún pedido.</p></li>
</ul>
<p>La demanda de ordenadores durante la semana es una variable aleatoria de Poisson con media 3. Cualquier demanda que no pueda ser satisfecha inmediatamente se pierde.</p>
<p>Se consideran las variables aleatorias:</p>
<ul>
<li>
<span class="math inline">\(X_n:\)</span> número de PCs en stock a las 8:00 a.m del lunes de la semana <span class="math inline">\(n\)</span>.</li>
<li>
<span class="math inline">\(D_n:\)</span> número de PCs demandados durante la semana <span class="math inline">\(n\)</span>.</li>
</ul>
<p>De esta forma el número de Pcs que hay en la tienda al inicio de la semana <span class="math inline">\(n+1\)</span> viene dado por los que habían en stock al inicio de la semana anterior menos los que se han vendido, siempre que dicho balance sea al menos de 2 unidades, y será de 5 en otro caso:</p>
<span class="math display">\[\begin{equation*}
X_{n+1} = 
\begin{cases}
X_n - D_n &amp; \text{ si } X_n - D_n \geq 2\\
5 &amp; \text{ si } X_n - D_n &lt; 2
\end{cases}
\end{equation*}\]</span>
<p>Necesariamente entonces, <span class="math inline">\(X_{n+1} \geq X_n\)</span> dado que <span class="math inline">\(D_n \geq 0\)</span>.</p>
<p>Se trata de una CMTD con espacio de estados <span class="math inline">\(\{2, 3, 4, 5\}\)</span>, puesto que el estado del sistema en la semana <span class="math inline">\(n+1\)</span> sólo depende de su estado en la semana anterior <span class="math inline">\(n\)</span>. Calculemos las probabilidades de transición.</p>
<ul>
<li>Para <span class="math inline">\(j= 2, 3, 4\)</span>
</li>
</ul>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1}  = j | X_n = i] &amp; = Pr[X_n - D_n = j | X_n = i]\\
&amp; = Pr[D_n=X_n-j | X_n = i]\\
&amp; = Pr[D_n = i - j] \\
&amp;=\begin{cases}
Pr[D_n = i - j] \quad \text{ si } i\geq j \\
0 \qquad \qquad \qquad \quad \text{ si } i&lt; j
\end{cases}
\end{array}\]</span></p>
<ul>
<li>Para <span class="math inline">\(j=5\)</span> e <span class="math inline">\(5&gt;i\geq 2\)</span>
</li>
</ul>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1}  = 5 | X_n = i] &amp; = Pr[X_n - D_n \leq 1 | X_n = i]\\
&amp;=Pr[D_n \geq X_n-1|X_n=i] \\
&amp; = Pr(D_n \geq i - 1).
\end{array}\]</span></p>
<ul>
<li>Para <span class="math inline">\(j=5\)</span> e <span class="math inline">\(i=5\)</span>, podría ocurrir que durante la semana anterior no se hubiera vendido nada <span class="math inline">\(D_n=0\)</span> o se hubieran vendido al menos cuatro ordenadores, <span class="math inline">\(D_n \geq 4\)</span> (para dejar un stock inferior a 2),</li>
</ul>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1}  = 5 | X_n = 5] &amp; = Pr[X_n - D_n =5 | X_n = 5]\\
&amp;=Pr[D_n =0] + Pr(D_n \geq 4).
\end{array}\]</span></p>
<p>Usando el hecho de que la variable <span class="math inline">\(D_n \sim Po(3)\)</span> podemos obtener la tabla de probabilidades siguientes:</p>
<div class="inline-table"><table class="table table-sm">
<thead><tr class="header">
<th><span class="math inline">\(k\)</span></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(Pr[D_n = k]\)</span></td>
<td>0.0498</td>
<td>0.1494</td>
<td>0.2240</td>
<td>0.2240</td>
<td>0.1680</td>
</tr>
<tr class="even">
<td><span class="math inline">\(Pr[D_n \geq k]\)</span></td>
<td>1.0000</td>
<td>0.9502</td>
<td>0.8008</td>
<td>0.5768</td>
<td>0.3528</td>
</tr>
</tbody>
</table></div>
<p>Usando los datos de esta tabla calculamos fácilmente la matriz de transición asociada a la <span class="math inline">\(CMTD\)</span> como:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.0498 &amp; 0 &amp; 0 &amp; 0.9502\\
0.1494 &amp; 0.0498 &amp; 0 &amp; 0.8008\\
0.2240 &amp; 0.1494 &amp; 0.0498 &amp; 0.5768\\
0.2240 &amp; 0.2240 &amp; 0.1494 &amp; 0.4026
\end{pmatrix}\]</span></p>
<p>Representamos a continuación este sistema en forma de grafo en la Figura <a href="cmtd.html#fig:03-013">2.4</a>.</p>
<div class="sourceCode" id="cb205"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"2 PCs"</span>, <span class="st">"3 PCs"</span>, <span class="st">"4 PCs"</span>, <span class="st">"5 PCs"</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.0498</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0.9502</span>, 
                        <span class="fl">0.1494</span>, <span class="fl">0.0498</span>, <span class="fl">0</span>, <span class="fl">0.8008</span>,  
                        <span class="fl">0.2240</span>, <span class="fl">0.1494</span>, <span class="fl">0.0498</span>, <span class="fl">0.5768</span>,
                        <span class="fl">0.2240</span>, <span class="fl">0.2240</span>, <span class="fl">0.1494</span>, <span class="fl">0.4026</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">4</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">inventario</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, 
                 name <span class="op">=</span> <span class="st">"inventario"</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">inventario</span></code></pre></div>
<pre><code>## inventario 
##  A  4 - dimensional discrete Markov Chain defined by the following states: 
##  2 PCs, 3 PCs, 4 PCs, 5 PCs 
##  The transition matrix  (by rows)  is defined as follows: 
##        2 PCs  3 PCs  4 PCs  5 PCs
## 2 PCs 0.0498 0.0000 0.0000 0.9502
## 3 PCs 0.1494 0.0498 0.0000 0.8008
## 4 PCs 0.2240 0.1494 0.0498 0.5768
## 5 PCs 0.2240 0.2240 0.1494 0.4026</code></pre>
<div class="sourceCode" id="cb207"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Diagrama</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">inventario</span>, vertex.color<span class="op">=</span><span class="st">"steelblue"</span>, 
     vertex.label.font <span class="op">=</span> <span class="fl">2</span>, 
     edge.label.size <span class="op">=</span> <span class="fl">0.1</span>,
     edge.arrow.size<span class="op">=</span><span class="fl">0.5</span>, 
     vertex.shape <span class="op">=</span> <span class="st">"rectangle"</span>, 
     vertex.size <span class="op">=</span> <span class="fl">40</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:03-013"></span>
<img src="02-CMTD_files/figure-html/03-013-1.png" alt="Diagrama del sistema de inventario" width="95%"><p class="caption">
Figura 2.4: Diagrama del sistema de inventario
</p>
</div>
</div>
<div id="planificacion" class="section level3" number="2.3.5">
<h3>
<span class="header-section-number">2.3.5</span> Planificación de mano de obra<a class="anchor" aria-label="anchor" href="#planificacion"><i class="fas fa-link"></i></a>
</h3>
<p>Paper Pushers, Inc. es una empresa de seguros que emplea a 100 trabajadores organizados en cuatro grados, etiquetados como <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, <span class="math inline">\(3\)</span> y <span class="math inline">\(4\)</span>. Por razones de simplicidad, supondremos que los trabajadores pueden ser promovidos de un grado a otro, o dejar la empresa, sólo al principio de la semana. Un trabajador en el grado 1 al principio de la semana asciende al grado 2 con probabilidad 0.03, deja la empresa con una probabilidad de 0.02, o continúa en el mismo grado al principio de la semana siguiente. Un trabajador que se encuentra en el grado 2 al principio de la semana asciende al grado 3 con probabilidad 0.01, abandona la empresa con probabilidad 0.008 o continúa en el mismo grado al principio de la semana siguiente. Un trabajador de grado 3 al principio de la semana asciende al grado 4 con una probabilidad de 0.005, abandona la empresa con una probabilidad de 0.02, o continúa en el mismo grado al principio de la semana siguiente. Un trabajador que se encuentra en el grado 4 al principio de la semana deja la empresa con una probabilidad de 0.01 o continúa en el mismo grado al principio de la semana siguiente. Si un trabajador abandona la empresa, es sustituido instantáneamente por otro de grado 1. El movimiento de los trabajadores dentro de la empresa puede modelizarse utilizando una <span class="math inline">\(CMTD\)</span>.</p>
<p>Supondremos que todos los ascensos de los trabajadores se deciden de manera independiente. Esto simplifica considerablemente nuestro modelo. En lugar de hacer un seguimiento de los 100 trabajadores, tenemos en cuenta a un único trabajador, digamos el trabajador <span class="math inline">\(k\)</span>, donde <span class="math inline">\(k = 1, 2,...,100\)</span>. Pensamos en <span class="math inline">\(k\)</span> como un ID de trabajador, y cuando este trabajador deja la empresa, se le asigna al nuevo sustituto. Sea <span class="math inline">\(X_n^k\)</span> el grado en el que se encuentra el trabajador <span class="math inline">\(k\)</span> al principio de la n-ésima semana. Ahora, si suponemos que los ascensos de los trabajadores se determinan independientemente del historial del trabajador (es decir, que el tiempo transcurrido en un grado determinado no afecta a las posibilidades de promoción), vemos que para <span class="math inline">\(k = 1, 2,...,100\)</span> el conjunto <span class="math inline">\(\{X_n^k, n \in \mathbb{N}\}\)</span> es una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S =\{1, 2, 3, 4\}\)</span>.</p>
<p>Para obtener la matriz de transiciones procedemos con un ejemplo. Supongamos que <span class="math inline">\(X_n^k = 3\)</span> entonces:</p>
<ul>
<li>Si es promocionado (<span class="math inline">\(X_{n+1}^k = 4\)</span>), tenemos que <span class="math inline">\(Pr[X_{n+1}^k = 4 | X_n^k = 3] = 0.005.\)</span>
</li>
<li>Si deja la empresa, es reemplazado por un nuevo empleado de grado 1 (<span class="math inline">\(X_{n+1}^k = 1\)</span>) de forma que <span class="math inline">\(Pr[X_{n+1}^k = 1 | X_n^k = 3] = 0.02.\)</span>
</li>
<li>Si se mantiene en el mismo puesto, tenemos que <span class="math inline">\(Pr[X_{n+1}^k = 3 | X_n^k = 3] = 0.975.\)</span>
</li>
</ul>
<p>Procediendo de forma similar en el resto de situaciones tenemos la matriz de transición para cualquiera de los trabajadores como:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.970 &amp; 0.030 &amp; 0 &amp; 0\\
0.008 &amp; 0.982 &amp; 0.010 &amp; 0\\
0.020 &amp; 0 &amp; 0.975 &amp; 0.005\\
0.010 &amp; 0 &amp; 0 &amp; 0.990
\end{pmatrix}\]</span></p>
<p>Representamos a continuación este sistema en forma de grafo en la Figura <a href="cmtd.html#fig:03-017">2.5</a>.</p>
<div class="sourceCode" id="cb208"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"1"</span>, <span class="st">"2"</span>, <span class="st">"3"</span>, <span class="st">"4"</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.9700</span>, <span class="fl">0.0300</span>, <span class="fl">0</span>, <span class="fl">0</span>, 
                        <span class="fl">0.0080</span>, <span class="fl">0.9820</span>, <span class="fl">0.0100</span>, <span class="fl">0</span>,   
                        <span class="fl">0.0200</span>, <span class="fl">0</span>, <span class="fl">0.9750</span>, <span class="fl">0.0050</span>,
                        <span class="fl">0.0100</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0.9900</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">4</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">planificacion</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, 
                 name <span class="op">=</span> <span class="st">"planificacion"</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">planificacion</span></code></pre></div>
<pre><code>## planificacion 
##  A  4 - dimensional discrete Markov Chain defined by the following states: 
##  1, 2, 3, 4 
##  The transition matrix  (by rows)  is defined as follows: 
##       1     2     3     4
## 1 0.970 0.030 0.000 0.000
## 2 0.008 0.982 0.010 0.000
## 3 0.020 0.000 0.975 0.005
## 4 0.010 0.000 0.000 0.990</code></pre>
<div class="sourceCode" id="cb210"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Diagrama</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">planificacion</span>, vertex.color<span class="op">=</span><span class="st">"steelblue"</span>, 
     vertex.label.font <span class="op">=</span> <span class="fl">2</span>, 
     vertex.label.color <span class="op">=</span> <span class="st">"white"</span>,
     edge.label.size <span class="op">=</span> <span class="fl">0.2</span>,
     edge.arrow.size<span class="op">=</span><span class="fl">0.5</span>, 
     vertex.shape <span class="op">=</span> <span class="st">"rectangle"</span>,
     vertex.size <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:03-017"></span>
<img src="02-CMTD_files/figure-html/03-017-1.png" alt="Diagrama del sistema de planificación" width="95%"><p class="caption">
Figura 2.5: Diagrama del sistema de planificación
</p>
</div>
</div>
<div id="mercadovalores" class="section level3" number="2.3.6">
<h3>
<span class="header-section-number">2.3.6</span> Mercado de valores<a class="anchor" aria-label="anchor" href="#mercadovalores"><i class="fas fa-link"></i></a>
</h3>
<p>Las acciones ordinarias de la empresa Gadgets-R-Us se cotizan en el mercado de valores. El director financiero de Gadgets-R-Us compra y vende las acciones de su propia empresa para que el precio nunca baje de 2 dólares y nunca supere los 10 dólares (cuando esto ocurre, vende). Para simplificar, suponemos que <span class="math inline">\(X_n\)</span>, es el precio de cada acción al final del día <span class="math inline">\(n\)</span>, y sólo toma valores enteros; es decir, el espacio de estados del proceso <span class="math inline">\(\{X_n, n \in \mathbb{N}\}\)</span> es <span class="math inline">\(S = 2, 3,...,10\)</span>. Si denominamos <span class="math inline">\(I_{n+1}\)</span> al movimiento potencial del precio de las acciones en el día <span class="math inline">\(n+1\)</span> en ausencia de cualquier intervención del director financiero, entonces tenemos que:</p>
<span class="math display">\[\begin{equation*}
X_{n+1} =  
\begin{cases}
2 &amp; \text{ si } X_n + I_{n+1} \leq 2\\
X_n + I_{n+1} &amp; \text{ si } 2 &lt; X_n + I_{n+1} &lt; 10\\
10 &amp; \text{ si }  X_n + I_{n+1} \geq 10
\end{cases}
\end{equation*}\]</span>
<p>Un análisis continuado de los datos del pasado sugiere que los movimientos potenciales <span class="math inline">\(\{I_n, n \geq 1\}\)</span> son una secuencia de variables iid con función de masa de probabilidad dada por:</p>
<p><span class="math display">\[Pr(I_n = k) = 0.2, \quad k = -2, -1, 0, 1, 2.\]</span></p>
<p>Esto implica que <span class="math inline">\(\{X_n, n \in \mathbb{N}\}\)</span> es una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S = \{2, 3,...,10\}\)</span>, donde las probabilidades de transición se pueden obtener de forma sencilla. A modo de ejemplo presentamos los tres casos siguientes:</p>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1} = 2 | X_n = 3] &amp; = Pr[X_n + I_{n+1} \leq 2 | X_n = 3]\\
&amp; = Pr[I_{n+1} \leq -1]= 0.4
\end{array}\]</span></p>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1} = 6 | X_n = 5] &amp; = Pr[X_n + I_{n+1} = 6 | X_n = 5]\\
&amp; = Pr[I_{n+1} = 1]  = 0.2
\end{array}\]</span></p>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1} = 10 | X_n = 10] &amp; = Pr[X_n + I_{n+1} \geq 10 | X_n = 10]\\
&amp; = Pr[I_{n+1} \geq 0] = 0.6
\end{array}\]</span></p>
<p>de forma que la matriz de transición del sistema viene dada por:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.6 &amp; 0.2 &amp; 0.2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0.4 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.2\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.2 &amp; 0.2 &amp; 0.2 &amp; 0.4\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.2 &amp; 0.2 &amp; 0.6
\end{pmatrix}\]</span></p>
<p>Representamos a continuación este sistema en forma de grafo en la Figura <a href="cmtd.html#fig:03-019">2.6</a>.</p>
<div class="sourceCode" id="cb211"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"2"</span>, <span class="st">"3"</span>, <span class="st">"4"</span>, <span class="st">"5"</span>, <span class="st">"6"</span>, <span class="st">"7"</span>, <span class="st">"8"</span>, <span class="st">"9"</span>, <span class="st">"10"</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.6</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span>,
                        <span class="fl">0.4</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span>,
                        <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span>,
                        <span class="fl">0</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span>,
                        <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0</span> , <span class="fl">0</span>,
                        <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0</span>,
                        <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span>,
                        <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.4</span>,
                        <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0</span> , <span class="fl">0.2</span> , <span class="fl">0.2</span> , <span class="fl">0.6</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">9</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">mercado.valores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, 
                 name <span class="op">=</span> <span class="st">"Mercado de valores"</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">mercado.valores</span></code></pre></div>
<pre><code>## Mercado de valores 
##  A  9 - dimensional discrete Markov Chain defined by the following states: 
##  2, 3, 4, 5, 6, 7, 8, 9, 10 
##  The transition matrix  (by rows)  is defined as follows: 
##      2   3   4   5   6   7   8   9  10
## 2  0.6 0.2 0.2 0.0 0.0 0.0 0.0 0.0 0.0
## 3  0.4 0.2 0.2 0.2 0.0 0.0 0.0 0.0 0.0
## 4  0.2 0.2 0.2 0.2 0.2 0.0 0.0 0.0 0.0
## 5  0.0 0.2 0.2 0.2 0.2 0.2 0.0 0.0 0.0
## 6  0.0 0.0 0.2 0.2 0.2 0.2 0.2 0.0 0.0
## 7  0.0 0.0 0.0 0.2 0.2 0.2 0.2 0.2 0.0
## 8  0.0 0.0 0.0 0.0 0.2 0.2 0.2 0.2 0.2
## 9  0.0 0.0 0.0 0.0 0.0 0.2 0.2 0.2 0.4
## 10 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.2 0.6</code></pre>
<div class="sourceCode" id="cb213"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Diagrama</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">mercado.valores</span>, vertex.color<span class="op">=</span><span class="st">"steelblue"</span>, 
     vertex.label.font <span class="op">=</span> <span class="fl">2</span>, 
     vertex.label.color <span class="op">=</span> <span class="st">"white"</span>,
     edge.label.size <span class="op">=</span> <span class="fl">0.2</span>,
     edge.arrow.size<span class="op">=</span><span class="fl">0.5</span>, 
     vertex.shape <span class="op">=</span> <span class="st">"rectangle"</span>,
     vertex.size <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:03-019"></span>
<img src="02-CMTD_files/figure-html/03-019-1.png" alt="Diagrama del sistema del Mercado de valores" width="95%"><p class="caption">
Figura 2.6: Diagrama del sistema del Mercado de valores
</p>
</div>
</div>
<div id="telecomunicaciones" class="section level3" number="2.3.7">
<h3>
<span class="header-section-number">2.3.7</span> Telecomunicaciones<a class="anchor" aria-label="anchor" href="#telecomunicaciones"><i class="fas fa-link"></i></a>
</h3>
<p>La empresa Tel-All Switch Corporation fabrica equipos de conmutación para redes de comunicación. Las redes de comunicación mueven los datos de un conmutador a otro a la velocidad del rayo en forma de paquetes, es decir, mediante cadenas de ceros y unos (llamadas bits). Los conmutadores Tel-All manejan paquetes de datos de longitud constante, es decir, el mismo número de bits en cada paquete. A nivel conceptual podemos pensar en el conmutador como un dispositivo de almacenamiento donde los paquetes llegan desde la red de usuarios según un proceso aleatorio, se almacenan en un buffer con capacidad para almacenar <span class="math inline">\(K\)</span> paquetes y se eliminan del buffer uno a uno según un protocolo preestablecido. Uno de los protocolos utilizados considera el tiempo dividido en intervalos de duración fija llamados “ranuras” (por ejemplo, un microsegundo), y consiste en que: si hay algún paquete en el buffer al principio de un intervalo o ranura, se elimina uno instantáneamente; si no hay ningún paquete al principio de un intervalo, no se elimina ningún paquete durante el intervalo, aunque lleguen más paquetes durante el mismo; por último, si un paquete llega durante una ranura y no hay espacio para él, se descarta. Este proceso se puede modelar como una <span class="math inline">\(CMTD\)</span>.</p>
<p>Sean:</p>
<ul>
<li>
<span class="math inline">\(A_n\)</span> el número de paquetes que llegan al conmutador durante la enésima ranura (algunos pueden ser descartados)</li>
<li>
<span class="math inline">\(X_n\)</span> el número de paquetes en el buffer al final de la enésima ranura.</li>
</ul>
<p>Ahora, si <span class="math inline">\(X_n = 0\)</span>, entonces no hay paquetes disponibles para la transmisión al principio de la ranura <span class="math inline">\(n+1\)</span>. Por lo tanto, todos los paquetes que llegan durante esa ranura, es decir, <span class="math inline">\(A_{n+1}\)</span>, están en el buffer al final de esa ranura mientras tenga capacidad, esto es, <span class="math inline">\(A_{n+1} \leq K\)</span>; si <span class="math inline">\(A_{n+1}&gt;K\)</span>, entonces la memoria intermedia está llena al final de la ranura <span class="math inline">\(n+1\)</span>, <span class="math inline">\(X_{n+1}=K\)</span>. Por lo tanto, en general <span class="math inline">\(X_{n+1} = min(A_{n+1}, K)\)</span>, cuando <span class="math inline">\(X_n=0\)</span>.</p>
<p>Por otro lado, si hay algún paquete al final del instante <span class="math inline">\(n\)</span>, <span class="math inline">\(X_n &gt; 0\)</span>, pasan al conmutador en la siguiente ranura <span class="math inline">\(n+1\)</span>, se elimina un paquete al principio de la misma y se añaden los paquetes que lleguen durante esa ranura, <span class="math inline">\(A_{n+1}\)</span>, con sujeción a las limitaciones de capacidad.</p>
<p>Combinando estos casos, obtenemos:</p>
<span class="math display">\[\begin{equation*}
X_{n+1} =  
\begin{cases}
min(A_{n+1}, K) &amp; \text{ si } X_n = 0\\
min(X_n + A_{n+1} - 1, K) &amp; \text{ si } 0 &lt; X_n \leq K
\end{cases}
\end{equation*}\]</span>
<p>Asumimos que <span class="math inline">\(\{A_n, n \geq 1\}\)</span> es una secuencia de variables iid con función de masa de probabilidad dada por:</p>
<p><span class="math display">\[Pr(A_n = k) = a_k, \quad k \geq 0.\]</span></p>
<p>Bajo esta condición <span class="math inline">\(\{X_n, n \in \mathbb{N}\}\)</span> es una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S = \{0, 1, 2,..., K\}\)</span>, cuyas probabilidades de transición vienen dadas a continuación para todos los estados <span class="math inline">\(0 \leq j \leq K\)</span>:</p>
<p>Para <span class="math inline">\(X_n=0 \ (i=0)\)</span>:</p>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1} = j | X_n = 0] &amp; = Pr[min(A_{n+1}, K) = j]\\
&amp; = \begin{cases}
Pr[A_{n+1} \geq K], \quad \text{ si } j=K\\
Pr[A_{n+1}=j], \quad \text{ si } j&lt;K
\end{cases} \\
&amp;= \begin{cases}
\sum_{r=K}^{\infty} a_r \quad \text{ si } j=K\\
a_j, \qquad \quad \text{ si } j&lt;K
\end{cases}
\end{array}\]</span></p>
<p>Para <span class="math inline">\(0&lt; X_n=i \leq K\)</span>:</p>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1} = j | X_n = i] &amp; = Pr[min(A_{n+1}+X_n-1, K) = j]\\
&amp; = \begin{cases}
Pr[A_{n+1} +i-1 \geq K], \quad \text{ si } j=K\\
Pr[A_{n+1}+i-1=j], \quad \text{ si } j&lt;K
\end{cases} \\
&amp; = \begin{cases}
\sum_{K-i+1}^{\infty} a_r, \qquad \text{ si } j=K\\
a_{j-i+1}, \qquad \qquad \text{ si } i-1 \leq j&lt;K\\
0, \qquad \qquad \qquad  \text{ si } j&lt;i-1
\end{cases}
\end{array}\]</span></p>
<p>Si consideramos:</p>
<p><span class="math display">\[b_j = \sum_{r=j}^{\infty} a_r=1-\sum_{r=0}^{j-1} a_r, \quad j=1,2,...,K\]</span></p>
<p>la matriz de transiciones de un paso (de dimensión <span class="math inline">\((K+1) \times (K+1)\)</span> la podemos escribir como:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
a_0 &amp; a_1 &amp; ... &amp; a_{K-1} &amp; b_K\\
a_0 &amp; a_1 &amp; ... &amp; a_{K-1} &amp; b_K\\
0 &amp; a_0 &amp; ... &amp; a_{K-2} &amp; b_{K-1}\\
...&amp;...&amp;...&amp;...&amp;...\\
0 &amp; 0 &amp; ... &amp; a_0 &amp; b_1
\end{pmatrix}\]</span></p>
</div>
<div id="inventario2" class="section level3" number="2.3.8">
<h3>
<span class="header-section-number">2.3.8</span> Inventario con desabastecimiento<a class="anchor" aria-label="anchor" href="#inventario2"><i class="fas fa-link"></i></a>
</h3>
<p>El gestor de un almacén desea analizar el comportamiento de uno de sus productos en función de la demanda del producto y de la capacidad del almacén.</p>
<p>Consideramos como <span class="math inline">\(Y_n\)</span> a la variable aleatoria que describe la demanda del producto durante el n-ésimo periodo de tiempo, de forma que:</p>
<p><span class="math display">\[Pr[Y_n = k] = a_k, \quad k=0, 1, 2,...  \text{ con } \sum_{k=0}^{\infty} a_k =1\]</span></p>
<p>Denotamos por <span class="math inline">\(X_n\)</span> a la variable aleatoria que registra la cantidad de producto almacenado al finalizar el n-ésimo periodo de tiempo, <span class="math inline">\(A\)</span> el nivel mínimo de almacenaje del producto, y <span class="math inline">\(B\)</span> el nivel máximo. La política de reposición es la siguiente:</p>
<ul>
<li>Si al finalizar un periodo el almacén tiene una cantidad de producto <span class="math inline">\(X_n\)</span> menor o igual que <span class="math inline">\(A\)</span>, entonces se reabastece hasta <span class="math inline">\(B\)</span>.</li>
<li>Si al finalizar un periodo el almacén tiene una cantidad de producto mayor que <span class="math inline">\(A\)</span> y menor o igual a <span class="math inline">\(B\)</span>, entonces no se reabastece y espera hasta el instante de tiempo siguiente.</li>
</ul>
<p>En esta situación el proceso <span class="math inline">\(\{X_n, n \in \mathbb{N}\}\)</span> es un proceso estocástico de tiempo discreto</p>
<p><span class="math display">\[\begin{array}{ll}
\text{ si } X_n \leq A &amp; \rightarrow X_{n+1} = B - Y_{n+1} \\
\text{ si } A &lt; X_n \leq B &amp; \rightarrow X_{n+1} = X_n - Y_{n+1} 
\end{array}\]</span></p>
<p>con espacio de estados <span class="math inline">\(S = \{B, B-1,..., 1, 0, -1, -2,...\}\)</span>, donde los valores negativos indican que la demanda supera a la cantidad almacenada y será servida en instantes posteriores (demanda insatisfecha).</p>
<p>Las probabilidades de transición vienen dadas por:</p>
<ul>
<li>si <span class="math inline">\(i \leq A\)</span>
</li>
</ul>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1} = j | X_{n} =i]&amp;= Pr[B - Y_{n+1} = j] \\
&amp;=Pr[Y_{n+1} = B-j]   \\
&amp; = \begin{cases} 
a_{B-j}, \quad \text{si } B \geq j\\
0,  \qquad \text{ si } B &lt; j
\end{cases}
\end{array}\]</span></p>
<ul>
<li>si <span class="math inline">\(A &lt; i \leq B\)</span>
</li>
</ul>
<p><span class="math display">\[\begin{array}{ll}
Pr[X_{n+1} = j | X_{n}=i] &amp; = Pr[i - Y_{n+1} = j] \\
&amp;=Pr[Y_{n+1} = i-j]   \\
&amp; =  \begin{cases}
a_{i-j}, \quad \text{ si } i \geq j\\
 0, \qquad \text{ si } i &lt; j
 \end{cases}
\end{array}\]</span></p>
<p>A modo de ejemplo consideramos <span class="math inline">\(A = 0\)</span>, <span class="math inline">\(B = 2\)</span>, con probabilidades para <span class="math inline">\(Y_n\)</span> dadas por:</p>
<p><span class="math display">\[Pr[Y_n = 0] = 0.5; \quad Pr[Y_n = 1] = 0.4; \quad Pr[Y_n = 2] = 0.1,\]</span></p>
<p>entonces la matriz de transición, para el espacio de estados <span class="math inline">\(S = \{-1, 0, 1, 2\}\)</span>, viene dada por:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0 &amp; 0.1 &amp; 0.4 &amp; 0.5\\
0 &amp; 0.1 &amp; 0.4 &amp; 0.5\\
0.1 &amp; 0.4 &amp; 0.5 &amp; 0\\
0 &amp; 0.1 &amp; 0.4 &amp; 0.5
\end{pmatrix}\]</span></p>
<p>Representamos a continuación este sistema en forma de grafo en la Figura <a href="cmtd.html#fig:03-019-3">2.7</a>.</p>
<div class="sourceCode" id="cb214"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"-1"</span>, <span class="st">"0"</span>, <span class="st">"1"</span>, <span class="st">"2"</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span> , <span class="fl">0.1</span> , <span class="fl">0.4</span> , <span class="fl">0.5</span>,
                        <span class="fl">0</span> , <span class="fl">0.1</span> , <span class="fl">0.4</span> , <span class="fl">0.5</span>,
                        <span class="fl">0.1</span> , <span class="fl">0.4</span> , <span class="fl">0.5</span> , <span class="fl">0</span>,
                        <span class="fl">0</span> , <span class="fl">0.1</span> , <span class="fl">0.4</span> , <span class="fl">0.5</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">4</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">inventario2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, 
                 name <span class="op">=</span> <span class="st">"Inventario 2"</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">inventario2</span></code></pre></div>
<pre><code>## Inventario 2 
##  A  4 - dimensional discrete Markov Chain defined by the following states: 
##  -1, 0, 1, 2 
##  The transition matrix  (by rows)  is defined as follows: 
##     -1   0   1   2
## -1 0.0 0.1 0.4 0.5
## 0  0.0 0.1 0.4 0.5
## 1  0.1 0.4 0.5 0.0
## 2  0.0 0.1 0.4 0.5</code></pre>
<div class="sourceCode" id="cb216"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Diagrama</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">inventario2</span>, vertex.color<span class="op">=</span><span class="st">"steelblue"</span>, 
     vertex.label.font <span class="op">=</span> <span class="fl">2</span>, 
     vertex.label.color <span class="op">=</span> <span class="st">"white"</span>,
     edge.label.size <span class="op">=</span> <span class="fl">0.2</span>,
     edge.arrow.size<span class="op">=</span><span class="fl">0.5</span>, 
     vertex.shape <span class="op">=</span> <span class="st">"rectangle"</span>,
     vertex.size <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:03-019-3"></span>
<img src="02-CMTD_files/figure-html/03-019-3-1.png" alt="Diagrama del sistema del problema de inventario." width="95%"><p class="caption">
Figura 2.7: Diagrama del sistema del problema de inventario.
</p>
</div>
</div>
</div>
<div id="CaracCMTD" class="section level2" number="2.4">
<h2>
<span class="header-section-number">2.4</span> Caracterización de una CMTD<a class="anchor" aria-label="anchor" href="#CaracCMTD"><i class="fas fa-link"></i></a>
</h2>
<p>En esta sección estudiamos las principales características de una <span class="math inline">\(CMTD\)</span> a través de la comunicación entre los diferentes estados de proceso, el número de visitas y los tiempos de ocupación de cada estado, los tiempos a la primera visita, partiendo de un estado, e introducimos la utilización de costes para la evaluación de los sistemas.</p>
<p>En todas las definiciones que presentamos a continuación asumimos que tenemos una <span class="math inline">\(CMTD\)</span> <span class="math inline">\(\{X_n, n \in \mathbb{N}\}\)</span> con espacio de estados <span class="math inline">\(S\)</span> y matriz de transición de un paso <span class="math inline">\(P\)</span>.</p>
<div id="comunicación-entre-estados" class="section level3" number="2.4.1">
<h3>
<span class="header-section-number">2.4.1</span> Comunicación entre estados<a class="anchor" aria-label="anchor" href="#comunicaci%C3%B3n-entre-estados"><i class="fas fa-link"></i></a>
</h3>
<p>Comenzamos caracterizando los estados de una cadena en función de sus probabilidades de transición.</p>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-7" class="definition"><strong>Definición 2.5  </strong></span>Dados dos estados <span class="math inline">\(i, j\)</span> de <span class="math inline">\(S\)</span>, se dice que el estado <span class="math inline">\(j\)</span> es <strong>accesible</strong> desde el estado <span class="math inline">\(i\)</span> si existe una transición <span class="math inline">\(n\)</span> tal que <span class="math inline">\(p_{ij}(n) &gt; 0\)</span>.</p>
<p>Que el estado <span class="math inline">\(j\)</span> sea accesible desde <span class="math inline">\(i\)</span> se denota habitualmente como <span class="math inline">\(i \rightarrow j\)</span>.</p>
</div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-8" class="definition"><strong>Definición 2.6  </strong></span>Dados dos estados <span class="math inline">\(i, j\)</span> de <span class="math inline">\(S\)</span>, se dice que son <strong>comunicantes</strong> si <span class="math inline">\(i\)</span> es accesible desde <span class="math inline">\(j\)</span>, y <span class="math inline">\(j\)</span> es accesible desde <span class="math inline">\(i\)</span>, es decir, existen <span class="math inline">\(n_1\)</span> y <span class="math inline">\(n_2\)</span> tal que <span class="math inline">\(p_{ij}(n_1) &gt; 0\)</span> y <span class="math inline">\(p_{ji}(n_2) &gt; 0.\)</span></p>
<p>Que los estados <span class="math inline">\(i, j\)</span> sean comunicantes se denota habitualmente como <span class="math inline">\(i \leftrightarrow j\)</span>.</p>
</div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-9" class="definition"><strong>Definición 2.7  </strong></span>Un subconjunto de estados <span class="math inline">\(S_j \subset S\)</span> se denomina <strong>clase comunicante</strong> del estado <span class="math inline">\(j\)</span> si todos los estados de ese subconjunto son comunicantes con <span class="math inline">\(j\)</span>.</p>
<p><span class="math display">\[S_j \subset S \text{ es clase comunicante de } j \text{ si } \quad i \leftrightarrow j, \qquad \forall i \in S_j.\]</span></p>
</div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-10" class="definition"><strong>Definición 2.8  </strong></span>Un estado <span class="math inline">\(i \in S\)</span> se denomina <strong>estado sin retorno</strong> cuando no es viable volver a dicho estado tras partir de él, esto es, para <span class="math inline">\(n \geq 1\)</span>, <span class="math inline">\(p_{ii}(n) = 0.\)</span></p>
</div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-11" class="definition"><strong>Definición 2.9  </strong></span>Un conjunto de estados <span class="math inline">\(C \subset S\)</span> se denomina <strong>cerrado</strong> cuando no es posible pasar de un estado de <span class="math inline">\(C\)</span> a otro que no esté en <span class="math inline">\(C\)</span>, esto es,</p>
<p><span class="math display">\[\forall i \in C, \quad \forall j \notin C \quad \Rightarrow \quad p_{ij}(n) = 0, \quad n\geq 1\]</span>
o lo que es lo mismo,</p>
<p><span class="math display">\[ \sum_{j \in C} p_{ij}=1, \quad \forall i \in C.\]</span></p>
<p>Esto implica que cuando accedamos a un conjunto cerrado, será imposible salir de él y sólo será factible moverse dentro de él.</p>
<p>Si el conjunto cerrado está compuesto por un único estado <span class="math inline">\(i\)</span> diremos que ese estado <span class="math inline">\(i\)</span> es <strong>absorbente</strong>. Eso implica que si se llega a dicho estado, el proceso se queda estancado en él y ya no es posible moverse a otro estado.</p>
</div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-12" class="definition"><strong>Definición 2.10  </strong></span>Una <span class="math inline">\(CMTD\)</span> es <strong>irreducible</strong> cuando todos sus estados están comunicados entre sí, esto es, para cualquier <span class="math inline">\(i,j \in S\)</span> existe algún instante de tiempo <span class="math inline">\(n \geq 0\)</span> tal que <span class="math inline">\(Pr(X_n=j|X_0=i)&gt;0\)</span>. Un conjunto de estados en S se dice irreducible cuando no contiene ningún subconjunto cerrado. Si la <span class="math inline">\(CMTD\)</span> no es irreducible, se llama <strong>reducible</strong>.</p>
<p>Todos los estados dentro de un conjunto irreducible son del mismo tipo.</p>
</div>
</div>
<div class="whitebox">
<p>Para caracterizar una CMTD mediante la librería <code>markovchain</code> es útil usar la función <code>summary(object)</code> donde ‘object’ identifica el proceso a estudiar.</p>
</div>
<div class="example">
<p><span id="exm:summary-markovchain" class="example"><strong>Ejemplo 2.2  </strong></span>Queremos caracterizar el proceso presentado en el Ejemplo <a href="cmtd.html#exm:diagramCMTD">2.1</a>. Cargamos los datos y ejecutamos la sintaxis a continuación.</p>
<div class="sourceCode" id="cb217"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Caracterización</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span></code></pre></div>
<pre><code>## Unnamed Markov chain  Markov chain that is composed by: 
## Closed classes: 
## a b c 
## Recurrent classes: 
## {a,b,c}
## Transient classes: 
## NONE 
## The Markov chain is irreducible 
## The absorbing states are: NONE</code></pre>
<p>A la vista del resultado, concluimos que este proceso es cerrado (todo su espacio de estados es cerrado). Todos sus estados son recurrentes y no tiene estados transitorios (estos conceptos los veremos más adelante). No tiene estados absorbentes y la cadena de Markov es irreducible (todos sus estados están comunicados).</p>
</div>
<div class="bluebox">
<p><strong>PRACTICA</strong> Caracterizar los procesos: <a href="cmtd.html#fiabilidad">Fiabilidad de máquinas</a>,<a href="cmtd.html#meteo">Metereología</a>, <a href="cmtd.html#inventario">Problema de inventario</a>, <a href="cmtd.html#planificacion">Planificación de mano de obra</a>, <a href="cmtd.html#mercadovalores">Mercado de valores</a> e <a href="cmtd.html#inventario2">Inventario con desabastecimiento</a>.</p>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-13" class="example"><strong>Ejemplo 2.3  </strong></span>Veamos ahora cómo utilizar la simulación para responder a diferentes preguntas de interés. En concreto, para el ejemplo en la sección <a href="cmtd.html#inventario2">Inventario con desabastecimiento</a> (recordemos que se trataba de un almacén que se reabastecía cuando el inventario quedaba por debajo o igual a un nivel mínimo de almacenaje, <span class="math inline">\(A=0\)</span>, y con una política de reabastecimiento que dependía del nivel de almacenaje máximo <span class="math inline">\(B=2\)</span>), planteamos estas preguntas:</p>
<ol style="list-style-type: decimal">
<li><p>Durante las próximas 20 semanas, ¿en cuántas de ellas será preciso reabastecerse?</p></li>
<li><p>Durante las próximas 20 semanas, ¿cuál es la proporción de semanas en que la demanda no ha sido satisfecha (por rebasar el stock)?</p></li>
</ol>
</div>
<p>Para responder estas preguntas hay que considerar el proceso <span class="math inline">\(\{X_n, n \geq 0\}\)</span> y la variable <span class="math inline">\(Y_n\)</span> que identifica la demanda en la semana <span class="math inline">\(n\)</span>. Planteamos el siguiente algoritmo de simulación.</p>
<div class="silverbox">
<p><strong>Algoritmo para simulación de inventario</strong></p>
<ul>
<li>Paso 1. Fijar el número de transiciones del proceso, <span class="math inline">\(n\)</span>, e inicializar <span class="math inline">\(X_0 = 2\)</span> (máximo almacenaje).</li>
</ul>
<p>Repetir pasos 2 y 3 hasta alcanzar el número de transiciones deseadas.</p>
<ul>
<li><p>Paso 2. Generar <span class="math inline">\(Y_i\)</span> con el método de la transformada inversa.</p></li>
<li><p>Paso 3. Actualizar el valor <span class="math inline">\(X_i\)</span> y reabastecer si fuera necesario.</p></li>
<li><p>Paso 4. Devolver la secuencia <span class="math inline">\(\{X_i, Y_i; i=1,\ldots,n\}\)</span> para estudiar la evolución del sistema y la demanda.</p></li>
</ul>
</div>
<p>Desarrollemos pues, el algoritmo.</p>
<div class="sourceCode" id="cb219"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Inicialización</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12</span><span class="op">)</span>
<span class="va">tiempo</span> <span class="op">&lt;-</span> <span class="fl">21</span> <span class="co"># valor inicial y 20 transiciones</span>
<span class="va">invent</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># vector con los valores de inventario</span>
<span class="va">demanda</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">)</span> <span class="co"># vector con los valores de demanda</span>
<span class="va">A</span> <span class="op">&lt;-</span> <span class="fl">0</span>
<span class="va">B</span> <span class="op">&lt;-</span> <span class="fl">2</span>
<span class="co">##### Configuración metodo transformada inversa ######</span>
<span class="co"># datos uniformes</span>
<span class="va">unif</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="va">tiempo</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>
<span class="co"># Valores posibles para la demanda</span>
<span class="va">valores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>
<span class="co"># Probabilidades para la demanda</span>
<span class="va">prob</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span><span class="op">)</span>
<span class="va">probacum</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cumsum.html">cumsum</a></span><span class="op">(</span><span class="va">prob</span><span class="op">)</span>  <span class="co"># probabilidades acumuladas</span>
<span class="co"># valor inicial del proceso</span>
<span class="va">invent</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span>
<span class="va">demanda</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>
<span class="va">i</span><span class="op">&lt;-</span><span class="fl">2</span>
<span class="kw">while</span> <span class="op">(</span><span class="va">i</span> <span class="op">&lt;=</span> <span class="va">tiempo</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># simulamos demanda</span>
  <span class="va">demanda</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">valores</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">unif</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;=</span> <span class="va">probacum</span><span class="op">)</span><span class="op">)</span><span class="op">]</span> 
  <span class="co"># Actualizamos inventario</span>
  <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">invent</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;=</span> <span class="va">A</span>, 
         <span class="va">invent</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">B</span> <span class="op">-</span> <span class="va">demanda</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, 
         <span class="va">invent</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">invent</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">-</span><span class="va">demanda</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>
  <span class="co"># iteración siguiente</span>
  <span class="va">i</span><span class="op">&lt;-</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span>
<span class="op">}</span>
<span class="co"># Devolvemos la secuencia de estados </span>
<span class="va">inventario2.sim</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span><span class="va">invent</span>,<span class="va">demanda</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">inventario2.sim</span><span class="op">)</span></code></pre></div>
<pre><code>##   invent demanda
## 1      2       0
## 2      2       0
## 3      1       1
## 4     -1       2
## 5      2       0
## 6      2       0</code></pre>
<p>La estimación del número de semanas que hay que reabastecerse viene dada por el número de simulaciones en las que el nivel de inventario es menor o igual al nivel mínimo de almacenamiento, <span class="math inline">\(invent=X\leq 0\)</span>, es decir</p>
<div class="sourceCode" id="cb221"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">inventario2.sim</span><span class="op">$</span><span class="va">invent</span> <span class="op">&lt;=</span> <span class="va">A</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>La proporción de semanas en que la demanda no ha sido satisfecha (por rebasar el stock) corresponde a aquellas en las que la demanda ha superado al inventario,</p>
<div class="sourceCode" id="cb223"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">inventario2.sim</span><span class="op">$</span><span class="va">invent</span> <span class="op">&lt;</span><span class="va">inventario2.sim</span><span class="op">$</span><span class="va">demanda</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.1428571</code></pre>
</div>
<div id="tiemposocupa-sec" class="section level3" number="2.4.2">
<h3>
<span class="header-section-number">2.4.2</span> Tiempos de ocupación<a class="anchor" aria-label="anchor" href="#tiemposocupa-sec"><i class="fas fa-link"></i></a>
</h3>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-14" class="definition"><strong>Definición 2.11  </strong></span>Sea <span class="math inline">\(\{X_n, n \geq 0\}\)</span> una <span class="math inline">\(CMTD\)</span> homogénea con espacio de estados <span class="math inline">\(S = \{1, 2,...,N\}\)</span>, matriz de probabilidades de transición de una paso <span class="math inline">\(P\)</span>, y distribución inicial <span class="math inline">\(p(0)\)</span>. Consideramos la variable aleatoria <span class="math inline">\(N_j(n)\)</span> como el <strong>número de visitas al estado <span class="math inline">\(j\)</span> en <span class="math inline">\(n\)</span> transiciones</strong> y definimos</p>
<p><span class="math display">\[m_{ij}(n) = E[N_j(n)|X_0 = i]\]</span>
como el <strong>número esperado de visitas</strong> o <strong>tiempo de ocupación del estado <span class="math inline">\(j\)</span> hasta el instante <span class="math inline">\(n\)</span>, partiendo del estado <span class="math inline">\(i\)</span></strong>.</p>
<p>A partir de las cantidades <span class="math inline">\(m_{ij}(n)\)</span> se puede definir la <strong>matriz de tiempos de ocupación hasta un instante</strong> <span class="math inline">\(n\)</span>, <span class="math inline">\(M(n)=(m_{ij}(n))_{ij}\)</span>, que se puede calcular a partir de la matriz de transición <span class="math inline">\(P\)</span> como:</p>
<span class="math display" id="eq:tposocupa">\[\begin{equation}
M(n) = \sum_{r=0}^n P^r
\tag{2.7}
\end{equation}\]</span>
</div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-15" class="definition"><strong>Definición 2.12  </strong></span>Un estado <span class="math inline">\(i\)</span> se dice que es <strong>recurrente</strong> si es continuamente revisitado a lo largo de la vida de la cadena, esto es, el número esperado de visitas al estado <span class="math inline">\(i\)</span> a lo largo de la vida del proceso es infinito, <span class="math inline">\(m_{ii}=E(N_i|X_0=i)=\infty\)</span>. En otro caso, cuando sólo se accede un número finito de veces, se dice que es <strong>transitorio</strong>. Un estado transitorio sólo será accesible durante un cierto periodo de tiempo, tras el cual dicho estado ya no será revisitado nunca más.</p>
</div>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-16" class="example"><strong>Ejemplo 2.4  </strong></span>Volvemos sobre el Ejemplo <a href="cmtd.html#exm:diagramCMTD">2.1</a> para calcular los tiempos de ocupación durante un periodo continuado de 10 transiciones. Para ello utilizamos la Ecuación <a href="cmtd.html#eq:tposocupa">(2.7)</a> con <span class="math inline">\(n=10\)</span>.</p>
<div class="sourceCode" id="cb225"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Simulación de los tiempos de ocupación (número de visitas a un estado)</span>
<span class="co"># Número de estados del proceso</span>
<span class="va">nestat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span>
<span class="co"># Estados</span>
<span class="va">nombres</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span>
<span class="co"># Generamos la matriz de ocupaciones</span>
<span class="va">mocupa</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">nestat</span><span class="op">*</span><span class="va">nestat</span><span class="op">)</span>,
                 nrow <span class="op">=</span> <span class="va">nestat</span>, dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">nombres</span>, <span class="va">nombres</span><span class="op">)</span><span class="op">)</span>
<span class="co"># Bucle de cálculo de los tiempos de ocupación</span>
<span class="va">P</span><span class="op">=</span><span class="va">proceso</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">nestat</span>,<span class="fl">1</span><span class="op">:</span><span class="va">nestat</span><span class="op">]</span> <span class="co"># matriz de transición</span>
<span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="fl">10</span><span class="op">)</span>
<span class="op">{</span>
   <span class="va">mocupa</span> <span class="op">&lt;-</span> <span class="va">mocupa</span> <span class="op">+</span> <span class="va">P</span><span class="op">^</span><span class="va">i</span>
<span class="op">}</span>
<span class="va">mocupa</span></code></pre></div>
<pre><code>##          a        b        c
## a 1.250000 1.428569 1.999023
## b 1.111111 1.000000 6.861894
## c 2.219126 1.000000 1.817903</code></pre>
<p>Podemos ver cómo el número esperado de visitas al estado <span class="math inline">\(c\)</span> partiendo del estado <span class="math inline">\(b\)</span> en las próximas 10 transiciones es casi de 7 (6.86). Sin embargo, si partimos del estado <span class="math inline">\(b\)</span>, en 10 transiciones sólo esperamos volver a dicho estado 1 vez.</p>
</div>
<div class="whitebox">
<p>Definamos una función para obtener la matriz de tiempos de ocupación (o número esperado de visitas) durante un periodo de duración de <span class="math inline">\(n\)</span> unidades de tiempo.</p>
<div class="sourceCode" id="cb227"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mocupa.proceso</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">sistema</span>, <span class="va">n</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># Número de estados del proceso</span>
  <span class="va">nestat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">sistema</span><span class="op">)</span>
  <span class="co"># Estados</span>
  <span class="va">nombres</span><span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">sistema</span><span class="op">)</span>
  <span class="co"># Generamos la matriz de ocupaciones</span>
  <span class="va">mocupa</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">nestat</span><span class="op">*</span><span class="va">nestat</span><span class="op">)</span>,
                 nrow <span class="op">=</span> <span class="va">nestat</span>, dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">nombres</span>, <span class="va">nombres</span><span class="op">)</span><span class="op">)</span>
  <span class="co"># Bucle de calculo de los tiempos de ocupación</span>
  <span class="va">P</span><span class="op">=</span><span class="va">sistema</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">nestat</span>,<span class="fl">1</span><span class="op">:</span><span class="va">nestat</span><span class="op">]</span>
  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="va">n</span><span class="op">)</span>
   <span class="va">mocupa</span> <span class="op">&lt;-</span> <span class="va">mocupa</span> <span class="op">+</span> <span class="va">P</span><span class="op">^</span><span class="va">i</span>
  
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">mocupa</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
</div>
<div class="bluebox">
<p><strong>PRACTICA</strong> Obtener y caracterizar la matriz del número esperado de visitas en 20 transiciones para los procesos: <a href="cmtd.html#fiabilidad">Fiabilidad de máquinas</a>,<a href="cmtd.html#meteo">Metereología</a>, <a href="cmtd.html#inventario">Problema de inventario</a>, <a href="cmtd.html#planificacion">Planificación de mano de obra</a> y <a href="cmtd.html#mercadovalores">Mercado de valores</a>.</p>
</div>
</div>
<div id="análisis-de-costes" class="section level3" number="2.4.3">
<h3>
<span class="header-section-number">2.4.3</span> Análisis de costes<a class="anchor" aria-label="anchor" href="#an%C3%A1lisis-de-costes"><i class="fas fa-link"></i></a>
</h3>
<p>Una aplicación muy habitual de los tiempos de ocupación es directa en los denominados <strong>modelos de costes</strong>, que describimos brevemente, y que pueden estar vinculados en situaciones específicas a costes, pero también a beneficios, pérdidas, etc..</p>
<p>Sea <span class="math inline">\(X_n\)</span> el estado del sistema en el tiempo <span class="math inline">\(n\)</span>. Asumimos que <span class="math inline">\(\{X_n, n \geq 0 \}\)</span> es una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S =\{1, 2,...,N\}\)</span>, matriz de transición <span class="math inline">\(P\)</span>, y matriz de tiempos de ocupación <span class="math inline">\(M(n)\)</span>.</p>
<p>En esta situación, hablamos de que cada visita a cierto estado <span class="math inline">\(i\)</span> tiene un coste aleatorio asociado <span class="math inline">\(C(i)\)</span>, y el coste esperado por cada visita al estado <span class="math inline">\(i\)</span> viene dado por <span class="math inline">\(c(i) = E[C(i)]\)</span>. Definimos la matriz de costes esperados asociados a los estados, como <span class="math inline">\(\mathbf{c}\)</span>, de dimensión <span class="math inline">\(N\times 1\)</span>, como:</p>
<p><span class="math display">\[\mathbf{c}' = (c(1),c(2),\ldots,c(N))\]</span></p>
<p>Así mismo, hablamos del coste <span class="math inline">\(C(X_r)\)</span> en el que incurre el sistema en un instante concreto <span class="math inline">\(r\)</span>, y <span class="math inline">\(\sum_{r=0}^n C(X_r)\)</span> el coste acumulado desde el inicio del proceso hasta llegar al instante <span class="math inline">\(n\)</span>. Entonces el <strong>coste esperado total (CET)</strong> asociado al funcionamiento del sistema hasta llegar al instante <span class="math inline">\(n\)</span> se calculará como</p>
<p><span class="math display">\[CET=E\left[\sum_{r=0}^n C(X_r)\right]\]</span></p>
<p>Definimos el coste esperado total hasta el instante <span class="math inline">\(n\)</span> partiendo del estado <span class="math inline">\(i\)</span>, <span class="math inline">\(g(i,n)\)</span>, como:</p>
<p><span class="math display">\[g(i,n) = E\left[\sum_{r=0}^n C(X_r)| X_0 = i \right]\]</span></p>
<p>y construimos la matriz de <strong>costes totales sobre un horizonte finito (CTHF) hasta el instante <span class="math inline">\(n\)</span></strong>, <span class="math inline">\(\mathbf{g}(n)\)</span>, de dimensión <span class="math inline">\(N \times 1\)</span>, a través de estos costes esperados partiendo de cualesquier estado <span class="math inline">\(i \in S\)</span>, como</p>
<p><span class="math display">\[\mathbf{g}(n)' = (g(1,n),g(2,n),\ldots,g(N,n))\]</span></p>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-17" class="definition"><strong>Definición 2.13  </strong></span>Si vinculado al funcionamiento de un sistema CMTD queremos calcular el <strong>coste esperado total sobre un horizonte finito hasta un instante <span class="math inline">\(n\)</span></strong>, (CTHF), basta multiplicar la matriz de tiempos de ocupación hasta el instante <span class="math inline">\(n\)</span>, <span class="math inline">\(M(n)\)</span>, por la matriz de costes esperados asociados a los estados del sistema, <span class="math inline">\(\mathbf{c}\)</span>, esto es, resolver la Ecuación <a href="cmtd.html#eq:CTHF">(2.8)</a>.</p>
<span class="math display" id="eq:CTHF">\[\begin{equation}
\mathbf{g}(n) = M(n) \cdot \mathbf{c}
\tag{2.8}
\end{equation}\]</span>
</div>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-18" class="example"><strong>Ejemplo 2.5  </strong></span>Volvamos al proceso de inventario presentado en el <a href="cmtd.html#inventario">Problema de inventario</a> con espacio de estados <span class="math inline">\(\{2,3,4,5\}\)</span>. Supongamos que la empresa compra PCs por 1500 euros y los vende por 1750 euros. Además el coste de almacenamiento semanal es de 50 euros por cada unidad que está en la tienda al inicio de una semana. Queremos calcular los ingresos netos que la tienda espera obtener durante las próximas 10 semanas, suponiendo que comienza con cinco PCs en stock al inicio del periodo.</p>
</div>
<p>En esta situación, estamos interesados en los ingresos, por lo que definimos <span class="math inline">\(c(i)\)</span> como los ingresos netos que se obtienen en una semana cualquiera en la que hay <span class="math inline">\(i\)</span> PCs al principio de la semana. Sabemos que los costes de almacenamiento de <span class="math inline">\(i\)</span> PCs es <span class="math inline">\(50i\)</span>. Las ganancias provendrán de los PCs que se hayan vendido. Si <span class="math inline">\(D_n\)</span> es la demanda durante una semana cualquiera <span class="math inline">\(n\)</span>, el número esperado de PCs vendidos durante esa semana será <span class="math inline">\(E[min(i, D_n)]\)</span>. Así, los ingresos netos previstos para una semana cualquiera <span class="math inline">\(n\)</span> en la que se tienen <span class="math inline">\(i\)</span> PCs almacenados al inicio, <span class="math inline">\(c(i)\)</span>, provendrán de los ingresos por ventas menos los gastos de almacenaje, esto es,</p>
<p><span class="math display">\[c(i) = (1750-1500)E[min(i, D_n)] -50i, \quad 2 \leq i \leq 5\]</span></p>
<p>Necesitamos pues, obtener el valor de <span class="math inline">\(E[min(i, D_n)]\)</span>, para cada valor de <span class="math inline">\(i\)</span>. Veamos cómo hacerlo, tanto de forma teórica como mediante simulación. Denotemos por <span class="math inline">\(Z_{i,n} = min(i, D_n),\)</span> para <span class="math inline">\(i=2, 3, 4, 5\)</span> de forma que:</p>
<span class="math display">\[\begin{equation*}
Z_{i,n} =  
\begin{cases}
i &amp; \text{ si } i &lt;D_n \\
D_n &amp; \text{ si } i \geq  D_n 
\end{cases}
\end{equation*}\]</span>
<p>de esta forma tenemos que su valor esperado vendrá dado por:</p>
<p><span class="math display">\[E[Z_{i,n}] = i \cdot Pr[i &lt; D_n] + \sum_{d=0}^{i} d \cdot Pr(D_n=d).\]</span></p>
<p>Recordando que <span class="math inline">\(D_n\sim Pois(3)\)</span> en el ejemplo original, para <span class="math inline">\(i=2\)</span> la expresión anterior da lugar a:</p>
<p><span class="math display">\[\begin{eqnarray*}
E[Z_{2,n}] &amp;= 2 \cdot Pr[D_n &gt; 2] + 0 \cdot Pr[D_n = 0] + 1 \cdot Pr[D_n =1] +2 \cdot Pr(D_n=2) \\
&amp;= 2 \cdot (1-Pr(D_n \leq 2)) + 1 \cdot Pr[D_n =1] + 2 \cdot Pr(D_n=2) \\
&amp;= 2 \cdot 0.5768 +0.1494 +2 \cdot 0.2240 = 1.751
\end{eqnarray*}\]</span></p>
<p>de donde calculamos los ingresos <span class="math inline">\(c(2)\)</span> con la ecuación anterior.
<span class="math display">\[c(2) =  250 \cdot 1.751 -50 \cdot 2 = 337.75\]</span>
Hacemos fácilmente los cálculos para todos los estados:</p>
<div class="sourceCode" id="cb228"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estados</span><span class="op">=</span><span class="fl">2</span><span class="op">:</span><span class="fl">5</span>
<span class="va">lambda</span><span class="op">=</span><span class="fl">3</span>   <span class="co"># Poisson para la demanda</span>
<span class="co"># número esperado de ventas</span>
<span class="va">ez</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">)</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="va">estados</span><span class="op">)</span><span class="op">{</span>
<span class="va">ez</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">=</span><span class="va">i</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">ppois</a></span><span class="op">(</span><span class="va">i</span>,<span class="va">lambda</span><span class="op">)</span><span class="op">)</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="va">i</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">dpois</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="va">i</span>,<span class="va">lambda</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span>
<span class="va">ingresos</span><span class="op">=</span><span class="fl">250</span><span class="op">*</span><span class="va">ez</span><span class="op">-</span><span class="fl">50</span><span class="op">*</span><span class="va">estados</span>;<span class="va">ingresos</span></code></pre></div>
<pre><code>## [1] 337.7662 431.9686 470.1607 466.3449</code></pre>
<p>Y obtenemos
<span class="math display">\[\mathbf{c} = 
\begin{pmatrix}
337.75 \\
431.95 \\
470.15 \\
466.23 
\end{pmatrix}\]</span></p>
<p>Con esta matriz y la matriz de ocupación hasta el instante <span class="math inline">\(n=10\)</span> podemos calcular los ingresos netos totales esperados durante las próximas <span class="math inline">\(n=10\)</span> semanas, sea cual sea el estado inicial del sistema:</p>
<p><span class="math display">\[g(10)=M(10) \cdot c\]</span>
que calculamos a continuación:</p>
<div class="sourceCode" id="cb230"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">c</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">ingresos</span>,<span class="fl">2</span><span class="op">)</span>, ncol<span class="op">=</span><span class="fl">1</span><span class="op">)</span>
<span class="va">M10</span><span class="op">=</span><span class="fu">mocupa.proceso</span><span class="op">(</span><span class="va">inventario</span>,<span class="fl">10</span><span class="op">)</span>
<span class="va">g</span><span class="op">=</span><span class="va">M10</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">c</span>
<span class="va">g</span></code></pre></div>
<pre><code>##           [,1]
## 2 PCs 5283.122
## 3 PCs 3459.611
## 4 PCs 2537.260
## 5 PCs 2325.253</code></pre>
<p>y que nos permite extraer los ingresos netos totales esperados asumiendo que el periodo inicia con <span class="math inline">\(i=5\)</span> PCs en tienda, esto es, como <span class="math inline">\(g(5,10)=4842.59\)</span> euros.</p>
<p>Los valores de <span class="math inline">\(c\)</span> se pueden aproximar mediante simulación sin necesidad de calcularlos de forma teórica. A continuación se presenta el código necesario para realizar la simulación. Concretamente definimos una función que depende del valor del estado inicial <span class="math inline">\(i\)</span>.</p>
<div class="sourceCode" id="cb232"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># simulador del valor esperado del número esperado de ventas</span>
<span class="va">c.sim</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">estado</span>, <span class="va">nsim</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># estado: estado inicial del sistema</span>
  <span class="co"># nsim: nº simulaciones para la aproximación</span>
  
  <span class="co"># Simulamos valores del mínimo entre i y D_n</span>
  <span class="va">datos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>rsim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">rpois</a></span><span class="op">(</span><span class="va">nsim</span>, <span class="fl">3</span><span class="op">)</span>, <span class="va">rdos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="va">estado</span>, <span class="va">nsim</span><span class="op">)</span><span class="op">)</span>
  <span class="va">minimo</span> <span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">datos</span>, <span class="fl">1</span> ,<span class="va">min</span><span class="op">)</span> <span class="co"># Mínimo por filas</span>
  <span class="co"># Valor esperado min(i,D_n)</span>
  <span class="va">esperanza</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">minimo</span><span class="op">)</span>
  <span class="co"># coste</span>
  <span class="va">coste</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="op">-</span><span class="fl">50</span><span class="op">*</span><span class="va">estado</span><span class="op">+</span><span class="fl">250</span><span class="op">*</span><span class="va">esperanza</span>, <span class="fl">2</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">coste</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>Aproximamos pues por simulación, los valores de la matriz <span class="math inline">\(c\)</span> con <span class="math inline">\(nsim=1.000.000\)</span> simulaciones</p>
<div class="sourceCode" id="cb233"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">nsim</span> <span class="op">&lt;-</span> <span class="fl">1000000</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12</span><span class="op">)</span>
<span class="va">c.s</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu">c.sim</span><span class="op">(</span><span class="fl">2</span>, <span class="va">nsim</span><span class="op">)</span>,<span class="fu">c.sim</span><span class="op">(</span><span class="fl">3</span>, <span class="va">nsim</span><span class="op">)</span>,
      <span class="fu">c.sim</span><span class="op">(</span><span class="fl">4</span>, <span class="va">nsim</span><span class="op">)</span>,<span class="fu">c.sim</span><span class="op">(</span><span class="fl">5</span>, <span class="va">nsim</span><span class="op">)</span><span class="op">)</span>,ncol<span class="op">=</span><span class="fl">1</span><span class="op">)</span>
<span class="va">c.s</span></code></pre></div>
<pre><code>##        [,1]
## [1,] 337.66
## [2,] 431.61
## [3,] 470.28
## [4,] 466.69</code></pre>
<p>Como se puede ver, la simulación funciona bastante bien para aproximar el vector <span class="math inline">\(c\)</span>; resolvamos pues los cálculos de <span class="math inline">\(g(5,10)\)</span> con estos valores, que de nuevo aproximarán las cantidades que buscamos.</p>
<div class="sourceCode" id="cb235"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># matriz M</span>
<span class="va">Mmat</span> <span class="op">&lt;-</span> <span class="fu">mocupa.proceso</span><span class="op">(</span><span class="va">inventario</span>, <span class="fl">10</span><span class="op">)</span>
<span class="co"># vector g</span>
<span class="va">beneficio</span> <span class="op">&lt;-</span> <span class="va">Mmat</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span><span class="va">c.s</span>
<span class="va">beneficio</span></code></pre></div>
<pre><code>##           [,1]
## 2 PCs 5285.787
## 3 PCs 3460.827
## 4 PCs 2537.646
## 5 PCs 2325.374</code></pre>
<p>Mientras que teóricamente obteníamos unos ingresos esperados de 4842.59€, con la simulación obtenemos una aproximación de 4844.27€.</p>
</div>
<div id="tiempos-de-primer-paso" class="section level3" number="2.4.4">
<h3>
<span class="header-section-number">2.4.4</span> Tiempos de primer paso<a class="anchor" aria-label="anchor" href="#tiempos-de-primer-paso"><i class="fas fa-link"></i></a>
</h3>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-19" class="definition"><strong>Definición 2.14  </strong></span>Sea <span class="math inline">\(\{X_n, n \geq 0\}\)</span> una <span class="math inline">\(CMTD\)</span> homogénea con espacio de estados <span class="math inline">\(S = \{1, 2,...,N\}\)</span>. Se define el <strong>tiempo de primer paso</strong> o <strong>tiempo de primera visita</strong> al estado <span class="math inline">\(j\)</span> partiendo del estado <span class="math inline">\(i\)</span>, <span class="math inline">\(T_{ij}\)</span>, como el mínimo número de transiciones necesarias para alcanzar el estado <span class="math inline">\(j\)</span> partiendo del estado inicial <span class="math inline">\(i\)</span>, es decir:</p>
<p><span class="math display">\[T_{ij} = \underset{n}{min}\{n &gt; 0, X_n = j | X_0 = i\}\]</span></p>
<p>En ocasiones interesará sin embargo el tiempo de primer paso de un estado a un conjunto de estados <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[T_{iA} = \underset{n}{min}\{n &gt; 0, X_n \in A | X_0 = i\}.\]</span></p>
</div>
</div>
<div class="whitebox">
<p>Para obtener los tiempos esperados de recurrencia <span class="math inline">\(f=(f_{11},...,f_{NN})\)</span> para el espacio de estados <span class="math inline">\(S=\{1,...,N\}\)</span>, utilizamos la función <code>meanRecurrenceTime(proceso)</code> de la librería <code>markovchain</code>.</p>
<p>Para obtener los tiempos esperados de primer paso por un estado <span class="math inline">\(j\)</span> desde cualquier estado de <span class="math inline">\(S\)</span>, podemos utilizar la función <code>meanFirstPassageTime(proceso,destination=j)</code> de la librería <code>markovchain</code>.
Si queremos calcular la matriz de tiempos esperados para llegar a cualquier estado desde cualquier estado, basta utilizar <code>meanFirstPassageTime(proceso)</code>.</p>
</div>
<p>En caso de que no podamos utilizar la función <code>meanFirstPassageTime</code> para el cálculo del tiempo esperado de primer paso, podemos utilizar la propiedad que pasamos a describir.</p>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-20" class="definition"><strong>Definición 2.15  </strong></span>Sea <span class="math inline">\(\{X_n, n \geq 0\}\)</span> una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S = \{1, 2,...,N\}\)</span>. Si estamos interesados en obtener el tiempo esperado de primer paso para el estado <span class="math inline">\(j\)</span> desde cualquier estado <span class="math inline">\(i\)</span>, dado por:</p>
<p><span class="math display">\[v_{ij} = E(T_{ij}), \quad \text{ con } T_{ij} = \underset{n}{min}\{n &gt; 0, X_n = j | X_0 = i\}\]</span></p>
<p>y construimos la matriz de dimensión <span class="math inline">\((N-1) \times 1\)</span> <span class="math inline">\(\mathbf{v_j'}=(v_{1j},...,v_{j-1,j},v_{j+1,j},...,v_{Nj})\)</span><br>
basta con resolver el sistema:</p>
<span class="math display" id="eq:primerpaso-ecu">\[\begin{equation}
[\mathbf{I} - P_{-j}]\mathbf{v_j} = \mathbf{1}
\tag{2.9}
\end{equation}\]</span>
<p>donde</p>
<ul>
<li>
<span class="math inline">\(P_{-j}\)</span> es la matriz de transición eliminando la fila y columna del estado <span class="math inline">\(j\)</span>,</li>
<li>
<span class="math inline">\(\mathbf{1}\)</span> es un vector de unos, de dimensión <span class="math inline">\(N-1\)</span>,</li>
<li>
<span class="math inline">\(\mathbf{I}\)</span> es una matriz diagonal de las mismas dimensiones que <span class="math inline">\(P_{-N}\)</span>.</li>
</ul>
<p>Esta ecuación se puede generalizar para obtener los tiempos esperados de primer paso desde un estado <span class="math inline">\(i\)</span> hasta cualquier subconjunto de estados <span class="math inline">\(S_c \subset S\)</span>.</p>
</div>
</div>
<div class="whitebox">
<p><strong>Función para obtener los tiempos esperados de primer paso</strong></p>
<p>Como alternativa a la función definida en <code>markovchain</code>, programamos a continuación una función genérica para poder obtener los tiempos esperados de primer paso, dependiente de dos parámetros:</p>
<ul>
<li>proceso: <span class="math inline">\(CMTD\)</span> que describe el sistema a estudio</li>
<li>estado: estado o conjunto de estados que se desean alcanzar, partiendo desde cualquier estado inicial que no está en este conjunto.</li>
</ul>
<div class="sourceCode" id="cb237"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Función para obtener el tiempo esperado de primer paso por "estado"</span>
<span class="co"># (equivalente a meanFirstPassageTime de markovchain)</span>
<span class="va">tiempo.pp</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">proceso</span>, <span class="va">estado</span><span class="op">)</span>
<span class="op">{</span>
  <span class="co"># estados del proceso</span>
  <span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/states.html">states</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span>
  <span class="va">numestados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">estados</span><span class="op">)</span>
  <span class="co"># posición de los estados deseados</span>
  <span class="va">lestat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">estado</span><span class="op">)</span>
  <span class="va">pos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">estados</span> <span class="op"><a href="https://rdrr.io/r/base/match.html">%in%</a></span> <span class="va">estado</span><span class="op">)</span>
  <span class="co"># matriz P_N</span>
  <span class="va">P_N</span> <span class="op">&lt;-</span> <span class="va">proceso</span><span class="op">[</span><span class="op">-</span><span class="va">pos</span>,<span class="op">-</span><span class="va">pos</span><span class="op">]</span>
  <span class="co"># vector de unos</span>
  <span class="va">vector.1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">numestados</span><span class="op">-</span><span class="va">lestat</span><span class="op">)</span>, ncol<span class="op">=</span><span class="fl">1</span><span class="op">)</span>
  <span class="co"># sistema de ecuaciones</span>
  <span class="va">sistema</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">numestados</span><span class="op">-</span><span class="va">lestat</span><span class="op">)</span> <span class="op">-</span> <span class="va">P_N</span>
  <span class="co"># solución del sistema</span>
  <span class="va">solucion</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html">solve</a></span><span class="op">(</span><span class="va">sistema</span>, <span class="va">vector.1</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">solucion</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-21" class="definition"><strong>Definición 2.16  </strong></span>Sea <span class="math inline">\(\{X_n, n \geq 0\}\)</span> una <span class="math inline">\(CMTD\)</span> homogénea con espacio de estados <span class="math inline">\(S = \{1, 2,...,N\}\)</span>. Se definen las <strong>probabilidades de primera visita</strong> o primer paso del estado <span class="math inline">\(i\)</span> al <span class="math inline">\(j\)</span> en <span class="math inline">\(n\)</span> transiciones, con <span class="math inline">\(f_{ij}(n)\)</span>,</p>
<p><span class="math display">\[\begin{eqnarray*}
f_{ij}(n) &amp;=&amp; Pr[X_n = j, X_{n-1} \neq j,\ldots, X_1 \neq j | \quad X_0 = i] \\ 
&amp;=&amp; Pr(T_{ij}=n), \quad n \geq 0
\end{eqnarray*}\]</span></p>
<p>donde por convenio <span class="math inline">\(f_{ij}(0) = 0.\)</span></p>
</div>
</div>
<div class="whitebox">
<p>Podemos obtener la distribución de probabilidad asociada al tiempo de primer paso del estado <span class="math inline">\(j\)</span> desde el estado <span class="math inline">\(i\)</span> en <span class="math inline">\(n\)</span> transiciones, <span class="math inline">\(f_{ij}(n)\)</span>, con la función <code>firstPassageMultiple(proceso,state=i,set=j,n=n)</code>.</p>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-22" class="definition"><strong>Definición 2.17  </strong></span>Si <span class="math inline">\(T_{ii}\)</span> denota el <strong>tiempo del primer retorno</strong>, o <strong>tiempo de recurrencia</strong> al estado <span class="math inline">\(i\)</span>, entonces se dice que el estado <span class="math inline">\(i\)</span> es <strong>recurrente</strong> si <span class="math inline">\(f_{ii}=Pr(T_{ii}&lt;\infty)=1\)</span>, es decir, si el sistema se inicia en él, pueda volver a él. Es transitorio si <span class="math inline">\(f_{ii}&lt;1\)</span>.</p>
</div>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-23" class="example"><strong>Ejemplo 2.6  </strong></span>Analizamos los tiempos de primer paso, tiempos de recurrencia y probabilidades de primer paso sobre el proceso presentado en el Ejemplo <a href="cmtd.html#exm:diagramCMTD">2.1</a>. Estamos interesados en saber cuándo alcanzaremos el estado “b” partiendo desde cualquier estado en el momento inicial.</p>
</div>
<p>Comenzamos calculando los tiempos de primer paso utilizando las dos funciones consideradas, la propia y la de <code>markovchain</code>.</p>
<div class="sourceCode" id="cb238"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Tiempo de primer paso partiendo del estado "b"</span>
<span class="co"># libreria</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime</a></span><span class="op">(</span><span class="va">proceso</span>, <span class="st">"b"</span><span class="op">)</span></code></pre></div>
<pre><code>##        a        c 
## 6.363636 8.181818</code></pre>
<div class="sourceCode" id="cb240"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># definida por nosotros</span>
<span class="fu">tiempo.pp</span><span class="op">(</span><span class="va">proceso</span>, <span class="st">"b"</span><span class="op">)</span></code></pre></div>
<pre><code>##       [,1]
## a 6.363636
## c 8.181818</code></pre>
<p>Podemos ver que ambas funciones proporcionan el mismo resultado. Si comenzamos en el estado “a” tardaremos en promedio seis transiciones para alcanzar por primera vez el estado “b,” mientras que si empezamos en el estado “c” tardaremos 8 transiciones en alcanzar el estado “b.”</p>
<p>Si deseamos la matriz del valor esperado del primer paso en cualquier estado basta con ejecutar</p>
<div class="sourceCode" id="cb242"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span></code></pre></div>
<pre><code>##          a        b        c
## a 0.000000 6.363636 1.688312
## b 2.636364 0.000000 1.168831
## c 1.818182 8.181818 0.000000</code></pre>
<p>Obtenemos ahora el tiempo de primer paso (utilizando la función programada) y la probabilidad de primer paso de pasar del estado <span class="math inline">\(b\)</span> a cualquiera de los estados <span class="math inline">\(a\)</span> o <span class="math inline">\(c\)</span> en 10 transiciones (<span class="math inline">\(A = \{a, c\}\)</span>)</p>
<div class="sourceCode" id="cb244"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Tiempo esperado e primer paso de "b" a "A"</span>
<span class="fu">tiempo.pp</span><span class="op">(</span><span class="va">proceso</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>,<span class="st">"c"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>##      [,1]
## [1,]    1</code></pre>
<div class="sourceCode" id="cb246"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Probabilidad de primer paso de "b" a "A"</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/firstPassageMultiple.html">firstPassageMultiple</a></span><span class="op">(</span><span class="va">proceso</span>, <span class="st">"b"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>,<span class="st">"c"</span><span class="op">)</span>, <span class="fl">10</span><span class="op">)</span></code></pre></div>
<pre><code>##             set
## 1  1.0000000000
## 2  0.5450000000
## 3  0.2597500000
## 4  0.1091375000
## 5  0.0479968750
## 6  0.0211430938
## 7  0.0093898422
## 8  0.0041868540
## 9  0.0018726328
## 10 0.0008392372</code></pre>
<p>Se espera poder pasar de <span class="math inline">\(b\)</span> a <span class="math inline">\(A\)</span> en una transición (lógico puesto que A es el conjunto complementario a <span class="math inline">\(b\)</span> en el conjunto de estados), mientras que la probabilidad de pasar del estado <span class="math inline">\(b\)</span> al conjunto <span class="math inline">\(A\)</span> en dos transiciones es de <span class="math inline">\(0.55\)</span> y tan solo de <span class="math inline">\(0.0008\)</span> en 10 transiciones.</p>
<p>En cuanto a los tiempos de recurrencia, tenemos:</p>
<div class="sourceCode" id="cb248"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Tiempo de recurrencia</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanRecurrenceTime.html">meanRecurrenceTime</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span></code></pre></div>
<pre><code>##        a        b        c 
## 2.700000 9.000000 1.928571</code></pre>
<p>Podemos ver que una vez hemos pasado por el estado “b” tardamos 9 transiciones en volver a él. Calculamos ahora la probabilidad de recurrencia en 10 transiciones.</p>
<div class="sourceCode" id="cb250"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Probabilidad de recurrencia en 10 pasos</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/firstPassageMultiple.html">firstPassageMultiple</a></span><span class="op">(</span><span class="va">proceso</span>, <span class="st">"b"</span>, <span class="st">"b"</span>, <span class="fl">10</span><span class="op">)</span></code></pre></div>
<pre><code>##           set
## 1  0.00000000
## 2  0.03000000
## 3  0.15450000
## 4  0.10597500
## 5  0.09746625
## 6  0.08295844
## 7  0.07195424
## 8  0.06211757
## 9  0.05368795
## 10 0.04638892</code></pre>
<p>Si iniciamos el proceso en el estado “b” la probabilidad de volver a dicho estado es muy baja en cualquiera de las 10 primeras transiciones. La probabilidad de volver en 3 transiciones es de 0.15, pero de volver en 10 transiciones es de 0.046.</p>
<p>¿Qué implicaciones prácticas tienen los análisis realizados en el proceso estudiado?</p>
<div class="example">
<p><span id="exm:unlabeled-div-24" class="example"><strong>Ejemplo 2.7  </strong></span>Consideramos el proceso que ya vimos sobre <a href="cmtd.html#fiabilidad">Fiabilidad de máquinas</a>. Supongamos que en el instante inicial (dia 0) las dos máquinas están “On,” y que deseamos calcular el tiempo esperado hasta que las dos máquinas estén “Off” por primera vez.</p>
</div>
<p>Si <span class="math inline">\(Y_n\)</span> es el proceso que representa el número de máquinas que están “On,” con espacio de estados <span class="math inline">\(S = \{0, 1, 2\}\)</span>, estamos interesados en calcular el tiempo esperado para llegar a <span class="math inline">\(Y_n = 0\)</span> (dos máquinas “Off”) partiendo de <span class="math inline">\(Y_0 = 2\)</span> (dos máquinas “On”). Utilizamos la función propia estableciendo el estado objetivo.</p>
<div class="sourceCode" id="cb252"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Tiempo de primer paso para acabar en el estado "0"</span>
<span class="fu">tiempo.pp</span><span class="op">(</span><span class="va">fiabilidad</span>, <span class="st">"0"</span><span class="op">)</span></code></pre></div>
<pre><code>##       [,1]
## 1 2450.990
## 2 2451.485</code></pre>
<p>El tiempo esperado para que las dos máquinas estén en estado “Off” comenzando con ambas en el estado “On” es 2451.5, que expresado en años será <span class="math inline">\(2451.5/365 = 6.71\)</span> años.</p>
<div class="example">
<p><span id="exm:unlabeled-div-25" class="example"><strong>Ejemplo 2.8  </strong></span>Consideramos el proceso ya presentado sobre <a href="cmtd.html#planificacion">Planificación de mano de obra</a>. Deseamos el tiempo medio de permanencia en la empresa para un empleado recién reclutado. Recordemos que un nuevo empleado siempre empieza en el nivel “1.” Definamos un proceso <span class="math inline">\(Y_n\)</span> que representa el nivel de un empleado novel en la semana n-ésima, proceso que puede tomar los valores <span class="math inline">\(S = \{0, 1, 2, 3, 4\}\)</span>, donde <span class="math inline">\(Y_n=0\)</span> significa que deja la empresa en n semanas después de empezar. En esta situación el proceso <span class="math inline">\(\{Y_n, n \geq 0\}\)</span> es una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S = \{0, 1, 2, 3, 4\}\)</span> y matriz de probabilidades de transición calculadas a partir de las probabilidades que se daban en el desarrollo de <a href="cmtd.html#planificacion">Planificación de mano de obra</a> y teniendo en cuenta que si está fuera de la empresa, a la semana siguiente también lo estará:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0.02 &amp; 0.98 &amp; 0.03 &amp; 0 &amp; 0\\
0.008 &amp; 0 &amp; 0.982 &amp; 0.01 &amp; 0\\
0.02 &amp; 0 &amp; 0 &amp; 0.975 &amp; 0.005\\
0.01 &amp; 0 &amp; 0 &amp; 0 &amp; 0.99
\end{pmatrix}\]</span></p>
</div>
<p>Creamos la estructura del sistema:</p>
<div class="sourceCode" id="cb254"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"0"</span>, <span class="st">"1"</span>, <span class="st">"2"</span>, <span class="st">"3"</span>, <span class="st">"4"</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>,  
                        <span class="fl">0.02</span>, <span class="fl">0.95</span>, <span class="fl">0.03</span>, <span class="fl">0</span>, <span class="fl">0</span>, 
                        <span class="fl">0.008</span>, <span class="fl">0</span>, <span class="fl">0.982</span>, <span class="fl">0.01</span>, <span class="fl">0</span>,   
                        <span class="fl">0.02</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0.975</span>, <span class="fl">0.005</span>,
                        <span class="fl">0.01</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0.99</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">5</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">planificacion2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, name <span class="op">=</span> <span class="st">"planificacion"</span><span class="op">)</span>
<span class="co"># Verificamos los datos introducidos</span>
<span class="va">planificacion2</span></code></pre></div>
<pre><code>## planificacion 
##  A  5 - dimensional discrete Markov Chain defined by the following states: 
##  0, 1, 2, 3, 4 
##  The transition matrix  (by rows)  is defined as follows: 
##       0    1     2     3     4
## 0 1.000 0.00 0.000 0.000 0.000
## 1 0.020 0.95 0.030 0.000 0.000
## 2 0.008 0.00 0.982 0.010 0.000
## 3 0.020 0.00 0.000 0.975 0.005
## 4 0.010 0.00 0.000 0.000 0.990</code></pre>
<div class="sourceCode" id="cb256"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># y describimos el sistema</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">planificacion2</span><span class="op">)</span></code></pre></div>
<pre><code>## planificacion  Markov chain that is composed by: 
## Closed classes: 
## 0 
## Recurrent classes: 
## {0}
## Transient classes: 
## {1},{2},{3},{4}
## The Markov chain is not irreducible 
## The absorbing states are: 0</code></pre>
<p>En este caso el estado “0” es absorbente (cuando es despedido, ya no vuelve), y el resto de estados son transitorios. Al tener un estado absorbente, no es irreducible y no se puede aplicar la función <code><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime()</a></code> para calcular los tiempos de primer paso esperados. Usamos pues, la función que hemos programado:</p>
<div class="sourceCode" id="cb258"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Tiempo esperado para llegar a estado 0</span>
<span class="fu">tiempo.pp</span><span class="op">(</span><span class="va">planificacion2</span>, <span class="st">"0"</span><span class="op">)</span></code></pre></div>
<pre><code>##        [,1]
## 1  73.33333
## 2  88.88889
## 3  60.00000
## 4 100.00000</code></pre>
<p>Puesto que el nuevo empleado comienza siempre en el nivel “1,” el tiempo esperado para que abandone la empresa es de 73.33 semanas (el proceso se mide en semanas), lo que equivale a 1.4 años (<span class="math inline">\(73.33/52\)</span>).</p>
</div>
</div>
<div id="AsinCMTD" class="section level2" number="2.5">
<h2>
<span class="header-section-number">2.5</span> Comportamiento a largo plazo<a class="anchor" aria-label="anchor" href="#AsinCMTD"><i class="fas fa-link"></i></a>
</h2>
<p>En está sección estamos interesados en estudiar el comportamiento a largo plazo o asintótico de una <span class="math inline">\(CMTD\)</span>, es decir, el comportamiento cuando <span class="math inline">\(n \rightarrow \infty\)</span>.</p>
<div class="yellowbox">
<div class=".definition">
<p>La distribución estacionaria <span class="math inline">\(\{\pi_1,..., \pi_N\}\)</span> de una CMTD <span class="math inline">\(\{X_n, n \geq 0\}\)</span>, con espacio de estados <span class="math inline">\(S =\{1, 2,..., N\}\)</span> verifica que:</p>
<p><span class="math display">\[Pr(X_n=i)=\pi_i, \forall i \in S, \ n \geq 0.\]</span></p>
</div>
</div>
<div class="yellowbox">
<div class=".definition">
<p>Si existe la distribución a largo plazo de un proceso CMTD <span class="math inline">\(\{X_n, n \geq 0\}\)</span>, con espacio de estados <span class="math inline">\(S =\{1, 2,..., N\}\)</span> y matriz de probabilidades de transición <span class="math inline">\(P\)</span>, la denominamos <strong>distribución límite</strong> o <strong>distribución en estado estacionario</strong>, y la denotamos por:</p>
<p><span class="math display">\[\pi = [\pi_1, \pi_2,...,\pi_N]\]</span></p>
<p>donde</p>
<p><span class="math display">\[\pi_j = \underset{n \rightarrow \infty}{lim} Pr[X_n = j], \quad j \in S\]</span>
Si existe la distribución límite o en estado estacionario, dicha distribución es la distribución estacionaria.</p>
</div>
</div>
<div class="yellowbox">
<div class=".definition">
<p>Si existe la distribución límite de un proceso CMTD <span class="math inline">\(\{X_n, n \geq 0\}\)</span>, con espacio de estados <span class="math inline">\(S =\{1, 2,..., N\}\)</span> y matriz de probabilidades de transición <span class="math inline">\(P\)</span>, entonces las probabilidades <span class="math inline">\(\pi_j\)</span> satisfacen la siguiente ecuación:</p>
<p><span class="math display">\[\pi_j = \sum_{i=1}^N \pi_i p_{ij}, \quad \forall j \in S,\]</span>
donde <span class="math inline">\(p_{ij}\)</span> son las probabilidades de transición (en la matriz <span class="math inline">\(P\)</span>). Esta propiedad en formato matricial da lugar a la <strong>ecuación de balance</strong> o <strong>del estado estacionario</strong>, que viene dada por:</p>
<span class="math display" id="eq:ecuee">\[\begin{equation}
\pi = \pi \cdot P, \qquad \text{ con } 
\tag{2.10}
\end{equation}\]</span>
<p>junto con la restricción de normalización</p>
<p><span class="math display">\[\sum_{j=1}^N \pi_j = 1.\]</span></p>
</div>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-26" class="definition"><strong>Definición 2.18  </strong></span>Sea <span class="math inline">\(\{X_n, n \geq 0\}\)</span> una <span class="math inline">\(CMTD\)</span>, con <span class="math inline">\(N_j(n)\)</span> el número de visitas o tiempo de ocupación del estado <span class="math inline">\(j\)</span>. La <strong>ocupación</strong> del estado <span class="math inline">\(j\)</span> se define como la proporción de visitas al estado <span class="math inline">\(j\)</span> (o proporción del tiempo de ocupación que el sistema está en <span class="math inline">\(j\)</span>) en el largo plazo (<span class="math inline">\(n \rightarrow \infty\)</span>):</p>
<p><span class="math display" id="eq:ocupacion">\[\begin{equation}
\pi_j=lim_{n \rightarrow \infty} \frac{E[N_j(n)|X_0=i]}{n+1}
\tag{2.11}
\end{equation}\]</span></p>
<p>Si existe esta distribución de ocupación, entonces satisface las ecuaciones de balance y de normalización en <a href="cmtd.html#eq:ecuee">(2.10)</a>.</p>
</div>
</div>
<div class="yellowbox">
<div class="theorem">
<p><span id="thm:unlabeled-div-27" class="theorem"><strong>Teorema 2.1  </strong></span>Una CMTD con espacio de estados finitos y que es irreducible tiene una única distribución estacionaria, es decir, sólo hay una solución normalizada de la ecuación de balance.</p>
<p>Una CMTD con espacio de estados finitos y que es irreducible tiene una única distribución de ocupación y es igual a la distribución estacionaria.</p>
</div>
</div>
<p>Introducimos ahora el concepto de periodicidad, que nos ayudará a decidir cuándo existe la distribución estacionaria.</p>
<div class="yellowbox">
<div class="definition">
<p><span id="def:periodo" class="definition"><strong>Definición 2.19  </strong></span>Sea la <span class="math inline">\(CMTD\)</span> <span class="math inline">\(\{X_n, n \geq 0\}\)</span> con espacio de estados <span class="math inline">\(S =\{1, 2,..., N\}\)</span> y <span class="math inline">\(d\)</span> el entero más grande tal que para cualquier estado <span class="math inline">\(i \in S\)</span></p>
<p><span class="math display">\[\text{si } Pr[X_n = i | X_0 = i] &gt;0 \Rightarrow n \text{ es  múltiplo de } d,\]</span></p>
<p>Se dice entonces que dicha <span class="math inline">\(CMTD\)</span> es <strong>periódica con periodo <span class="math inline">\(d\)</span></strong> si <span class="math inline">\(d&gt;1\)</span>, y <strong>aperiódica</strong> si <span class="math inline">\(d = 1\)</span>.</p>
</div>
</div>
<p>Así, una CMTD con periodo <span class="math inline">\(d\)</span> puede volver a su estado inicial sólo en los instantes <span class="math inline">\(d, 2d, 3d, ...\)</span>. En consecuencia, en las CMTD irreducibles es suficiente encontrar el periodo <span class="math inline">\(d\)</span> para cualquier estado <span class="math inline">\(i \in S\)</span>, puesto que será el mismo para todos los estados, con lo que encontrar el periodo en CMTD irreducibles será sencillo.</p>
<p>En particular, si <span class="math inline">\(p_{ii}&gt;0\)</span> para cualquier <span class="math inline">\(i\in S\)</span> (todos los estados son recurrentes) de una CMTD irreducible, entonces <span class="math inline">\(d=1\)</span> y la CMTD será aperiódica.</p>
<div class="yellowbox">
<div class="theorem">
<p><span id="thm:unlabeled-div-28" class="theorem"><strong>Teorema 2.2  </strong></span>Una CMTD con espacio de estados finitos, irreducible y aperiódica tiene una única distribución límite o en el estado estacionario, que coincide pues con la distribución estacionaria y también con la de los tiempos de ocupación.</p>
<p>La distribución límite o en estado estacionario de una CMTD reducible no es única y depende del estado inicial de la cadena.</p>
</div>
</div>
<div class="whitebox">
<p>Podemos estudiar la periocidad de un sistema mediante la función <code><a href="https://rdrr.io/pkg/markovchain/man/structuralAnalysis.html">period()</a></code> de la librería <code>markovchain</code>.</p>
<p>La función <code><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates()</a></code> de la librería <code>markovchain</code> nos devuelve la distribución estacionaria de una <span class="math inline">\(CMTD\)</span>.</p>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-29" class="example"><strong>Ejemplo 2.9  </strong></span>Analizamos el sistema presentado en el Ejemplo <a href="cmtd.html#exm:diagramCMTD">2.1</a> para obtener la distribución estacionaria:</p>
<div class="sourceCode" id="cb260"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/structuralAnalysis.html">period</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb262"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Distribución estacionaria</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates</a></span><span class="op">(</span><span class="va">proceso</span><span class="op">)</span></code></pre></div>
<pre><code>##              a         b         c
## [1,] 0.3703704 0.1111111 0.5185185</code></pre>
<p>Obtenemos de esta forma las probabilidades asintóticas de estar en cada uno de los estados. Vemos pues, que a la larga lo más probable es que nos encontremos en el estado ‘c,’ y lo menos probable es estar en el estado ‘b.’</p>
</div>
<div class="yellowbox">
<div class="definition">
<p><span id="def:unlabeled-div-30" class="definition"><strong>Definición 2.20  </strong></span>Si <span class="math inline">\(i\)</span> es un estado recurrente y existe la distribución estacionaria, entonces el valor esperado del tiempo de recurrencia es el inverso de la probabilidad de <span class="math inline">\(i\)</span> según la distribución estacionaria, es decir,</p>
<span class="math display" id="eq:et-piestacionaria">\[\begin{equation}
E[T_{ii}] = 1/\pi_i.
\tag{2.12}
\end{equation}\]</span>
</div>
</div>
<p>Tenemos un resultado adicional sobre el comportamiento de los <strong>costes en el estado estacionario</strong>.</p>
<div class="yellowbox">
<div class="definition">
<p><span id="def:costesestacionarios" class="definition"><strong>Definición 2.21  </strong></span>Si <span class="math inline">\(c(i)\)</span> es el coste esperado en el que incurrimos cuando visitamos el estado <span class="math inline">\(i \in S\)</span>, de una CMTD irreducible con distribución de ocupación <span class="math inline">\(\pi\)</span>, entonces el coste esperado por unidad a largo plazo (en el estado estacionario) viene dado por:</p>
<p><span class="math display">\[g= \sum_{j\in S} \pi_j \ c(j).\]</span></p>
</div>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-31" class="example"><strong>Ejemplo 2.10  </strong></span>Para el proceso descrito en la sección <a href="cmtd.html#telecomunicaciones">Telecomunicaciones</a>, en el que los paquetes de datos que se generan en el instante (ranura) <span class="math inline">\(n\)</span>, <span class="math inline">\(A_n \sim Po(1)\)</span>, se almacenaban en un buffer de capacidad <span class="math inline">\(K=7\)</span>, que se van eliminando conforme a cierta estrategia. Interesados en el proceso <span class="math inline">\(\{X_n, n\geq 0\}\)</span> que describe el número de paquetes en el buffer al final de la n-ésima ranura, con espacio de estados <span class="math inline">\(S=\{0, 1,..., 7\}\)</span> y matriz de probabilidades de transición:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.3679 &amp; 0.3679 &amp; 0.1839 &amp; 0.0613 &amp; 0.0153 &amp; 0.0031 &amp; 0.0005 &amp; 0.0001\\
0.3679 &amp; 0.3679 &amp; 0.1839 &amp; 0.0613 &amp; 0.0153 &amp; 0.0031 &amp; 0.0005 &amp; 0.0001\\
0.0 &amp; 0.3679 &amp; 0.3679 &amp; 0.1839 &amp; 0.0613 &amp; 0.0153 &amp; 0.0031 &amp; 0.0006\\
0.0 &amp; 0.0 &amp; 0.3679 &amp; 0.3679 &amp; 0.1839 &amp; 0.0613 &amp; 0.0153 &amp; 0.0037\\
0.0 &amp; 0.0 &amp; 0.0&amp; 0.3679 &amp; 0.3679 &amp; 0.1839 &amp; 0.0613 &amp; 0.0190\\
0.0 &amp; 0.0 &amp; 0.0&amp; 0.0&amp; 0.3679 &amp; 0.3679 &amp; 0.1839 &amp; 0.0803\\
0.0 &amp; 0.0 &amp; 0.0&amp; 0.0&amp; 0.0&amp; 0.3679 &amp; 0.3679 &amp; 0.2642\\
0.0 &amp; 0.0 &amp; 0.0&amp; 0.0&amp; 0.0&amp; 0.0&amp; 0.3679 &amp; 0.6321\\
\end{pmatrix}\]</span></p>
<p>En esta situación estamos interesados en analizar las siguientes características del estado estacionario del proceso <span class="math inline">\(X_n\)</span>:</p>
<ol style="list-style-type: decimal">
<li>Periodo del proceso.</li>
<li>Fracción de tiempo en que el buffer estará lleno.</li>
<li>Número esperado de paquetes que esperan en el buffer.</li>
</ol>
</div>
<p>Definamos la estructura del proceso para la librería <code>markovchain</code>, y pidamos la distribución estacionaria.</p>
<div class="sourceCode" id="cb264"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Estructura del proceso</span>
<span class="co"># Definimos estados</span>
<span class="va">estados</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">7</span><span class="op">)</span>
<span class="co"># Matriz de transición </span>
<span class="va">pmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.3679</span>, <span class="fl">0.3679</span>, <span class="fl">0.1839</span>, <span class="fl">0.0613</span>, <span class="fl">0.0153</span>, 
                        <span class="fl">0.0031</span>, <span class="fl">0.0005</span>, <span class="fl">0.0001</span>,
<span class="fl">0.3679</span>, <span class="fl">0.3679</span>, <span class="fl">0.1839</span>, <span class="fl">0.0613</span>, <span class="fl">0.0153</span>, <span class="fl">0.0031</span>, <span class="fl">0.0005</span>, <span class="fl">0.0001</span>,
<span class="fl">0.0</span>, <span class="fl">0.3679</span>, <span class="fl">0.3679</span>, <span class="fl">0.1839</span>, <span class="fl">0.0613</span>, <span class="fl">0.0153</span>, <span class="fl">0.0031</span>, <span class="fl">0.0006</span>,
<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.3679</span>, <span class="fl">0.3679</span>, <span class="fl">0.1839</span>, <span class="fl">0.0613</span>, <span class="fl">0.0153</span>, <span class="fl">0.0037</span>,
<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.3679</span>, <span class="fl">0.3679</span>, <span class="fl">0.1839</span>, <span class="fl">0.0613</span>, <span class="fl">0.0190</span>,
<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.3679</span>, <span class="fl">0.3679</span>, <span class="fl">0.1839</span>, <span class="fl">0.0803</span>,
<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.3679</span>, <span class="fl">0.3679</span>, <span class="fl">0.2642</span>,
<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.3679</span>, <span class="fl">0.6321</span><span class="op">)</span>, 
               byrow <span class="op">=</span> <span class="cn">TRUE</span>, nrow <span class="op">=</span> <span class="fl">8</span>, 
               dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>, <span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># CMTD</span>
<span class="va">teleco</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>, states <span class="op">=</span> <span class="va">estados</span>, 
                 byrow <span class="op">=</span> <span class="cn">TRUE</span>, transitionMatrix <span class="op">=</span> <span class="va">pmat</span>, 
              name <span class="op">=</span> <span class="st">"Telecomunicaciones"</span><span class="op">)</span>
<span class="co"># Revisamos si la CMTD es irreducible</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">teleco</span><span class="op">)</span></code></pre></div>
<pre><code>## Telecomunicaciones  Markov chain that is composed by: 
## Closed classes: 
## 0 1 2 3 4 5 6 7 
## Recurrent classes: 
## {0,1,2,3,4,5,6,7}
## Transient classes: 
## NONE 
## The Markov chain is irreducible 
## The absorbing states are: NONE</code></pre>
<div class="sourceCode" id="cb266"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Periodo del sistema</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/structuralAnalysis.html">period</a></span><span class="op">(</span><span class="va">teleco</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb268"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Distribución estacionaria</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates</a></span><span class="op">(</span><span class="va">teleco</span><span class="op">)</span></code></pre></div>
<pre><code>##               0         1         2         3         4         5         6         7
## [1,] 0.06820411 0.1171835 0.1331324 0.1360701 0.1363485 0.1363554 0.1363497 0.1363562</code></pre>
<p>Tenemos que la CMTD es irreducible, luego por los resultados teóricos tiene una única distribución estacionaria, que coincidirá con la distribución límite y con la distribución de los tiempos de ocupación.</p>
<p>Que el buffer esté lleno significa que nos encontramos en el estado “7,” y al ser la distribución estacionaria la del tiempo de ocupación, tenemos que la fracción de tiempo en que el buffer está lleno es del 13.64%.</p>
<p>El número esperado de paquetes en el buffer en el estado estacionario es un valor esperado calculado con la distribución límite/estacionaria, que al ser discreta se calcula fácilmente a partir de las distribución estacionaria obtenida, esto es,</p>
<div class="sourceCode" id="cb270"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estados</span> <span class="op">&lt;-</span> <span class="fl">0</span><span class="op">:</span><span class="fl">7</span>
<span class="va">distribucion</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates</a></span><span class="op">(</span><span class="va">teleco</span><span class="op">)</span>
<span class="co"># Valor esperado</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">estados</span><span class="op">*</span><span class="va">distribucion</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 3.791421</code></pre>
<p>Por lo tanto, a largo plazo se espera que el buffer esté a un poco más de la mitad de su capacidad.</p>
<div class="example">
<p><span id="exm:unlabeled-div-32" class="example"><strong>Ejemplo 2.11  </strong></span>Consideramos el proceso de <a href="cmtd.html#planificacion">Planificación de mano de obra</a>, donde suponemos que la empresa tiene 70 empleados cuyo nivel no cambia a lo largo del tiempo. Supongamos que los gastos de nómina semanales por persona son de 400 dólares para el grado 1, 600 dólares para el grado 2, 800 dólares para grado 3, y $1000 para el grado 4. Estamos interesados en calcular los gastos semanales promedio por empleado.</p>
</div>
<p>Aplicando el resultado en la Definición <a href="cmtd.html#def:costesestacionarios">2.21</a>, comprobemos que el proceso es irreducible y procedamos a aplicar la fórmula correspondiente, si es el caso.</p>
<div class="sourceCode" id="cb272"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># ¿el proceso es irreducible?</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">planificacion</span><span class="op">)</span></code></pre></div>
<pre><code>## planificacion  Markov chain that is composed by: 
## Closed classes: 
## 1 2 3 4 
## Recurrent classes: 
## {1,2,3,4}
## Transient classes: 
## NONE 
## The Markov chain is irreducible 
## The absorbing states are: NONE</code></pre>
<div class="sourceCode" id="cb274"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Vector de costes</span>
<span class="va">costes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">400</span>, <span class="fl">600</span>, <span class="fl">800</span>, <span class="fl">1000</span><span class="op">)</span>
<span class="co"># distribución estado estacionario</span>
<span class="va">distribucion</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates</a></span><span class="op">(</span><span class="va">planificacion</span><span class="op">)</span>
<span class="co"># gastos esperados por semana</span>
<span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n Gastos semanales:"</span>,<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">distribucion</span><span class="op">*</span><span class="va">costes</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## 
##  Gastos semanales: 618.1818</code></pre>
<p>Por tanto, los gastos semanales promedio por trabajador son de 618.20 dólares, lo que multiplicado por el número de empleados (70) supone 43274 dólares.</p>
</div>
<div id="estudio-de-caso" class="section level2" number="2.6">
<h2>
<span class="header-section-number">2.6</span> Estudio de caso<a class="anchor" aria-label="anchor" href="#estudio-de-caso"><i class="fas fa-link"></i></a>
</h2>
<p>Veamos por último, una aplicación completa del análisis de una CMTD.</p>
<p>Sabemos que en cada idioma las frecuencias de transición entre vocales y consonantes son diferentes. A partir de análisis recurrentes con textos de dos idiomas hemos identificado las probabilidades de transición entre vocales y consonantes en cada uno, estados=(vocal,consonante), y que vienen dadas a continuación.</p>
<p><span class="math display">\[p1=\left(\begin{matrix}
0.51 &amp; 0.49 \\
0.90 &amp; 0.10
\end{matrix}
\right), \qquad 
p2=\left(\begin{matrix}
0.25 &amp; 0.75 \\
0.30 &amp; 0.70
\end{matrix}
\right)\]</span></p>
<p>Definimos primero los procesos para la librería <code>markovchain</code> a partir de las probabilidades de transición.</p>
<div class="sourceCode" id="cb276"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estados</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"vocal"</span>,<span class="st">"consonante"</span><span class="op">)</span>
<span class="co"># matriz de transición idioma1</span>
<span class="va">p1</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.51</span>,<span class="fl">0.49</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span><span class="op">)</span>,byrow <span class="op">=</span> <span class="cn">TRUE</span>,ncol<span class="op">=</span><span class="fl">2</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>,<span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># proceso 1: idioma1</span>
<span class="va">idioma1</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>,states<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">p1</span><span class="op">)</span>,byrow<span class="op">=</span><span class="cn">TRUE</span>,transitionMatrix<span class="op">=</span><span class="va">p1</span>,name<span class="op">=</span><span class="st">"idioma1"</span><span class="op">)</span>
<span class="co"># matriz de transición idioma2</span>
<span class="va">p2</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.25</span>,<span class="fl">0.75</span>,<span class="fl">0.3</span>,<span class="fl">0.7</span><span class="op">)</span>,byrow <span class="op">=</span> <span class="cn">TRUE</span>,ncol<span class="op">=</span><span class="fl">2</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">estados</span>,<span class="va">estados</span><span class="op">)</span><span class="op">)</span>
<span class="co"># proceso 2: idioma2</span>
<span class="va">idioma2</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/methods/new.html">new</a></span><span class="op">(</span><span class="st">"markovchain"</span>,states<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">p2</span><span class="op">)</span>,byrow<span class="op">=</span><span class="cn">TRUE</span>,transitionMatrix<span class="op">=</span><span class="va">p2</span>,name<span class="op">=</span><span class="st">"idioma2"</span><span class="op">)</span>

<span class="co"># y lo mostramos en formato data.frame</span>
<span class="fu"><a href="https://rdrr.io/r/methods/as.html">as</a></span><span class="op">(</span><span class="va">idioma1</span>,<span class="st">"data.frame"</span><span class="op">)</span></code></pre></div>
<pre><code>##           t0         t1 prob
## 1      vocal      vocal 0.51
## 2      vocal consonante 0.49
## 3 consonante      vocal 0.90
## 4 consonante consonante 0.10</code></pre>
<div class="sourceCode" id="cb278"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/methods/as.html">as</a></span><span class="op">(</span><span class="va">idioma2</span>,<span class="st">"data.frame"</span><span class="op">)</span></code></pre></div>
<pre><code>##           t0         t1 prob
## 1      vocal      vocal 0.25
## 2      vocal consonante 0.75
## 3 consonante      vocal 0.30
## 4 consonante consonante 0.70</code></pre>
<p>Verificamos que todos sus estados son recurrentes y la cadena es irreducible.</p>
<div class="sourceCode" id="cb280"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Descripción idioma1\n"</span><span class="op">)</span></code></pre></div>
<pre><code>## Descripción idioma1</code></pre>
<div class="sourceCode" id="cb282"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">idioma1</span><span class="op">)</span></code></pre></div>
<pre><code>## idioma1  Markov chain that is composed by: 
## Closed classes: 
## vocal consonante 
## Recurrent classes: 
## {vocal,consonante}
## Transient classes: 
## NONE 
## The Markov chain is irreducible 
## The absorbing states are: NONE</code></pre>
<div class="sourceCode" id="cb284"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n Descripción idioma2\n"</span><span class="op">)</span></code></pre></div>
<pre><code>## 
##  Descripción idioma2</code></pre>
<div class="sourceCode" id="cb286"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">idioma2</span><span class="op">)</span></code></pre></div>
<pre><code>## idioma2  Markov chain that is composed by: 
## Closed classes: 
## vocal consonante 
## Recurrent classes: 
## {vocal,consonante}
## Transient classes: 
## NONE 
## The Markov chain is irreducible 
## The absorbing states are: NONE</code></pre>
<p>Planteamos ahora una serie de preguntas a responder.</p>
<ol style="list-style-type: decimal">
<li>En cada idioma, ¿cuál es la probabilidad de que si un texto empieza por vocal, el siguiente carácter sea consonante?</li>
</ol>
<p>Calculamos pues, la distribución de los estados del sistema partiendo de una vocal, manualmente y con la función <code><a href="https://rdrr.io/pkg/markovchain/man/transitionProbability.html">transitionProbability()</a></code> o con <code><a href="https://rdrr.io/pkg/markovchain/man/conditionalDistribution.html">conditionalDistribution()</a></code>, que nos da la distribución condicional partiendo de un estado:</p>
<div class="sourceCode" id="cb288"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#determinamos el estado inicial</span>
<span class="va">ini</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span>
<span class="co"># y manualmente evaluamos los productos</span>
<span class="va">final1</span><span class="op">=</span><span class="va">ini</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">p1</span>; <span class="va">final1</span></code></pre></div>
<pre><code>##      vocal consonante
## [1,]  0.51       0.49</code></pre>
<div class="sourceCode" id="cb290"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">final2</span><span class="op">=</span><span class="va">ini</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">p2</span>; <span class="va">final2</span></code></pre></div>
<pre><code>##      vocal consonante
## [1,]  0.25       0.75</code></pre>
<div class="sourceCode" id="cb292"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># o extraemos la distribución condicional partiendo del estado inicial "vocal":</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/conditionalDistribution.html">conditionalDistribution</a></span><span class="op">(</span><span class="va">idioma1</span>,<span class="st">"vocal"</span><span class="op">)</span></code></pre></div>
<pre><code>##      vocal consonante 
##       0.51       0.49</code></pre>
<div class="sourceCode" id="cb294"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/conditionalDistribution.html">conditionalDistribution</a></span><span class="op">(</span><span class="va">idioma2</span>,<span class="st">"vocal"</span><span class="op">)</span></code></pre></div>
<pre><code>##      vocal consonante 
##       0.25       0.75</code></pre>
<div class="sourceCode" id="cb296"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># o usamos la función de la librería markovchain</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/transitionProbability.html">transitionProbability</a></span><span class="op">(</span><span class="va">idioma1</span>,t0<span class="op">=</span><span class="st">"vocal"</span>,t1<span class="op">=</span><span class="st">"consonante"</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.49</code></pre>
<div class="sourceCode" id="cb298"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/transitionProbability.html">transitionProbability</a></span><span class="op">(</span><span class="va">idioma2</span>,t0<span class="op">=</span><span class="st">"vocal"</span>,t1<span class="op">=</span><span class="st">"consonante"</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.75</code></pre>
<p>Resulta que en el idioma1 la probabilidad de que si un texto empieza por vocal el siguiente carácter sea consonante es de 0.49 y en el idioma2 de 0.75.</p>
<ol start="2" style="list-style-type: decimal">
<li>En cada idioma, ¿cuál es la probabilidad de que si un texto empieza por vocal, tras contar 10 caracteres más, encontremos una consonante?</li>
</ol>
<p>Utilizamos el resultado que se mostró en la Ecuación <a href="cmtd.html#eq:matriznpasos">(2.5)</a> para calcular la matriz de transición de <span class="math inline">\(n\)</span> pasos.</p>
<div class="sourceCode" id="cb300"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ini</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span>
<span class="va">final1.10</span> <span class="op">=</span> <span class="va">ini</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">p1</span><span class="op">^</span><span class="fl">10</span>; <span class="va">final1.10</span></code></pre></div>
<pre><code>##            vocal   consonante
## [1,] 0.001190424 0.0007979227</code></pre>
<div class="sourceCode" id="cb302"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">final2.10</span> <span class="op">=</span> <span class="va">ini</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">p2</span><span class="op">^</span><span class="fl">10</span>; <span class="va">final2.10</span></code></pre></div>
<pre><code>##             vocal consonante
## [1,] 9.536743e-07 0.05631351</code></pre>
<p>Las probabilidades ahora se reducen drásticamente, y en el idioma1 resulta de 0.0008, y en el idioma2 de 0.0563.</p>
<ol start="3" style="list-style-type: decimal">
<li>En cada idioma, en a palabra de 5 caracteres que empieza por vocal, ¿cuántas vocales esperamos encontrar? ¿Y si la palabra empieza por consonante?</li>
</ol>
<p>Nos pregunta por el número de visitas o tiempo de ocupación de cada uno de los estados (vocal/consonante) cuando llegamos a 5 caracteres (en 4 transiciones entre caracteres). Calculamos pues la matriz de tiempos de ocupación hasta el instante <span class="math inline">\(n=4\)</span> con la Ecuación <a href="cmtd.html#eq:tposocupa">(2.7)</a>, y para la que utilizamos la función <code>mocupa.proceso()</code> que definimos en la Sección <a href="tiemposocupa-sec">Tiempos de ocupación</a>.</p>
<div class="sourceCode" id="cb304"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">n</span><span class="op">=</span><span class="fl">4</span>
<span class="va">mocupa1</span><span class="op">=</span><span class="fu">mocupa.proceso</span><span class="op">(</span><span class="va">idioma1</span>,<span class="va">n</span><span class="op">)</span>;<span class="va">mocupa1</span></code></pre></div>
<pre><code>##               vocal consonante
## vocal      1.970403   1.905397
## consonante 4.095100   1.111100</code></pre>
<div class="sourceCode" id="cb306"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mocupa2</span><span class="op">=</span><span class="fu">mocupa.proceso</span><span class="op">(</span><span class="va">idioma2</span>,<span class="va">n</span><span class="op">)</span>;<span class="va">mocupa2</span></code></pre></div>
<pre><code>##               vocal consonante
## vocal      1.332031   3.050781
## consonante 1.425100   2.773100</code></pre>
<p>Así, en el idioma1, si partimos de un texto que empieza en vocal, esperamos encontrar 2 vocales y si partimos de una consonante, 4.1 vocales. En el idioma2, si el primer carácter es vocal, encontraré 1.3 vocales y 4 vocales si el texto empieza por consonante.</p>
<ol start="4" style="list-style-type: decimal">
<li>¿Cuántos caracteres habremos de leer por término medio en un texto (en cada idioma) hasta encontrar la primera vocal?</li>
</ol>
<p>Nos están preguntando por el tiempo medio de primer paso por una vocal, partiendo de una consonante. Resolvemos con la función <code><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime()</a></code>.</p>
<div class="sourceCode" id="cb308"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># todos los tiempos de primer paso</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime</a></span><span class="op">(</span><span class="va">idioma1</span><span class="op">)</span></code></pre></div>
<pre><code>##               vocal consonante
## vocal      0.000000   2.040816
## consonante 1.111111   0.000000</code></pre>
<div class="sourceCode" id="cb310"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># tiempo de primer paso por una vocal</span>
<span class="va">mfpt1</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime</a></span><span class="op">(</span><span class="va">idioma1</span>,<span class="st">"vocal"</span><span class="op">)</span>;<span class="va">mfpt1</span></code></pre></div>
<pre><code>## consonante 
##   1.111111</code></pre>
<div class="sourceCode" id="cb312"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime</a></span><span class="op">(</span><span class="va">idioma2</span><span class="op">)</span></code></pre></div>
<pre><code>##               vocal consonante
## vocal      0.000000   1.333333
## consonante 3.333333   0.000000</code></pre>
<div class="sourceCode" id="cb314"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mfpt2</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanFirstPassageTime.html">meanFirstPassageTime</a></span><span class="op">(</span><span class="va">idioma2</span>,<span class="st">"vocal"</span><span class="op">)</span>;<span class="va">mfpt2</span></code></pre></div>
<pre><code>## consonante 
##   3.333333</code></pre>
<p>Tenemos así que el número medio de caracteres que esperamos encontrar en un texto hasta que aparezca por primera vez una vocal en el idioma 1 (partiendo de una consonante) es de 1, y en el idioma2 de 3.</p>
<ol start="5" style="list-style-type: decimal">
<li>En un texto que se inicia con una vocal, ¿con qué probabilidad encontraremos la primera consonante en los siguientes 3 caracteres? Compara los resultados para los dos idiomas.</li>
</ol>
<p>Nos preguntan por la probabilidad de primer paso por el estado “consonante” partiendo de una “vocal” transcurridos tres caracteres. Utilizamos la función <code><a href="https://rdrr.io/pkg/markovchain/man/firstPassageMultiple.html">firstPassageMultiple()</a></code> de la librería <code>markovchain</code>.</p>
<div class="sourceCode" id="cb316"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">n</span><span class="op">=</span><span class="fl">3</span>
<span class="va">fpm1</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/firstPassageMultiple.html">firstPassageMultiple</a></span><span class="op">(</span><span class="va">idioma1</span>,state<span class="op">=</span><span class="st">"vocal"</span>,set<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"consonante"</span><span class="op">)</span>,n<span class="op">=</span><span class="va">n</span><span class="op">)</span>;<span class="va">fpm1</span></code></pre></div>
<pre><code>##        set
## 1 0.490000
## 2 0.249900
## 3 0.127449</code></pre>
<div class="sourceCode" id="cb318"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fpm2</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/firstPassageMultiple.html">firstPassageMultiple</a></span><span class="op">(</span><span class="va">idioma2</span>,state<span class="op">=</span><span class="st">"vocal"</span>,set<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"consonante"</span><span class="op">)</span>,n<span class="op">=</span><span class="va">n</span><span class="op">)</span>;<span class="va">fpm2</span></code></pre></div>
<pre><code>##        set
## 1 0.750000
## 2 0.187500
## 3 0.046875</code></pre>
<p>Así, tenemos que en el idioma1 la probabilidad de que la primera consonante que encontremos esté tres caracteres después de la vocal de inicio es de 0.127449, mientras que esta probabilidad en el idioma2 es sólo de 0.127449.</p>
<ol start="6" style="list-style-type: decimal">
<li>A partir de una consonante, ¿cuántos caracteres, por término medio, tardamos en encontrar otra consonante en cada idioma?</li>
</ol>
<p>Nos están pidiendo el tiempo medio de recurrencia, esto es, volver a encontrar otra consonante si partimos de una consonante, que calculamos con la función <code><a href="https://rdrr.io/pkg/markovchain/man/meanRecurrenceTime.html">meanRecurrenceTime()</a></code>.</p>
<div class="sourceCode" id="cb320"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mrt1</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanRecurrenceTime.html">meanRecurrenceTime</a></span><span class="op">(</span><span class="va">idioma1</span><span class="op">)</span>;<span class="va">mrt1</span></code></pre></div>
<pre><code>##      vocal consonante 
##   1.544444   2.836735</code></pre>
<div class="sourceCode" id="cb322"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mrt2</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanRecurrenceTime.html">meanRecurrenceTime</a></span><span class="op">(</span><span class="va">idioma2</span><span class="op">)</span>;<span class="va">mrt2</span></code></pre></div>
<pre><code>##      vocal consonante 
##        3.5        1.4</code></pre>
<p>Así, en el idioma1, desde la última consonante tendremos aproximadamente 3 caracteres hasta encontrar otra consonante, mientras que en el idioma2 sólo 1 por término medio.</p>
<ol start="7" style="list-style-type: decimal">
<li>¿Qué proporción de vocales y consonantes hay en cada idioma? En un texto de 1000 caracteres que empieza por vocal, ¿cuántas vocales esperamos encontrar? ¿Y consonantes?</li>
</ol>
<p>Para contestar la primera pregunta recurrimos a la distribución estacionaria, que nos da la probabilidad estacionaria para cada uno de los estados posibles, o lo que es lo mismo, la proporción de vocales y consonantes. Para responder la segunda pregunta, puesto que estamos en un texto muy largo con 1000 caracteres, ya no utilizaremos a la matriz de ocupación hasta un instante <span class="math inline">\(n=1000\)</span>, sino la distribución de ocupación, que coincide con la distribución estacionaria.</p>
<p>Sabemos que una CMTD irreducible y aperiódica tiene una única distribución estacionaria, que coincide con la distribución de ocupación. Que es irreducible ya lo comprobamos anteriormente al definir el sistema; verifiquemos pues que es aperiódica, esto es, que su periodo es 1, con la función <code><a href="https://rdrr.io/pkg/markovchain/man/structuralAnalysis.html">period()</a></code>.</p>
<div class="sourceCode" id="cb324"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/structuralAnalysis.html">period</a></span><span class="op">(</span><span class="va">idioma1</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb326"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/structuralAnalysis.html">period</a></span><span class="op">(</span><span class="va">idioma2</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>Así pues, calculamos la distribución estacionaria a continuación con la función <code><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates()</a></code>.</p>
<div class="sourceCode" id="cb328"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pi1</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates</a></span><span class="op">(</span><span class="va">idioma1</span><span class="op">)</span>; <span class="va">pi1</span></code></pre></div>
<pre><code>##         vocal consonante
## [1,] 0.647482   0.352518</code></pre>
<div class="sourceCode" id="cb330"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pi2</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/steadyStates.html">steadyStates</a></span><span class="op">(</span><span class="va">idioma2</span><span class="op">)</span>; <span class="va">pi2</span></code></pre></div>
<pre><code>##          vocal consonante
## [1,] 0.2857143  0.7142857</code></pre>
<p>Tenemos que en el idioma1 el 65% de los caracteres en un texto son vocales, que predominan sobre las consonantes, mientras que en el idioma2 sólo un 29%, y la supremacía es de las consonantes, con un 71.4%.</p>
<p>Para calcular el número esperado de vocales y consonantes en un texto de 1000 caracteres, basta multiplicar estas probabilidades por 1000.</p>
<div class="sourceCode" id="cb332"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">*</span><span class="va">pi1</span><span class="op">)</span></code></pre></div>
<pre><code>##      vocal consonante
## [1,]   647        353</code></pre>
<div class="sourceCode" id="cb334"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">*</span><span class="va">pi2</span><span class="op">)</span></code></pre></div>
<pre><code>##      vocal consonante
## [1,]   286        714</code></pre>
<p>Así, en un texto de 1000 caracteres esperamos 647 vocales en el idioma1 y 286 en el idioma2.</p>
<p>Vamos a comprobar, además, que la distribución estacionaria verifica la ecuación de balance o del estado estacionario que se muestra en la Ecuación <a href="cmtd.html#eq:ecuee">(2.10)</a>.</p>
<div class="sourceCode" id="cb336"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># ecuación de balance para la d.estacionaria del idioma1</span>
<span class="va">pi1</span></code></pre></div>
<pre><code>##         vocal consonante
## [1,] 0.647482   0.352518</code></pre>
<div class="sourceCode" id="cb338"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># es igual a su producto por la matriz de transición</span>
<span class="va">pi1</span><span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span><span class="va">p1</span></code></pre></div>
<pre><code>##         vocal consonante
## [1,] 0.647482   0.352518</code></pre>
<div class="sourceCode" id="cb340"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># y sus probabilidades suman 1</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">pi1</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>Con la distribución estacionaria comprobamos que se verifica la Ecuación <a href="cmtd.html#eq:et-piestacionaria">(2.12)</a> que nos permite calcular los tiempos medios de recurrencia con el inverso de las probabilidades estacionarias. Lo hacemos sólo con el idioma1.</p>
<div class="sourceCode" id="cb342"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fl">1</span><span class="op">/</span><span class="va">pi1</span></code></pre></div>
<pre><code>##         vocal consonante
## [1,] 1.544444   2.836735</code></pre>
<div class="sourceCode" id="cb344"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/meanRecurrenceTime.html">meanRecurrenceTime</a></span><span class="op">(</span><span class="va">idioma1</span><span class="op">)</span></code></pre></div>
<pre><code>##      vocal consonante 
##   1.544444   2.836735</code></pre>
<ol start="8" style="list-style-type: decimal">
<li>Simula un texto de 1000 caracteres para el idioma1, empezando por una vocal y estima con esas simulaciones las probabilidades de transición. Compara los resultados con la matriz inicial.</li>
</ol>
<p>Para simular una CMTD recurrimos a la función <code><a href="https://rdrr.io/pkg/markovchain/man/rmarkovchain.html">rmarkovchain()</a></code>.</p>
<div class="sourceCode" id="cb346"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12</span><span class="op">)</span>
<span class="va">n</span><span class="op">=</span><span class="fl">1000</span>
<span class="va">idioma1.sim</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/rmarkovchain.html">rmarkovchain</a></span><span class="op">(</span><span class="va">n</span>,<span class="va">idioma1</span>,t0<span class="op">=</span><span class="st">"vocal"</span>,include.t0<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<p>Para estimar las probabilidades de transición con los textos simulados vamos a utilizar la librería <code>markovchain</code> que específicamente nos proporciona las frecuencias de salto, así como una estimación (junto con su error), basada en dichas frecuencias, bajo diversos procedimientos de estimación.</p>
<p>La función <code><a href="https://rdrr.io/pkg/markovchain/man/markovchainFit.html">createSequenceMatrix()</a></code> nos proporciona una matriz de frecuencias (absolutas o relativas) de las transiciones entre todos los estados posibles del sistema</p>
<div class="sourceCode" id="cb347"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># frecuencias de transiciones o saltos</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/markovchainFit.html">createSequenceMatrix</a></span><span class="op">(</span><span class="va">idioma1.sim</span><span class="op">)</span></code></pre></div>
<pre><code>##            consonante vocal
## consonante         39   311
## vocal             311   339</code></pre>
<div class="sourceCode" id="cb349"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># frecuencias relativas de transiciones o saltos</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/markovchainFit.html">createSequenceMatrix</a></span><span class="op">(</span><span class="va">idioma1.sim</span>,toRowProbs <span class="op">=</span> <span class="cn">TRUE</span> <span class="op">)</span></code></pre></div>
<pre><code>##            consonante     vocal
## consonante  0.1114286 0.8885714
## vocal       0.4784615 0.5215385</code></pre>
<p>Utilizamos ahora la función <code><a href="https://rdrr.io/pkg/markovchain/man/markovchainFit.html">markovchainFit()</a></code> que, a partir de datos simulados en estado estacionario, estima las probabilidades de transición. Podemos usar varios métodos de optimización alternativos, si bien por defecto se usa la estimación máximo-verosímil, <code>method="mle"</code>. Las alternativas son EMV con suavizado de Laplace (“laplace”), bootstrap (“bootstrap”) y máximo a posteriori (“map”).</p>
<div class="sourceCode" id="cb351"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Estimación de p1</span>
<span class="va">p1.sim</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/markovchainFit.html">markovchainFit</a></span><span class="op">(</span><span class="va">idioma1.sim</span>,byrow<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>
<span class="va">p1.sim</span>;<span class="va">p1</span></code></pre></div>
<pre><code>## $estimate
## MLE Fit 
##  A  2 - dimensional discrete Markov Chain defined by the following states: 
##  consonante, vocal 
##  The transition matrix  (by rows)  is defined as follows: 
##            consonante     vocal
## consonante  0.1114286 0.8885714
## vocal       0.4784615 0.5215385
## 
## 
## $standardError
##            consonante      vocal
## consonante 0.01784285 0.05038626
## vocal      0.02713106 0.02832608
## 
## $confidenceLevel
## [1] 0.95
## 
## $lowerEndpointMatrix
##            consonante     vocal
## consonante 0.07645722 0.7898161
## vocal      0.42528562 0.4660204
## 
## $upperEndpointMatrix
##            consonante     vocal
## consonante  0.1463999 0.9873267
## vocal       0.5316375 0.5770566
## 
## $logLikelihood
## [1] -572.2645</code></pre>
<pre><code>##            vocal consonante
## vocal       0.51       0.49
## consonante  0.90       0.10</code></pre>
<p>Esta función nos proporciona, además de la estimación de las probabilidades de transición, una estimación del error e intervalos de confianza.</p>
<div class="sourceCode" id="cb354"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">estimate</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/methods/as.html">as</a></span><span class="op">(</span><span class="va">p1.sim</span><span class="op">$</span><span class="va">estimate</span>,<span class="st">"data.frame"</span><span class="op">)</span>
<span class="va">error</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="va">p1.sim</span><span class="op">$</span><span class="va">standardError</span><span class="op">)</span>
<span class="va">ic.low</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="va">p1.sim</span><span class="op">$</span><span class="va">lowerEndpointMatrix</span><span class="op">)</span>
<span class="va">ic.up</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="va">p1.sim</span><span class="op">$</span><span class="va">upperEndpointMatrix</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">estimate</span>,<span class="va">error</span>,<span class="va">ic.low</span>,<span class="va">ic.up</span><span class="op">)</span></code></pre></div>
<pre><code>##           t0         t1      prob      error     ic.low     ic.up
## 1 consonante consonante 0.1114286 0.01784285 0.07645722 0.1463999
## 2 consonante      vocal 0.8885714 0.02713106 0.42528562 0.5316375
## 3      vocal consonante 0.4784615 0.05038626 0.78981615 0.9873267
## 4      vocal      vocal 0.5215385 0.02832608 0.46602035 0.5770566</code></pre>
<ol start="9" style="list-style-type: decimal">
<li>Supón que accedes a un texto que transformas en una secuencia de vocales y consonantes (disponible para descarga en <a href="%22https://raw.githubusercontent.com/UMH1477/data/f4e4a62533e24a74be27b8984f9fc23eb1b1ff49/textos.csv%22">Github</a>). Verifica, con dicha secuencia que proviene de una CMTD.</li>
</ol>
<p>Para ello podemos utilizar la función <code><a href="https://rdrr.io/pkg/markovchain/man/statisticalTests.html">verifyMarkovProperty()</a></code> que resuelve un test de hipótesis basado en la Chi-cuadrado, sobre el cumplimiento de la propiedad de Markov con los datos proporcionados. Obtener un p-valor significativo significa que rechazaríamos esa propiedad y por lo tanto rechazaríamos que se trata de una CMTD.</p>
<div class="sourceCode" id="cb356"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># leemos los datos de Github</span>
<span class="va">texto</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/utils/read.table.html">read.csv</a></span><span class="op">(</span><span class="st">"https://raw.githubusercontent.com/UMH1477/data/f4e4a62533e24a74be27b8984f9fc23eb1b1ff49/textos.csv"</span><span class="op">)</span>
<span class="co"># visualizamos el formato de los datos, con 2 columnas de texto</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">texto</span><span class="op">)</span></code></pre></div>
<pre><code>##       texto1     texto2
## 1      vocal consonante
## 2      vocal consonante
## 3 consonante consonante
## 4      vocal      vocal
## 5 consonante consonante
## 6 consonante consonante</code></pre>
<div class="sourceCode" id="cb358"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># y ejecutamos el test sobre una de las columnas de texto</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/statisticalTests.html">verifyMarkovProperty</a></span><span class="op">(</span><span class="va">texto</span><span class="op">$</span><span class="va">texto1</span><span class="op">)</span></code></pre></div>
<pre><code>## Testing markovianity property on given data sequence
## Chi - square statistic is: 2.056533 
## Degrees of freedom are: 5 
## And corresponding p-value is: 0.8412687</code></pre>
<p>El p-valor es de 0.84, que no permite rechazar la propiedad de Markov.</p>
<p>Por último, para testar la estacionariedad, esto es, si <span class="math inline">\(p_{ij}(n)=p_{ij}\)</span> para cualquier <span class="math inline">\(n\)</span>, tenemos la función <code><a href="https://rdrr.io/pkg/markovchain/man/statisticalTests.html">assessStationarity()</a></code>. Obtener un p-valor significativo significa que rechazaríamos esa propiedad y por lo tanto rechazaríamos que se trata de una CMTD.</p>
<div class="sourceCode" id="cb360"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/statisticalTests.html">assessStationarity</a></span><span class="op">(</span><span class="va">texto</span><span class="op">$</span><span class="va">texto1</span>,<span class="fl">5</span><span class="op">)</span></code></pre></div>
<pre><code>## Warning in assessStationarity(texto$texto1, 5): The accuracy of the statistical inference functions
## has been questioned. It will be thoroughly investigated in future versions of the package.</code></pre>
<pre><code>## Warning in chisq.test(mat): Chi-squared approximation may be incorrect

## Warning in chisq.test(mat): Chi-squared approximation may be incorrect</code></pre>
<pre><code>## The assessStationarity test statistic is:  0.0002538706 
## The Chi-Square d.f. are:  8 
## The p-value is:  1</code></pre>
<ol start="10" style="list-style-type: decimal">
<li>Con los datos utilizados en el apartado anterior, verifica si alguno de los textos que se proporcionan en las columnas de la base de datos, se podría asimilar como perteneciente a alguno de los idiomas presentados, idioma1 o idioma2.</li>
</ol>
<p>Para contrastar la similitud entre una secuencia y un proceso teórico que tenemos definido podemos utilizar la función <code><a href="https://rdrr.io/pkg/markovchain/man/statisticalTests.html">verifyEmpiricalToTheoretical()</a></code>. Veamos cómo funciona con los procesos idioma1 e idioma2.</p>
<div class="sourceCode" id="cb364"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># comparamos con el idioma1</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/statisticalTests.html">verifyEmpiricalToTheoretical</a></span><span class="op">(</span><span class="va">texto</span><span class="op">$</span><span class="va">texto1</span>,<span class="va">idioma1</span><span class="op">)</span></code></pre></div>
<pre><code>## Testing whether the
##            vocal consonante
## vocal      32800      31854
## consonante 31854       3491
## transition matrix is compatible with
##            vocal consonante
## vocal       0.51       0.49
## consonante  0.90       0.10
## [1] "theoretical transition matrix"
## ChiSq statistic is 2.460873 d.o.f are 2 corresponding p-value is 0.292165</code></pre>
<pre><code>## $statistic
##    vocal 
## 2.460873 
## 
## $dof
## [1] 2
## 
## $pvalue
##    vocal 
## 0.292165</code></pre>
<p>El p-valor resultante es 0.29, con lo cual no se puede rechazar la hipótesis nula de que la secuencia dada es compatible con el idioma1. Podría ser pues, un texto de dicho idioma</p>
<p>Veamos ahora su compatibilidad con el idioma2:</p>
<div class="sourceCode" id="cb367"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># comparamos con el idioma2</span>
<span class="fu"><a href="https://rdrr.io/pkg/markovchain/man/statisticalTests.html">verifyEmpiricalToTheoretical</a></span><span class="op">(</span><span class="va">texto</span><span class="op">$</span><span class="va">texto1</span>,<span class="va">idioma2</span><span class="op">)</span></code></pre></div>
<pre><code>## Testing whether the
##            vocal consonante
## vocal      32800      31854
## consonante 31854       3491
## transition matrix is compatible with
##            vocal consonante
## vocal       0.25       0.75
## consonante  0.30       0.70
## [1] "theoretical transition matrix"
## ChiSq statistic is 76057.57 d.o.f are 2 corresponding p-value is 0</code></pre>
<pre><code>## $statistic
##    vocal 
## 76057.57 
## 
## $dof
## [1] 2
## 
## $pvalue
## vocal 
##     0</code></pre>
<p>En este caso el p-valor es cero, por lo que rechazamos la compatibilidad y claramente aceptamos que este texto no proviene del idioma2.</p>
</div>
<div id="ejer-u2" class="section level2" number="2.7">
<h2>
<span class="header-section-number">2.7</span> Ejercicios<a class="anchor" aria-label="anchor" href="#ejer-u2"><i class="fas fa-link"></i></a>
</h2>
<div id="básicos-1" class="section level3" number="2.7.1">
<h3>
<span class="header-section-number">2.7.1</span> Básicos<a class="anchor" aria-label="anchor" href="#b%C3%A1sicos-1"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Ejercicio B2.1.</strong> Para el proceso <a href="cmtd.html#meteo">Meteorologia</a> se desea conocer cuál es el tiempo estimado para tener un día lluvioso si hoy tenemos un día soleado.</p>
<p><strong>Ejercicio B2.2.</strong> Para el proceso <a href="cmtd.html#mercadovalores">Mercado de valores</a> se desea conocer cuál es el tiempo estimado en conseguir que las acciones alcancen los valores <span class="math inline">\(8, 9, 10\)</span> partiendo de un valor inicial de <span class="math inline">\(5\)</span>.</p>
<p><strong>Ejercicio B2.3.</strong> Consideramos el proceso <a href="cmtd.html#mercadovalores">Mercado de valores</a>. Supongamos que el gerente financiero ha comprado 100 acciones a 5 dólares, y está interesado en conocer cuál es el beneficio neto esperado de su inversión en 5 días.</p>
<p><strong>Ejercicio B2.4.</strong> En una boutique de café se cambian semanalmente los escaparates, promocionando tres tipos de café A, B y C en función de la demanda que registran. Según ello, la promoción de los tres tipos cambia de una semana a otra de acuerdo a la siguiente matriz de transición:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.3 &amp; 0.3 &amp; 0.4\\
0.1 &amp; 0.5 &amp; 0.4\\
0.3 &amp; 0.2 &amp; 0.5\\
\end{pmatrix}\]</span></p>
<p>Si en la semana 1 se expone el tipo A en el escaparate, ¿cuál es la probabilidad de que en la semana 10 se esté promocionando cualquiera de las tres marcas?</p>
<p><strong>Ejercicio B2.5.</strong> Consideramos el proceso descrito en la sección <a href="cmtd.html#telecomunicaciones">Telecomunicaciones</a>. Asumimos que en el estado inicial el buffer está lleno y deseamos conocer el número esperado de paquetes en el buffer en los instantes <span class="math inline">\(n =1, 2, 5\)</span> y <span class="math inline">\(10\)</span>, asumiendo que el tamaño del buffer es 10 y que el número de paquetes que llegan en un instante es una variable aleatoria <span class="math inline">\(Bi(5, 0.2).\)</span></p>
<p><strong>Ejercicio B2.6.</strong> Consideramos el proceso descrito en la sección <a href="cmtd.html#planificacion">Planificación de mano de obra</a>. Supongamos que la empresa tiene 100 empleados en la semana 1, distribuidos como sigue: 50 en el nivel 1, 25 en el grado 2, 15 en el grado 3, y 10 en el grado 4. Si cada empleado tiene un comportamiento independiente respecto del resto ¿cuál es el número esperado de empleados en cada grado al principio de la semana 4?</p>
<p><strong>Ejercicio B2.7.</strong> Consideramos el proceso descrito en la sección <a href="cmtd.html#inventario">Problema de inventario</a>. Estamos interesados en conocer cuál es la proporción de semanas en que el inventario estará lleno durante el proximo año, si empezamos con un inventario de 5 PCs?</p>
<p><strong>Ejercicio B2.8.</strong> La secuencia de consonantes y vocales en el lenguaje humano se puede modelizar mediante una <span class="math inline">\(CMTD\)</span> dado que después de una vocal siempre le sigue una consonante con probabilidad 0.49 y una vocal con probabilidad 0.51. Después de una consonante hay otra consonante con probabilidad 0.1. Codificamos un texto completo con una secuencia de ceros (vocal) y unos (consonantes). Obtén la matriz de transición para este proceso. Si el texto comienza con una consonante, ¿qué tipo de elemento será el que aparezca en la quinta posición de la secuencia? ¿Qué porcentaje de vocales y consonantes encontraremos en un texto de 2000 letras?</p>
<p><strong>Ejercicio B2.9</strong> Considera el proceso descrito en la sección <a href="cmtd.html#fiabilidad">Fiabilidad de máquinas</a>, con dos máquinas. Supón que ambas máquinas están operativas al principio del día 0. Calcula la probabilidad de que el número de máquinas operativas al principio de los próximos tres días sea 2, 1 y 2, en ese orden.</p>
<p><strong>Ejercicio B2.10</strong>. Calcula la matriz de ocupación <span class="math inline">\(M(10)\)</span>, la distribución límite y la estacionaria, para un proceso CMTD con matriz de transición dada por:</p>
<p><span class="math display">\[P=\begin{pmatrix}
0.1 &amp; 0.3 &amp; 0.2 &amp; 0.4 \\
0.1 &amp; 0.3 &amp; 0.4 &amp; 0.2 \\
0.3 &amp; 0.1 &amp; 0.1 &amp; 0.5 \\
0.15 &amp; 0.25 &amp; 0.35 &amp; 0.25 
\end{pmatrix}\]</span></p>
</div>
<div id="avanzados-1" class="section level3" number="2.7.2">
<h3>
<span class="header-section-number">2.7.2</span> Avanzados<a class="anchor" aria-label="anchor" href="#avanzados-1"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Ejercicio A2.1.</strong> Los artículos llegan a un taller mecánico de forma determinista a un ritmo de uno por minuto. Cada artículo se comprueba antes de cargarlo en la máquina. Un artículo es adecuado con probabilidad <span class="math inline">\(p\)</span> y defectuoso con una probabilidad <span class="math inline">\(1-p\)</span>. Si un artículo es defectuoso, se descarta; en caso contrario, se carga en la máquina. La máquina tarda exactamente 1 minuto en procesar el artículo, tras lo cual está lista para procesar el siguiente. Consideramos la variable aleatoria <span class="math inline">\(X_n\)</span> que toma el valor <span class="math inline">\(0\)</span> si la máquina está inactiva al principio del n-ésimo minuto y 1 si está iniciando el proceso.</p>
<ol style="list-style-type: decimal">
<li>Obtén la matriz de transición de este proceso.</li>
<li>Si <span class="math inline">\(p = 0.98\)</span>, ¿cuál es la proporción de tiempo en que la máquina está cargando un artículo durante las próximas ocho horas?</li>
<li>¿Cuántas horas tendrán que pasar para que la máquina descarte un artículo cuando el primero no se descarta?</li>
</ol>
<p>Supongamos ahora que la máquina puede procesar dos artículos simultáneamente. Sin embargo, tarda 2 minutos en completar el procesamiento. Delante de la máquina hay un contenedor en el que se pueden almacenar dos artículos no defectuosos. En cuanto hay dos artículos en la bandeja, se cargan en la máquina y ésta empieza a procesarlos.</p>
<ol start="4" style="list-style-type: decimal">
<li>Obtén la matriz de transición de este proceso.</li>
<li>¿Cuál es la proporción de tiempo en que la máquina carga artículos durante las próximas ocho horas?</li>
<li>¿Cuántas horas tendrán que pasar para que la máquina descarte dos artículos cuando los dos primeros no son defectuosos?</li>
</ol>
<p><strong>Ejercicio A2.2.</strong> Un vendedor vive en la ciudad “a” y es responsable de la venta de su producto en las ciudades “a,” “b” y ‘c.’ Cada semana tiene que visitar una ciudad diferente. Cuando está en su ciudad natal, le da igual la ciudad que visite a continuación, así que lanza una moneda y si sale cara va a “b” y si sale cruz va a “c.” Sin embargo, después de pasar una semana fuera de casa tiene una ligera preferencia por volver a casa, así que cuando está en las ciudades ‘b’ o ‘c’ lanza dos monedas. Si salen dos caras, se va a la otra ciudad; de lo contrario va a ‘a.’ Las sucesivas ciudades que visita forman una cadena de Markov con un espacio de estados <span class="math inline">\(S = \{a, b, c\}\)</span> en la que la variable aleatoria <span class="math inline">\(X_n\)</span> es igual a ‘a,’ ‘b’ o ‘c’ según su ubicación durante la semana <span class="math inline">\(n\)</span>. Obtén la matriz de transición de este proceso.</p>
<ol style="list-style-type: decimal">
<li>Empezando en su ciudad natal, ¿en qué ciudad se encontrará dentro de seis semanas?</li>
<li>¿Cuál es la proporción de tiempo en que el vendedor se encontrará fuera de casa durante los próximos seis meses?</li>
<li>Si inicialmente está en la ciudad ‘a,’ ¿cuántas semanas tendrán que pasar para que visite la ciudad ‘c?’</li>
<li>Si el vendedor obtiene un beneficio de 1200 euros cuando pasa una semana en la ciudad ‘a,’ de 1200 euros cuando está en ‘b,’ y de 1250 cuando está en ‘c,’ ¿cuál será el beneficio esperado después de 12 semanas si comienza en su ciudad natal?</li>
<li>¿Cuál será el beneficio esperado después de 12 semanas si desconocemos la ciudad de partida pero sabemos que hay una probabilidad de 0.5 que sea ‘a,’ 0.3 de que sea ‘b,’ y 0.2 de que sea ‘c?’</li>
</ol>
<p><strong>Ejercicio A2.3.</strong> Se lleva a cabo un análisis de mercado para conocer las preferencias de compras de coches en formato “renting,” según el cual cada año se renueva el coche a cada cliente del servicio en el mes de enero. La empresa está interesada en conocer si los clientes cambian el estilo de vehículo entre las tres opciones posibles (“sedan,” “station wagon,” y “convertible”) de un año al siguiente. Para estudiar este proceso se toman los datos de cambio de vehículo del último mes de enero:</p>
<div class="inline-table"><table class="table table-sm">
<thead><tr class="header">
<th>Número ventas</th>
<th>Cambio</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>275</td>
<td>sedan for sedan</td>
</tr>
<tr class="even">
<td>180</td>
<td>sedan for station wagon</td>
</tr>
<tr class="odd">
<td>45</td>
<td>sedan for convertible</td>
</tr>
<tr class="even">
<td>80</td>
<td>station wagon for sedan</td>
</tr>
<tr class="odd">
<td>120</td>
<td>station wagon for station wagon</td>
</tr>
<tr class="even">
<td>150</td>
<td>convertible for sedan</td>
</tr>
<tr class="odd">
<td>50</td>
<td>convertible for convertible</td>
</tr>
</tbody>
</table></div>
<p>Este sistema se puede modelizar según una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S = \{s, w, c\}\)</span>.</p>
<ol style="list-style-type: decimal">
<li>Obtén la matriz de transición asociada a este proceso.</li>
<li>¿Cuál es la probabilidad de que un cliente mantenga el mismo tipo de vehículo dentro de tres años? ¿y de cinco?</li>
<li>¿Cuál es el tiempo esperado de permanencia con el mismo tipo de vehículo en los próximos 10 años?</li>
<li>¿Cuál es el tiempo esperado hasta el primer cambio para cualquiera de los tipos considerados?</li>
<li>Si un “sedan” proporciona un beneficio anual de 1200 euros, el “station wagon” de 1500, y el “convertible” de 2500 euros, ¿cuál es el beneficio promedio esperado para un año? ¿y para 5 años?</li>
</ol>
<p><strong>Ejercicio A2.4.</strong> Un proceso de fabricación consiste en dos etapas consecutivas mediante el esquema siguiente:</p>
<ul>
<li>En la etapa 1, el 20% de las piezas son devueltas para su reelaboración, el 10% son desechadas, y el 70% restante pasan a la etapa 2.</li>
<li>En la etapa 2, el 5% de las piezas deben ser devueltas a la etapa 1, el 10% deben ser reelaboradas, el 5% son desechadas, y el 80% restantes se consideran adecuadas para la venta.</li>
</ul>
<ol style="list-style-type: decimal">
<li>Considerando todos los estados del proceso (e1 = etapa 1; e2 = etapa 2; d = desechado; v = venta) construye la matriz de transición correspondiente a este proceso.</li>
</ol>
<p>La estructura de costes del proceso viene dada por:</p>
<ul>
<li>El coste del material que va a entrar entra en la etapa 1 es de 150 euros.</li>
<li>Cada parte que es procesada en la etapa 1 incurre en un coste de 200 euros.</li>
<li>Cada parte que es procesada en la etapa 2 incurre en un coste de 300 euros.</li>
<li>Cada parte que no es rechazada en el etapa 1 pero si es rechazada en l etapa 2 incurre en un coste de 850 euros.</li>
<li>El material que es desechado debe someterse a un proceso de eliminación especial con u coste de 50 euros por parte.</li>
</ul>
<p>El sistema es capaz de tratar suficiente material para generar 100 partes al cabo de un día (aptas para la venta o desechadas).</p>
<ol start="2" style="list-style-type: decimal">
<li>Plantea un algoritmo de simulación que permita responder a cuál es el coste medio del proceso de fabricación para los próximos 15 días. ¿Y la variabilidad estimada de dicho coste?</li>
<li>Si la empresa quiere asegurar un beneficio neto del 5%, ¿a qué precio debe vender las piezas aptas para asegurar dicho beneficio de acuerdo al coste medio estimado del proceso? ¿Cuál sería el rango de venta teniendo en cuenta las fluctuaciones del coste medio?</li>
</ol>
<p><strong>Ejercicio A2.5.</strong> Se lanza un misil al que se le envía una secuencia de señales de corrección de rumbo cuando es necesario. Supongamos que el sistema tiene cuatro estados que se etiquetan como sigue:</p>
<ul>
<li>Estado 0: en rumbo, sin necesidad de correcciones.</li>
<li>Estado 1: correcciones mínimas.</li>
<li>Estado 2: correcciones mayores.</li>
<li>Estado 3: desviación no controlable que hace necesaria la autodestrucción del mísil.</li>
</ul>
<p>Sea <span class="math inline">\(X_n\)</span> que representa el estado del sistema después de la n-ésima corrección, de forma que si el mísil está en curso en el instante <span class="math inline">\(n\)</span> se mantendrá en curso durante todo el vuelo; si necesita una corrección mímima, entonces con probabilidad 0.5 no será necesaria ninguna corrección posterior, con probabilidad 0.25 será necesaria una nueva corrección menor, y con probabilidad 0.25 será necesaria una corrección mayor. Si en el instante <span class="math inline">\(n\)</span> necesitamos una corrección mayor, con probabilidad 0.5 necesitaremos una corrección menor a continuación, con probabilidad 0.25 necesitaremos otra corrección mayor, y con probabilidad 0.25 deberemos abortar la misión.</p>
<ol style="list-style-type: decimal">
<li>¿Cuál es la matriz de transición para este proceso?</li>
<li>Si un mísil necesita una corrección menor al inicio del lanzamiento, ¿cuál será su situación después de 3 correcciones?</li>
</ol>
<p>El mísil gasta 50000 libras de combustible en el lanzamiento, 1000 libras cuando una corrección menor es necesaria, y 5000 cuando una corrección mayor es necesaria. Simula el proceso para tratar de responder a estas preguntas:</p>
<ol start="3" style="list-style-type: decimal">
<li>¿Cuál será el consumo medio de combustible después de 4 correcciones?</li>
<li>¿Y si lanzamos 6 cohetes a la vez?</li>
</ol>
<p><strong>Ejercicio A2.6.</strong> Al comienzo de cada semana, el estado de una máquina se determina midiendo la cantidad de corriente eléctrica que utiliza. En función de su lectura de amperaje, la máquina se clasifica en uno de los cuatro estados siguientes: bajo, medio, alto, fallido. Una máquina en estado bajo tiene una probabilidad de 0.05, 0.03 y 0.02 de estar en el estado medio, alto o fallido, respectivamente, al comienzo de la siguiente semana. Una máquina en estado medio tiene una probabilidad de 0.09 y 0.06 de estar en estado alta o fallida, respectivamente, al inicio de la siguiente semana; no puede, por sí sola, pasar al estado bajo. Una máquina en estado alto tiene una probabilidad de 0.1 de estar en el estado fallido al comienzo de la siguiente semana; no puede, por sí misma, pasar al estado bajo o medio. Si una máquina se encuentra en estado de fallo al comienzo de la semana, se inicia inmediatamente la reparación de la máquina para que (con probabilidad 1) esté en el estado bajo al comienzo de la semana siguiente.</p>
<ol style="list-style-type: decimal">
<li>Modeliza este proceso como una <span class="math inline">\(CMTD\)</span> y obtén la correspondiente matriz de transición.</li>
<li>Si una máquina nueva siempre comienza en el estado bajo, ¿cuál es la probabilidad de que la máquina esté en estado de fallo tras tres semanas?</li>
<li>¿Cuál es la probabilidad de que una máquina nueva tenga al menos un fallo dentro de tres semanas?</li>
<li>En promedio, ¿cuántas semanas al año estará trabajando la máquina?</li>
</ol>
<p>Cada semana que la máquina está en estado bajo, se obtiene un beneficio de 1.000 dólares; cada semana que la máquina está en el estado medio, se obtiene un beneficio de 500 dólares; cada semana que la máquina está en estado alto, se obtiene un beneficio de 400 dólares; y la semana en la que se fija un fallo, se incurre en un coste de 700 dólares.</p>
<ol start="5" style="list-style-type: decimal">
<li>¿Cuál es el beneficio semanal a medio a largo plazo obtenido por la máquina?</li>
</ol>
<p>Se ha sugerido cambiar la política de mantenimiento de la máquina. Si al comienzo de una semana la máquina está en el estado alto, la máquina se deja fuera de servicio y es reparada para que al inicio de la siguiente semana vuelva a estar en el estado bajo. Cuando se realiza una reparación se incurre en un coste de 600 euros.</p>
<ol start="6" style="list-style-type: decimal">
<li>¿Merece la pena esta nueva política de mantenimiento?</li>
</ol>
<p><strong>Ejercicio A2.7.</strong> Nos interesa el traslado de planta de los pacientes dentro de un hospital. A efectos de nuestro análisis, consideraremos que el hospital tiene tres tipos diferentes de plantas: habitaciones de “cuidados generales,” habitaciones de “cuidados especiales” y “cuidados intensivos.” Basándonos en datos anteriores, el 60% de los pacientes que llegan, ingresan inicialmente en la categoría de “cuidados generales,” el 30% en la de “cuidados especiales” y el 10% en la de “cuidados intensivos.” Un paciente de “cuidados generales” tiene un 55% de posibilidades de ser dado de alta sano al día siguiente, un 30% de permanecer en la planta de “cuidados generales,” y un 15% de ser trasladado a la planta de “cuidados especiales.” Un paciente de “cuidados especiales” tiene un 10% de posibilidades de ser dado de alta al día siguiente, un 20% de ser trasladado a “cuidados generales,” un 15% de pasar a “cuidados intensivos.” Un paciente de “cuidados intensivos” nunca es dado de alta, hasta que muestra mejoría. Las probabilidades de que el paciente sea trasladado a “cuidados generales,” “cuidados especiales” o que permanezca en “cuidados intensivos” son del 5%, el 30% o el 55%, respectivamente.</p>
<ol style="list-style-type: decimal">
<li>Modeliza este sistema como una <span class="math inline">\(CMTD\)</span> y obtén la correspondiente matriz de transición.</li>
<li>¿Cuál es la probabilidad de que un paciente ingresado en la sala de cuidados intensivos salga sano del hospital?</li>
<li>¿Cuál es el número esperado de días que un paciente, ingresado en cuidados intensivos pasará en la UCI?</li>
<li>¿Cuál es la duración prevista de la estancia de un paciente ingresado en el hospital como paciente de cuidados generales?</li>
<li>Durante un día normal, ingresan en el hospital 100 pacientes. ¿Cuál es el número medio de pacientes en la UCI?</li>
</ol>
<p><strong>Ejercicio A2.8.</strong> La fabricación de un determinado tipo de placa electrónica consta de cuatro pasos: preparación, montaje, inserción y soldadura. Después de la etapa de montaje, el 5% de las piezas deben ser retiradas; después de la etapa de inserción, el 20% de las piezas son retiradas; y después de la etapa de soldadura, el 30% de las piezas deben ser devueltas a la inserción y el 10% debe desecharse. Suponemos que cuando una pieza se devuelve a una etapa de procesamiento, es tratada como cualquier otra pieza que entra en esa etapa.</p>
<ol style="list-style-type: decimal">
<li>Modeliza este sistema como una <span class="math inline">\(CMTD\)</span> y obtén la correspondiente matriz de transición.</li>
<li>Si un lote de 100 placas comienza este proceso de fabricación, ¿cuántas se espera que acaben desechadas?</li>
<li>¿Con cuántas placas deberíamos empezar si el objetivo es que el número esperado de placas que terminen siendo aceptadas sea igual a 100?</li>
<li>¿Con cuántas placas deberíamos empezar si queremos estar seguros al 90% de que terminamos con un lote de 100 placas?</li>
</ol>
<p>Cada vez que una placa pasa por una etapa de procesamiento, los costes directos de mano de obra y material son de 10 euros para la preparación, 15 euros para el montaje, 25 euros para la inserción y 20 euros para la soldadura. La materia prima cuesta 8 euros, y una placa desechada devuelve 2 euros. La tasa media de gastos generales es de 1.000.000 de euros al año, lo que incluye valores de recuperación de capital. El ritmo de procesamiento medio es de 5.000 placas por semana.</p>
<ol start="5" style="list-style-type: decimal">
<li>Queremos fijar un precio por placa para que los ingresos previstos sean un 25% superiores a los costes previstos. ¿En qué valor debemos fijar el precio?</li>
</ol>
<p><strong>Ejercicio A2.9.</strong> Dentro de un área de mercado determinada hay dos marcas de jabón que la mayoría de la gente utiliza, el “superjabón” y el “jabón barato,” y el mercado actual se divide por igual entre las dos marcas. Una empresa está pensando en introducir una tercera marca llamada “jabón extra limpio,” y ha realizado algunos estudios iniciales sobre las condiciones del mercado. Sus estimaciones de las pautas de compra semanales son las siguientes: si un cliente compra superjabón esta semana, hay un 75% de posibilidades de que la próxima semana vuelva a comprarlo, un 10% de probabilidad de que use el jabón extra limpio y un 15% de probabilidad de que use el jabón barato. Si un cliente compra el jabón extra limpio esta semana, hay un 50% de probabilidades de que cambie, y si lo hace, siempre será al superjabón. Si un cliente compra jabón barato esta semana, es igual de probable que la próxima semana el cliente compre cualquiera de las tres marcas.</p>
<ol style="list-style-type: decimal">
<li>Asumiendo que se cumplen las condiciones de Markov, ¿cuál es la mariz de transición para este proceso?</li>
<li>¿Cuál es la cuota de mercado a largo plazo del nuevo jabón?</li>
<li>¿Cuál será la cuota de mercado del nuevo jabón dos semanas después de su introducción?</li>
</ol>
<p>El mercado consta de aproximadamente un millón de clientes cada semana. Cada compra de superjabón produce un beneficio de 15 céntimos; una compra de jabón barato produce un beneficio de 10 céntimos; y una compra del extra limpio produce un beneficio de 25 céntimos. Supongamos que el mercado se encuentra en estado estacionario con la misma distribución entre los dos productos ya comercializados. La campaña publicitaria inicial para introducir la nueva marca fue de 100.000 dólares.</p>
<ol start="4" style="list-style-type: decimal">
<li>¿Cuántas semanas pasarán hasta que se recuperen los 100.000 dólares de los ingresos añadidos del nuevo producto?</li>
<li>La empresa considera que con estas tres marcas, una campaña publicitaria de 30.000 dólares por semana aumentará el mercado total semanal en un cuarto de millón de clientes? ¿Merece la pena la campaña? (Utiliza un criterio de media a largo plazo).</li>
</ol>
<p><strong>Ejercicio A2.10.</strong> Considera una <span class="math inline">\(CMTD\)</span> con espacio de estados <span class="math inline">\(S=\{a, b, c\}\)</span> y con matriz de transición:</p>
<p><span class="math display">\[P = 
\begin{pmatrix}
0.3 &amp; 0.5 &amp; 0.2\\
0.1 &amp; 0.2 &amp; 0.7\\
0.8 &amp; 0.0 &amp; 0.2\\
\end{pmatrix}\]</span></p>
<p>Cada visita al ‘estado a’ produce un beneficio de 5 dólares, cada visita al ‘estado b’ produce un beneficio de 10 dólares, y cada visita al ‘estado c’ produce un beneficio de 12 dólares.</p>
<ol style="list-style-type: decimal">
<li>Escribir un algoritmo que simule la cadena de Markov para poder estimar el beneficio esperado por paso, asumiendo que la cadena siempre comienza en el ‘estado a.’</li>
<li>Realizar 10 repeticiones del proceso con 25 pasos en cada una y obtener el valor medio del beneficio y rango para las 10 réplicas.</li>
<li>Realizar 10 repeticiones con 1000 pasos en cada una y obtener el valor medio del beneficio y rango para las 10 réplicas.</li>
<li>Comparar las estimaciones y los rangos de los dos escenarios propuestos.</li>
</ol>
</div>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="intro.html"><span class="header-section-number">1</span> Conceptos básicos</a></div>
<div class="next"><a href="poissonprocess.html"><span class="header-section-number">3</span> Proceso de Poisson</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#cmtd"><span class="header-section-number">2</span> Cadenas de Markov de Tiempo Discreto</a></li>
<li><a class="nav-link" href="#definiciones"><span class="header-section-number">2.1</span> Definiciones</a></li>
<li><a class="nav-link" href="#libMC"><span class="header-section-number">2.2</span> Librería markovchain</a></li>
<li>
<a class="nav-link" href="#ExCMTD"><span class="header-section-number">2.3</span> Aplicaciones</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#CM01"><span class="header-section-number">2.3.1</span> Colas de espera</a></li>
<li><a class="nav-link" href="#fiabilidad"><span class="header-section-number">2.3.2</span> Fiabilidad de máquinas</a></li>
<li><a class="nav-link" href="#meteo"><span class="header-section-number">2.3.3</span> Meteorología</a></li>
<li><a class="nav-link" href="#inventario"><span class="header-section-number">2.3.4</span> Problema de inventario</a></li>
<li><a class="nav-link" href="#planificacion"><span class="header-section-number">2.3.5</span> Planificación de mano de obra</a></li>
<li><a class="nav-link" href="#mercadovalores"><span class="header-section-number">2.3.6</span> Mercado de valores</a></li>
<li><a class="nav-link" href="#telecomunicaciones"><span class="header-section-number">2.3.7</span> Telecomunicaciones</a></li>
<li><a class="nav-link" href="#inventario2"><span class="header-section-number">2.3.8</span> Inventario con desabastecimiento</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#CaracCMTD"><span class="header-section-number">2.4</span> Caracterización de una CMTD</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#comunicaci%C3%B3n-entre-estados"><span class="header-section-number">2.4.1</span> Comunicación entre estados</a></li>
<li><a class="nav-link" href="#tiemposocupa-sec"><span class="header-section-number">2.4.2</span> Tiempos de ocupación</a></li>
<li><a class="nav-link" href="#an%C3%A1lisis-de-costes"><span class="header-section-number">2.4.3</span> Análisis de costes</a></li>
<li><a class="nav-link" href="#tiempos-de-primer-paso"><span class="header-section-number">2.4.4</span> Tiempos de primer paso</a></li>
</ul>
</li>
<li><a class="nav-link" href="#AsinCMTD"><span class="header-section-number">2.5</span> Comportamiento a largo plazo</a></li>
<li><a class="nav-link" href="#estudio-de-caso"><span class="header-section-number">2.6</span> Estudio de caso</a></li>
<li>
<a class="nav-link" href="#ejer-u2"><span class="header-section-number">2.7</span> Ejercicios</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#b%C3%A1sicos-1"><span class="header-section-number">2.7.1</span> Básicos</a></li>
<li><a class="nav-link" href="#avanzados-1"><span class="header-section-number">2.7.2</span> Avanzados</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Simulación de Procesos y Sistemas</strong>" was written by true, true. It was last built on 2022-03-09.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
