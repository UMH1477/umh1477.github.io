[{"path":"index.html","id":"antes-de-comenzar","chapter":"Antes de comenzar","heading":"Antes de comenzar","text":"La simulación es una de las herramientas de modelización probabilística más utilizadas en la industria. Se utiliza para el análisis de sistemas existentes y para la selección de sistemas óptimos partir del planteamiento y comparación de diversos escenarios plausibles.Ejemplo 0.1  Por ejemplo, supongamos que un gran supermercado ha estado recibiendo quejas de los clientes sobre el tiempo que pasan en la cola esperando una caja disponible para pagar. La dirección ha decidido añadir algunas cajas más, pero ha de decidir cuántas añadir. Los modelos de simulación pueden ayudar la dirección determinar el número de cajas necesarias para dar un servicio adecuado sus clientes.Aunque el enfoque principal de la Estadística es la construcción de modelos analíticos que describan el funcionamiento de los procesos en función de variables que les afecten, en ocasiones nos puede resultar menos costoso proceder mediante simulación para obtener una predicción razonable de cómo se va comportar el sistema o proceso ante distintas configuraciones de esas variables condicionantes. La simulación permitirá obtener una aproximación del comportamiento del sistema ante distintos escenarios.Ejemplo 0.2  La forma de dar una solución al problema del supermercado mediante simulación podría consistir en escribir un programa informático que genere clientes que lleguen aleatoriamente (con la frecuencia habitual con que lo hacen, o con otras), simular también unos tiempos de permanencia en caja (para realizar los pagos) y evaluar los tiempos de espera para distintas configuraciones del número de cajas abiertas. Se podría así determinar el efecto de tener varias cajas abiertas en función del tráfico de clientes, y así mismo dimensionar con antelación su plantilla, quizás incluso adaptándola diferentes épocas o días, para tener suficientes cajeros ubicados en las cajas.Una razón importante para justificar el uso de la simulación es que puede utilizarse para aumentar la comprensión de un proceso. Es imposible construir un modelo de simulación de un proceso que se entiende cómo funciona, con lo que el mero hecho de desarrollar un modelo de simulación de un proceso especíﬁco forzará comprenderlo.Sin embargo, el aspecto más relevante tener en cuenta al construir un modelo de simulación es que este reproduzca la realidad fielmente, o al menos de la forma más precisa posible. En problemas sencillos, como los que veremos al inicio de este manual, resulta fácil comprobar si los algoritmos de simulación dan buenas soluciones; sin embargo, en sistemas más complejos es trivial asegurar la calidad de las simulaciones obtenidas al reproducir el funcionamiento del sistema que simulan, por lo que será necesario establecer medidas de validación.Para poder abordar sistemas de simulación es necesario tener previamente unos conocimientos básicos de probabilidad, que desarrollamos en la Unidad 1 Conceptos básicos, y partir de los que damos la definición de ‘proceso estocástico.’ Seguimos el camino en la Unidad 2 Cadenas de Markov de Tiempo Discreto con el estudio de las cadenas de Markov de tiempo discreto, los procesos de Poisson en la Unidad 3 Proceso de Poisson, las cadenas de Markov de tiempo continuo en la Unidad 4 Cadenas de Markov de Tiempo Contínuo, y finalizamos con las colas de espera en la Unidad 5 Sistemas de colas.Al final de todas las unidades se proporciona una colección de ejercicios relacionados con los procedimientos estudiados en dicha unidad, para practicar los conceptos estudiados resolviendo problemas generalmente relacionados la realidad. Los ejercicios aparecen etiquetados como B (Básicos), de aplicación directa de conceptos o técnicas, o como (Avanzados), si requieren de una modelización concreta y más tiempo para resolverlos.Todos los ejercicios deben resolverse mediante simulación. Se recomienda identificar las variables involucradas y sus distribuciones, así como construir el algoritmo de simulación (5000 simulaciones y semilla=12), con suficiente detalle y comentarios. El algoritmo de simulación es conveniente que venga desarrollado en función de los parámetros de entrada del problema, de forma que resulte útil para responder las preguntas formuladas y otras que se puedan plantear ante variaciones de las condiciones iniciales.Parte de los contenidos de este curso se han obtenido de la documentación de las diferentes librerías de R utilizadas, y de los libros Mayoral et al.1 Richard M. Feldman Ciriaco Valdez-Flores,2 V. G. Kulkarni3 y Christian P.Robert George Casella.4 Buena parte de los ejercicios y ejemplos propuestos se han obtenido también de los manuales de JosÃ© Pedro GarcÃ­Sabater5 y Ricardo Cao Abad.6","code":""},{"path":"software.html","id":"software","chapter":"Software","heading":"Software","text":"Para poder utilizar el código expuesto en estos materiales es necesario la instalación de los programas R,7 que actúa como lenguaje de programación, y RStudio.8 que actúa como interfaz, y que se pueden descargar desde:R: https://cran.r-project.org/RStudio: https://rstudio.com/Para crear informes directos partir del código utilizado al programar en R con RStudio se recomienda RMarkdown.9A continuación se detallan brevemente las librerías especifícas de R utilizadas en este manual. Conviene tenerlas instaladas y actualizadas todas ellas. El conjunto de librerías útiles en Simulación de Procesos y Sistemas son:tidyverse, en Hadley Wickham et al.10 y Hadley Wickham:11 Es una colección de librerías en R para la ciencia de datos, que comparten una misma filosofía, gramática y estructuras de datos y facilita el tratamiento de datos. Para aprender utilizar estas librerías es recomendable el libro R Data Science de Hadley Wickham Garret Grolemund,12 así como el manual de Malte Grosser.13tidyverse, en Hadley Wickham et al.10 y Hadley Wickham:11 Es una colección de librerías en R para la ciencia de datos, que comparten una misma filosofía, gramática y estructuras de datos y facilita el tratamiento de datos. Para aprender utilizar estas librerías es recomendable el libro R Data Science de Hadley Wickham Garret Grolemund,12 así como el manual de Malte Grosser.13simmer, en Iñaki Ucar, Bart Smeets, Arturo Azcorra,14 IÃ±aki Ucar Bart Smeets,15 Iñaki Ucar Bart Smeets:16 Es una librería R para la simulación de eventos discretos (DES) orientada procesos. Diseñado para ser un marco genérico como SimPy o SimJulia, aprovecha la potencia de Rcpp para aumentar el rendimiento y hacer factible el DES en R. Como característica destacable, simmer explota el concepto de trayectoria: un camino común en el modelo de simulación para entidades del mismo tipo. Es bastante flexible y sencillo de utilizar, y aprovecha el flujo de trabajo de encadenamiento/conducción introducido por el paquete magrittr (Stefan Milton Bache Hadley Wickham17). También utilizaremos las librerías vinculadas simmer.plot, simmer.optim, simmer.json, y simmer.mom.simmer, en Iñaki Ucar, Bart Smeets, Arturo Azcorra,14 IÃ±aki Ucar Bart Smeets,15 Iñaki Ucar Bart Smeets:16 Es una librería R para la simulación de eventos discretos (DES) orientada procesos. Diseñado para ser un marco genérico como SimPy o SimJulia, aprovecha la potencia de Rcpp para aumentar el rendimiento y hacer factible el DES en R. Como característica destacable, simmer explota el concepto de trayectoria: un camino común en el modelo de simulación para entidades del mismo tipo. Es bastante flexible y sencillo de utilizar, y aprovecha el flujo de trabajo de encadenamiento/conducción introducido por el paquete magrittr (Stefan Milton Bache Hadley Wickham17). También utilizaremos las librerías vinculadas simmer.plot, simmer.optim, simmer.json, y simmer.mom.markovchain:18 Librería de R que proporciona clases, métodos y funciones para manejar fácilmente las Cadenas de Markov de Tiempo Discreto (DTMC), realizando análisis probabilísticos y ajustes.markovchain:18 Librería de R que proporciona clases, métodos y funciones para manejar fácilmente las Cadenas de Markov de Tiempo Discreto (DTMC), realizando análisis probabilísticos y ajustes.queueing:19 Proporciona una herramienta versátil para el análisis de los modelos de colas markovianos basados en el nacimiento y la muerte y de las redes de colas monoclase y multiclase.queueing:19 Proporciona una herramienta versátil para el análisis de los modelos de colas markovianos basados en el nacimiento y la muerte y de las redes de colas monoclase y multiclase.queuecomputer, en Anthony Ebert et al.20 y Anthony Ebert:21 Implementación de un método computacionalmente eficiente para simular colas con tiempos de llegada y servicio arbitrarios.queuecomputer, en Anthony Ebert et al.20 y Anthony Ebert:21 Implementación de un método computacionalmente eficiente para simular colas con tiempos de llegada y servicio arbitrarios.Las versiones de las librerías de R utilizadas son las siguientes:Cargamos las librerías de interés que utilizaremos en este manual.Configuramos además el tema de los gráficos para que tengan un aspecto más limpio y más fácil de exportar en formato pdf o word. Para ellos utilizamos la función theme_set().Manuales de referenciaSe recomiendan los siguientes manuales para trabajar con R, RStudio y las librerías proporcionadas:APS 135: Introduction Exploratory Data Analysis R.22 Versión electrónica.APS 135: Introduction Exploratory Data Analysis R.22 Versión electrónica.R Data Science.23 Acceso web.R Data Science.23 Acceso web.Advanced R.24 Versión online y Versión en español.Advanced R.24 Versión online y Versión en español.Tidyverse Cookbook.25 Versión online incompleta.Tidyverse Cookbook.25 Versión online incompleta.ggplot2, part tidyverse26 Acceso web.ggplot2, part tidyverse26 Acceso web.RMarkdown básico.27 Acceso web.RMarkdown básico.27 Acceso web.RMarkdown Cookbook28 Versión online.RMarkdown Cookbook28 Versión online.","code":"\nsessionInfo()## R version 4.1.2 (2021-11-01)\n## Platform: x86_64-apple-darwin17.0 (64-bit)\n## Running under: macOS Big Sur 10.16\n## \n## Matrix products: default\n## BLAS:   /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.0.dylib\n## LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib\n## \n## locale:\n## [1] es_ES.UTF-8/es_ES.UTF-8/es_ES.UTF-8/C/es_ES.UTF-8/es_ES.UTF-8\n## \n## attached base packages:\n## [1] stats     graphics  grDevices utils     datasets  methods   base     \n## \n## other attached packages:\n##  [1] kableExtra_1.3.4    gridExtra_2.3       sjPlot_2.8.10       rootSolve_1.8.2.3  \n##  [5] queuecomputer_1.1.0 queueing_0.2.12     markovchain_0.8.6   diagram_1.6.5      \n##  [9] shape_1.4.6         simmer.plot_0.1.17  simmer.bricks_0.2.1 simmer_4.4.4       \n## [13] forcats_0.5.1       stringr_1.4.0       dplyr_1.0.8         purrr_0.3.4        \n## [17] readr_2.1.2         tidyr_1.2.0         tibble_3.1.6        ggplot2_3.3.5      \n## [21] tidyverse_1.3.1    \n## \n## loaded via a namespace (and not attached):\n##   [1] TH.data_1.1-0      minqa_1.2.4        colorspace_2.0-3   ellipsis_0.3.2     sjlabelled_1.1.8  \n##   [6] estimability_1.3   parameters_0.16.0  fs_1.5.2           rstudioapi_0.13    matlab_1.0.2      \n##  [11] fansi_1.0.2        mvtnorm_1.1-3      lubridate_1.8.0    xml2_1.3.3         codetools_0.2-18  \n##  [16] splines_4.1.2      downlit_0.4.0      cachem_1.0.6       knitr_1.37         sjmisc_2.8.9      \n##  [21] jsonlite_1.8.0     nloptr_2.0.0       ggeffects_1.1.1    broom_0.7.12       dbplyr_2.1.1      \n##  [26] effectsize_0.6.0.1 compiler_4.1.2     httr_1.4.2         sjstats_0.18.1     emmeans_1.7.2     \n##  [31] backports_1.4.1    assertthat_0.2.1   Matrix_1.4-0       fastmap_1.1.0      cli_3.2.0         \n##  [36] formatR_1.11       htmltools_0.5.2    tools_4.1.2        igraph_1.2.11      coda_0.19-4       \n##  [41] gtable_0.3.0       glue_1.6.2         Rcpp_1.0.8         jquerylib_0.1.4    cellranger_1.1.0  \n##  [46] vctrs_0.3.8        svglite_2.1.0      nlme_3.1-155       insight_0.16.0     xfun_0.29         \n##  [51] lme4_1.1-28        rvest_1.0.2        lifecycle_1.0.1    MASS_7.3-55        zoo_1.8-9         \n##  [56] scales_1.1.1       hms_1.1.1          parallel_4.1.2     sandwich_3.0-1     expm_0.999-6      \n##  [61] yaml_2.3.4         memoise_2.0.1      sass_0.4.0         stringi_1.7.6      bayestestR_0.11.5 \n##  [66] boot_1.3-28        systemfonts_1.0.4  rlang_1.0.1        pkgconfig_2.0.3    evaluate_0.15     \n##  [71] lattice_0.20-45    tidyselect_1.1.1   magrittr_2.0.2     bookdown_0.24      R6_2.5.1          \n##  [76] generics_0.1.2     multcomp_1.4-18    DBI_1.1.2          pillar_1.7.0       haven_2.4.3       \n##  [81] withr_2.5.0        survival_3.2-13    datawizard_0.2.3   performance_0.8.0  modelr_0.1.8      \n##  [86] crayon_1.5.0       utf8_1.2.2         tzdb_0.2.0         rmarkdown_2.11     grid_4.1.2        \n##  [91] readxl_1.3.1       webshot_0.5.2      reprex_2.0.1       digest_0.6.29      xtable_1.8-4      \n##  [96] RcppParallel_5.1.5 stats4_4.1.2       munsell_0.5.0      viridisLite_0.4.0  bslib_0.3.1\n# librerías\nlibrary(tidyverse)\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(simmer.plot)\nlibrary(diagram)\nlibrary(markovchain)\nlibrary(queueing)\nlibrary(queuecomputer)\nlibrary(rootSolve)\n# Librerías de entorno gráfico\nlibrary(sjPlot)\nlibrary(gridExtra)\nlibrary(kableExtra)  # y tablas\ntheme_set(theme_sjplot2())"},{"path":"intro.html","id":"intro","chapter":"Unidad 1 Conceptos básicos","heading":"Unidad 1 Conceptos básicos","text":"En esta unidad repasamos los conceptos básicos de probabilidad relacionados con las variables aleatorias y las distribuciones de probabilidad. Presentamos las distribuciones de probabilidad más relevantes, discretas y continuas, y otras estandarizadas, junto con varios algoritmos y funciones de R útiles para simularlas y realizar cálculos de probabilidad. Resolvemos por simulación múltiples problemas basados en los diferentes tipos de variables presentadas. Por último, introducimos la definición de proceso estocástico, con diversos ejemplos, con el fin de preparar el camino para las unidades siguientes, que ya estarán enfocadas en estudiar en profundidad diferentes tipos de procesos estocásticos. Proponemos al final de la unidad más ejercicios y estudios de caso, para que el alumnado practique los conceptos y algoritmos estudiados.","code":""},{"path":"intro.html","id":"variables-aleatorias","chapter":"Unidad 1 Conceptos básicos","heading":"1.1 Variables aleatorias","text":"Introducimos una serie de conceptos básicos.Definición 1.1  Una variable aleatoria es una función que asigna un número real cada uno de los posibles resultados de un experimento o característica de interés susceptibles de ser observados o medidos en una población objetivo.Las variables aleatorias pueden ser discretas o continuas en función de sus posibles valores. Si los valores o resultados posibles se pueden contar (sin ser infinitos), se dice que la variable aleatoria es ‘discreta’; en caso contrario, se dice que es ‘continua.’ Veamos varios ejemplos.Ejemplo 1.1  Un proveedor vende huevos por cajas que contienen 144 huevos. El proveedor desea estudiar el número de huevos que se suelen romper en cada una de las cajas durante el proceso de distribución. Es de interés pues, la variable aleatoria \\(N\\) que contabiliza el número de huevos rotos en una caja, y cuyos valores posibles son \\(0, 1, 2,..., 144\\). Se trata por tanto de una variable de tipo discreto.Ejemplo 1.2  Se desea realizar un estudio para estimar la estatura de los habitantes de una ciudad. Se define la variable aleatoria \\(X\\) como la altura en cm de cada uno de los habitantes de la ciudad. Dado que los posibles resultados son infinitos, diremos que dicha variable es de tipo continuo.Definición 1.2  Se define el espacio probabilístico \\(S\\) asociado una variable aleatoria como el conjunto de todos los valores posibles o con probabilidad que puede tomar dicha variable.","code":""},{"path":"intro.html","id":"función-de-probabilidad","chapter":"Unidad 1 Conceptos básicos","heading":"1.1.1 Función de probabilidad","text":"Para caracterizar completamente cualquier variable aleatoria es necesario definir la función de distribución, que nos da la probabilidad acumulada por debajo de un valor plausible en el espacio probabilístico \\(S\\) en el que está definida dicha variable.Definición 1.3  La función de distribución para una variable \\(X\\) en un punto \\(\\) del espacio probabilístico \\(S\\) se define como la probabilidad acumulada por debajo de dicho valor:\\[\\begin{equation*}\n  F() = P(X \\leq ).\n\\end{equation*}\\]En el caso de variables aleatorias de tipo discreto podemos caracterizar su comportamiento mediante las probabilidades asociadas cada uno de los elementos del espacio probabilístico Esto se hace través de la ‘función puntual de probabilidad’ o ‘función de masa de probabilidad.’Definición 1.4  La función de masa de probabilidad (fmp) para una variable discreta \\(X\\) en un punto \\(\\) del espacio probabilístico \\(S\\) se define como la probabilidad de que la variable \\(X\\) tome dicho valor:\\[\\begin{equation*}\n  f() = P(X = ).\n\\end{equation*}\\]En el caso de variables aleatorias de tipo discreto, la función de distribución de probabilidad se puede obtener partir de la función de masa de probabilidad como:\\[\\begin{equation*}\n  F() = \\sum_{k \\leq } f(k) = 1 - \\sum_{k > } f(k).\n\\end{equation*}\\]para cualquier valor de \\(\\) en \\(S\\).Sim embargo, en las variables aleatorias de tipo continuo es posible asignar una probabilidad cada uno de los infinitos valores de la variable, dado que en ese caso la probabilidad del espacio probabilístico íntegro excedería el valor 1 y por lo tanto sería una probabilidad. En estas variables es preciso definir otra función que permita cuantificar cualquier situación que involucre los resultados del espacio probabilístico \\(S\\) asociado la variable aleatoria. Surge la ‘función de densidad de probabilidad.’Definición 1.5  La función de densidad de probabilidad (fdp), \\(f\\), asociada una variable \\(X\\) de tipo continuo permite calcular la probabilidad acumulada en un intervalo cualesquiera \\((,b]\\) del espacio probabilístico \\(S\\) través de la integral en dicho intervalo:\\[\\begin{equation*}\n  \\int_{}^{b} f(s)ds = Pr(< X \\leq b) = F(b) - F().\n\\end{equation*}\\]De esta forma la ‘función de distribución’ de una variable continua se puede obtener como:\\[\\begin{equation*}\n  F() = \\int_{r_{min}}^{} f(s)ds.\n\\end{equation*}\\]donde \\(r_{min}\\) es el valor mínimo de \\(X\\) en el espacio probabilístico \\(S\\).","code":""},{"path":"intro.html","id":"variables-relevantes","chapter":"Unidad 1 Conceptos básicos","heading":"1.1.2 Variables relevantes","text":"Hay muchas funciones de distribución que se utilizan con tanta frecuencia que se conocen con nombres especiales, y que presentamos en las Secciones Distribuciones Discretas y Distribuciones continuas. Para estas variables resulta bastante sencillo realizar cualquier calculo de probabilidad, ya que la mayoría de programas informáticos tienen implementadas sus funciones de distribución. Utilizaremos obstante la simulación para realizar cálculos probabilísticos.En \\(R\\) se puede acceder directamente la función de densidad, función de distribución, quantiles y simulación de valores de cualquiera de las distribuciones que presentamos continuación mediante las funciones:\\(dXXXX(par)\\): función de densidad,\\(pXXXX(par)\\): función de distribución,\\(qXXXX(par)\\): quantiles,\\(rXXXX(par)\\): generación de valores de la variable,donde \\(XXXX\\) identifica la distribución/variable de interés y \\(par\\) son los parámetros que la caracterizan.","code":""},{"path":"intro.html","id":"media-y-varianza","chapter":"Unidad 1 Conceptos básicos","heading":"1.1.3 Media y varianza","text":"Muchas variables aleatorias tienen funciones de distribución complicadas y, por tanto, es difícil obtener una comprensión intuitiva del comportamiento de la variable conociendo simplemente la función de distribución. Dos medidas, la media o valor esperado y la varianza se definen para ayudar describir el comportamiento de una variable aleatoria. El valor esperado equivale la media aritmética de infinitas observaciones de la variable aleatoria y la varianza es una indicación de la variabilidad o dispersión de los valores de dicha variable.Definición 1.6  Dada una variable aleatoria \\(X\\) discreta sobre un espacio probabilístico \\(S\\), se define el valor esperado o esperanza de \\(X\\), \\(E(X)\\), como\\[E(X) = \\sum_{k \\ S} kf(k)\\]donde \\(f\\) es la fmp de \\(X\\).Cuando \\(X\\) es una variable aleatoria continua, su valor esperado se define partir de la fdp de \\(X\\):\\[E(X) = \\int_S xf(x)dx.\\]Esta definición se puede aplicar cualquier función o transformación de una variable aleatoria, \\(h(X)\\), para obtener su valor esperado \\(E[h(X)]\\), y así por ejemplo en el caso continuo tendríamos:\\[E[h(X)]=\\int_S h(x)f(x)dx.\\]El valor esperado nos da una medida de localización para la variable aleatoria \\(X\\), pero es bien sabido que dichas medidas de localización se deben acompañar siempre de una medida de dispersión, como la varianza o desviación típica.Definición 1.7  Dada una variable aleatoria \\(X\\) con valor esperado \\(E(X)\\) se define la varianza de \\(X\\), \\(V(X)\\) como:partir de la varianza se define la desviación típica de la variable \\(X\\) como la raíz cuadrada de su varianza. Las propiedades siguientes se derivan directamente partir de la definición de esperanza y varianza:Si \\(X\\) e \\(Y\\) son dos variables aleatorias y \\(c\\) una constante, entonces:\\(E(c) = c\\)\\(E(cX) = cE(X)\\)\\(E(X+Y) = E(X) + E(Y)\\)\\(V(cX) = c^2 V(X)\\)","code":""},{"path":"intro.html","id":"APMC","chapter":"Unidad 1 Conceptos básicos","heading":"1.2 Aproximación Monte Carlo","text":"Cuando trabajamos con variables aleatorias, es común el problema de querer estimar el valor esperado de cualquier cantidad \\(h(X)\\), siendo \\(X\\) una variable aleatoria. Utilizando la simulación es posible obtener estimaciones de dichos valores de un modo relativamente sencillo: través de la integración Monte Carlo.Ante un problema genérico relativo calcular el valor esperado de cierta función \\(h(X)\\) para una variable aleatoria con fdp \\(X \\sim f(x)\\),\\[\\begin{equation}\nE[h(X)]=\\int_S h(x) f(x) dx\n\\tag{1.1}\n\\end{equation}\\]donde \\(S\\) denota el conjunto en el que la variable \\(X\\) toma valores,Definición 1.8  Ante el problema de estimar (1.1), el procedimiento de estimación Monte Carlo propone simular una muestra aleatoria de la distribución de \\(X\\), \\(x_1,\\ldots,x_n\\) y con ella obtener una aproximación empírica través del promedio de las cantidades \\(h(x_1),\\ldots,h(x_n)\\),\\[\\begin{equation}\n\\bar{h_n}=\\frac{\\sum_{=1}^n h(x_i)}{n}.\n\\tag{1.2}\n\\end{equation}\\]Por la Ley de los Grandes Números, \\(\\bar{h_n}\\) converge casi seguro la cantidad de interés \\(E[h(X)]\\). Además, cuando \\(h^2(X)\\) tiene un valor esperado finito, la velocidad de convergencia de \\(\\bar{h_n}\\) se puede calcular y la varianza asintótica de la aproximación es \\[Var(\\bar{h_n})=\\frac{1}{n} \\int_S (h(x)-E[h(X)])^2 f(x) dx,\\] que se puede estimar con la muestra \\(x_1,\\ldots,x_n\\) través de\\[\\begin{equation}\nv_n=\\frac{1}{n^2} \\sum_{=1}^n [h(x_i)-\\bar{h_n}]^2.\n\\tag{1.3}\n\\end{equation}\\]Más específicamente, por el Teorema Central del Límite, para \\(n\\) grande tendremos que\\[\\begin{equation}\n\\frac{\\bar{h_n}-E[h(X)]}{\\sqrt{v_n}} \\sim N(0,1),\n\\tag{1.4}\n\\end{equation}\\]lo que permitirá además, construir bandas de confianza para la aproximación Monte Carlo, la que en adelante nos referiremos por “aproximación MC.”\\[\\begin{equation}\nIC_{1-\\alpha}[\\bar{h_n}]=[\\bar{h_n}-z_{1-\\alpha/2} \\sqrt{v_n}, \\bar{h_n}+z_{1-\\alpha/2} \\sqrt{v_n}]\n\\tag{1.5}\n\\end{equation}\\]donde \\(z_{1-\\alpha/2}\\) es el cuantil \\(1-\\alpha/2\\) de una normal estándar, asociado al nivel de confianza \\(1-\\alpha\\).","code":""},{"path":"intro.html","id":"mc-y-probabilidad","chapter":"Unidad 1 Conceptos básicos","heading":"1.2.1 MC y probabilidad","text":"Aunque en las situaciones más sencillas se puede evaluar cualquier probabilidad mediante la correspondiente función de distribución, en muchas ocasiones resulta sencillo obtener una muestra simulada de la variable aleatoria y aproximar dicha probabilidad de interés mediante el denominado estimador Monte-Carlo.Se obtiene la estimación Monte-Carlo (MC) de la probabilidad de que una variable aleatoria \\(X\\) tome algún valor en un conjunto \\(\\) de valores dentro de su espacio probabilístico, \\(Pr(X \\)\\), partir de un conjunto de observaciones o simulaciones \\(x_1, x_2,...,x_N\\) de la variable \\(X\\), mediante el cociente entre el número de simulaciones que están en dicha región \\(\\), y el número de datos disponibles,\\[\\begin{equation}\nPr(X \\) \\approx \\frac{\\#\\{x_1, x_2,...,x_N\\} \\}{N}.\n\\end{equation}\\]Básicamente esta definición se fundamenta en la interpretación empírica de la probabilidad, través del ratio de casos favorables por casos posibles:\\[probabilidad=\\frac{\\mbox{casos favorables}}{\\mbox{casos posibles}}.\\]La fórmula anterior la podemos expresar en notación similar la utilizada en (1.2) definiendo una variable dicotómica \\[I_A(X)=1 \\text{,  si } X \\\\] y 0 en otro caso, de manera que el problema de calcular una probabilidad según una distribución de probabilidad para \\(X\\) se convierte en el valor esperado de una distribución Bernouilli para una distribución de\\[Pr(X \\)=\\int_A f(x)dx=\\int_S I_A(X)f(x)dx=E[I_A(X)]\\] y la estimación MC (1.2) se puede expresar, para un conjunto de \\(n\\) simulaciones \\(x_1,\\ldots,x_n\\), como\\[\\begin{equation}\nPr(X \\)\\approx \\hat{h_n}= \\frac{\\sum_{=1}^n I_A(x_i)}{n},\n\\tag{1.6}\n\\end{equation}\\]y su varianza con\\[\\begin{equation}\nv_n=\\frac{1}{n^2} \\sum_{=1}^n [I_A(x_i)-\\bar{h_n}]^2.\n\\tag{1.7}\n\\end{equation}\\]Ejemplo 1.3  En la situación del ejemplo 1.1, supongamos que disponemos de un conjunto de 200 simulaciones del número de huevos defectuosos en 200 cajas distribuídas. Queremos descubrir, utilizando exclusivamente esas simulaciones:La probabilidad de que una caja tenga más de 3 huevos defectuosos, \\(Pr(X>3)\\).La probabilidad de que una caja tenga lo sumo 3 huevos defectuosos, \\(Pr(X\\leq 3)\\).La probabilidad de que una caja tenga ningún huevo defectuoso, \\(Pr(X=0)\\).La probabilidad de que la proporción de huevos defectuosos en una caja sea inferior al 1%, \\(Pr(X/144 < 0.01)=Pr(X<1.44)\\).Y vamos aproximando por Monte-Carlo las probabilidades de interés, estableciendo las condiciones lógicas en cada situación.El error asociado la estimación de la probabilidad anterior, lo calculamos aplicando (1.7), y también el intervalo de confianza al 95% con (1.5).De esta forma resultará posible estimar cualquier probabilidad asociada una variable aleatoria, aun desconociendo su función de distribución o de probabilidad, siempre que dispongamos de una muestra simulada, y esta estimación será más precisa cuanto mayor sea el tamaño de dicha muestra.","code":"\n# Simulaciones disponibles\ndefectos <- c(2, 2, 0, 0, 0, 2, 1, 2, 1, 4, 1, 0, 0, 2, 4, \n0, 0, 0, 0, 1, 1, 1, 2, 2, 3, 1, 0, 4, 3, 1, 0, \n2, 2, 2, 3, 1, 0, 2, 2, 2, 3, 1, 0, 1, 0, 1, 2, \n0, 0, 2, 3, 2, 3, 2, 4, 4, 0, 1, 1, 3, 0, 0, 3, \n2, 0, 0, 0, 3, 0, 1, 4, 1, 1, 2, 1, 1, 4, 1, 1, \n1, 0, 1, 0, 1, 2, 2, 1, 3, 1, 2, 1, 2, 3, 1, 2, \n5, 1, 1, 1, 1, 0, 1, 1, 1, 2, 1, 0, 0, 1, 2, 2, \n1, 1, 1, 1, 0, 3, 1, 1, 1, 1, 4, 4, 0, 6, 6, 1, \n1, 1, 0, 2, 3, 1, 0, 0, 2, 0, 2, 1, 1, 1, 2, 1, \n1, 1, 1, 2, 5, 0, 1, 3, 1, 1, 4, 1, 2, 1, 1, 0, \n2, 1, 2, 1, 3, 3, 2, 0, 3, 0, 1, 3, 0, 1, 2, 0, \n1, 0, 0, 2, 2, 1, 2, 0, 0, 0, 1, 1, 2, 3, 1, 0, \n1, 0, 1, 1, 1, 1, 1, 5, 3)\n# Número de simulaciones/observaciones\nnsim=length(defectos)\n# Tamaño de la caja\ntamaño <- rep(144,200)\n# Conjunto de datos\nhuevos <- data.frame(tamaño, defectos)\n# Pr(X > 3)\nsel <- dplyr::filter(huevos, defectos >3)\nprob <- nrow(sel)/nsim\ncat(\"Probabilidad estimada [Pr(X > 3)]: \", prob)## Probabilidad estimada [Pr(X > 3)]:  0.075\n# Pr(X <= 3)\nsel <- dplyr::filter(huevos, defectos <= 3)\nprob <- nrow(sel)/nsim\ncat(\"Probabilidad estimada [Pr(X <= 3)]: \", prob)## Probabilidad estimada [Pr(X <= 3)]:  0.925\n# Pr(X = 0)\nsel <- dplyr::filter(huevos, defectos == 0)\nprob <- nrow(sel)/nsim\ncat(\"Probabilidad estimada [Pr(X = 0): \", prob)## Probabilidad estimada [Pr(X = 0):  0.235\n# Pr(X/144 <=0.01)\nsel <- dplyr::filter(huevos, defectos <= (0.01*144))\nprob <- nrow(sel)/nsim\ncat(\"Probabilidad estimada [Pr(X/144 <=0.01): \", prob)## Probabilidad estimada [Pr(X/144 <=0.01):  0.62\nI.a=(huevos$defectos <= 1.44)*1\nprob=mean(I.a)\ncat(\"prob.estim=\",prob)## prob.estim= 0.62\nvn=sum((I.a-prob)^2)/(nsim^2)\nerror=sqrt(vn)\ncat(\"Error Estimado=\",round(error,3))## Error Estimado= 0.034\n# límites del IC redondeados a 3 cifras decimales\nic.low=round(prob-qnorm(0.975)*error,3)\nic.up=round(prob+qnorm(0.975)*error,3)\ncat(\"IC(95%)[AproxMC(prob.estim)]=[\",ic.low,\",\",ic.up,\"]\")## IC(95%)[AproxMC(prob.estim)]=[ 0.553 , 0.687 ]"},{"path":"intro.html","id":"mc-y-momentos","chapter":"Unidad 1 Conceptos básicos","heading":"1.2.2 MC y momentos","text":"Si disponemos de una muestra (de observaciones o simulaciones) lo suficientemente grande de la variable aleatoria \\(X\\) podemos aproximar -de modo razonablemente preciso- el valor esperado y la varianza (o desviación típica) sin más que calcular la media y varianza de los datos que componen la muestra.La precisión de estas estimaciones estará directamente relacionada con el tamaño de la muestra utilizada.Sean \\(x_1, x_2,...,x_N\\) simulaciones disponibles para \\(X\\). Entonces\\[\\begin{eqnarray*}\nE(X) &\\approx& \\bar{x}_N=\\sum_{=1}^N x_i /N \\\\\nVar(X) &\\approx& \\sum_{=1}^N (x_i-\\bar{x}_N)^2/n = \\bar{x}_N^2-\\sum_{=1}^N x_i^2 /N.\n\\end{eqnarray*}\\]Ejemplo 1.4  Con los datos del ejemplo anterior, queremos saber cuál es el número aproximado de huevos que se rompen en cada caja, conocer su dispersión y tener así mismo un intervalo de confianza para la media.","code":"\n# media\nmedia=mean(huevos$defectos)\n# dispersión\nvarianza=var(huevos$defectos)\ndesvtip=sd(huevos$defectos)\n\n# ic para la media\nerror=sqrt(sum((huevos$defectos-media)^2)/(nsim^2))\ncat(\"\\n Error Estimado (media)=\",round(error,3))## \n##  Error Estimado (media)= 0.089\n# límites del IC redondeados a 3 cifras decimales\nic.low=round(media-qnorm(0.975)*error,3)\nic.up=round(media+qnorm(0.975)*error,3)\ncat(\"IC(95%)[AproxMC(media)]=[\",ic.low,\",\",ic.up,\"]\")## IC(95%)[AproxMC(media)]=[ 1.255 , 1.605 ]"},{"path":"intro.html","id":"distribuciones-discretas","chapter":"Unidad 1 Conceptos básicos","heading":"1.3 Distribuciones discretas","text":"Destacamos como principales variables de tipo discreto las siguientes: Bernouilli, Binomial, Geométrica y Poisson.","code":""},{"path":"intro.html","id":"bernouilli","chapter":"Unidad 1 Conceptos básicos","heading":"1.3.1 Bernouilli","text":"Imaginemos una situación experimental donde el resultado de cierta variable que observamos únicamente puede tomar dos valores posibles, denominados “éxito” (codificado con el valor 1) y “fracaso” (codificado con el valor 0). Así pues, la variable aleatoria asociada \\(X\\) verifica que:\\[\\begin{equation}\nPr(X = x) = \n\\begin{cases}\n\\theta & \\text{ si } x = 1 (\\text{ éxito})\\\\\n1- \\theta & \\text{ si } x = 0 (\\text{ fracaso.})\n\\end{cases}\n\\tag{1.8}\n\\end{equation}\\]Definición 1.9  Una variable aleatoria \\(X\\) cuya fmp viene dada por (1.8) se denomina variable Bernouilli, con probabilidad de éxito \\(\\theta\\), y se denota por:\\[X \\sim Ber(\\theta)\\]de forma que \\(E(X) = \\theta\\) y \\(V(X) = \\theta(1-\\theta).\\)Un ejemplo típico de una variable Bernouilli es el lanzamiento de una moneda que sólo tiene dos posibles resultados: cara o cruz. Si la moneda esta equilibrada tenemos que \\(\\theta = 0.5\\) (idéntica probabilidad para cualquiera de los dos resultados), de forma que si definimos por ejemplo el éxito por conseguir cara, tendremos:\\[X = \\text{ Obtener cara } \\sim Ber(0.5)\\]Una distribución \\(Ber(p)\\) es equivalente una distribución binomial con parámetros 1 y p, \\(Bin(1,p)\\), de modo que para simular y realizar cálculos de probabilidad con ella utilizaremos las funciones correspondientes la distribución binomial que vemos continuación.La función dbinom(x,1,prob) nos permite evaluar la \\(Pr(X=x)\\) para una variable Bernoilli con probabilidad de éxito prob.La función pbinom(x,1,prob) nos permite evaluar la \\(Pr(X \\leq x), x=0,1\\).La función rbinom(n,1,prob) permite simular \\(n\\) valores Bernouilli.","code":""},{"path":"intro.html","id":"binomial","chapter":"Unidad 1 Conceptos básicos","heading":"1.3.2 Binomial","text":"Consideramos un experimento Bernouilli que repetimos en \\(n\\) ocasiones, obteniendo en cada repetición sólo dos resultados posibles, “éxito” o “fracaso,” con cierta probabilidad \\(\\theta\\) para el éxito, y contabilizamos el número de éxitos \\(N\\). Los posibles resultados de este experimento son \\(\\{0, 1, 2,...,n\\}\\) éxitos conseguidos en un total de \\(n\\) pruebas. La probabilidad de observar \\(x\\) éxitos en \\(n\\) pruebas viene dada por la función:\\[\\begin{equation}\nPr(N = x) = \\frac{n!}{x!(n-x)!}  \\theta^{x} (1-\\theta)^{n-x}  \\text{ para } x = 0, 1,\\ldots,n,\n\\tag{1.9}\n\\end{equation}\\]con \\(n\\) el número de repeticiones o pruebas Bernouilli realizadas, \\(x\\) el número de éxitos obtenidos, y \\(\\theta\\) la probabilidad de éxito.Definición 1.10  La variable aleatoria \\(N\\) que se obtiene como la suma de \\(n\\) variables Bernouilli independientes con la misma probabilidad de éxito \\(\\theta\\), y cuya función de masa de probabilidad viene dada en (1.9), se denomina variable Binomial de tamaño \\(n\\) y probabilidad de éxito \\(\\theta\\), y se denota por:\\[N \\sim Bi(n,\\theta)\\]con \\(E(N) = n\\theta\\) y \\(V(N) = n\\theta(1-\\theta).\\)continuación se presentan algunos ejemplos de aplicación de la variable Binomial donde representamos tanto la fmp como la función de distribución asociada al problema de interés. Antes mencionamos las funciones de R relacionadas con esta distribución.La función dbinom(x,size,prob) nos permite evaluar la \\(Pr(N=x)\\) para una variable Binomial con tamaño size y probabilidad de éxito prob.pbinom(x,size,prob) permite evaluar la \\(Pr(N \\leq x)\\).rbinom(n,size,prob) permite simular \\(n\\) valores de una variable Binomial de tamaño size y probabilidad de éxito \\(prob\\).Ejemplo 1.5  Estamos revisando en una empresa el comportamiento de las bajas laborales. En base al histórico, se tiene que cada día aproximadamente el 3% de los trabajadores faltan al trabajo alegando una baja laboral. Si el número de trabajadores de la empresa es de 150, queremos saber qué porcentaje de días vamos tener al menos 3 trabajadores de baja.Denotemos por \\(N\\) la variable aleatoria que indica el número de trabajadores de baja en un día cualquiera, e identifiquemos el “éxito” por el hecho de “estar de baja.” Así, podemos asumir que la distribución de \\(N\\) es binomial, con tamaño 50 y probabilidad 0.03.\\[N \\sim Bi(50,0.03).\\]En consecuencia, el valor esperado del número de trabajadores de baja cada día es \\(E(N) = 50 \\cdot 0.03=1.5\\).continuación, en la Figura 1.1 representamos la fmp y la función de distribución asociadas.\nFigura 1.1: Función de masa de probabilidad y Función de distribución para el número de trabajadores de baja un día cualquiera.\nEn la fmp (Figura 1.1-izquierda) podemos ver que en este caso la probabilidad se concentra en muy pocos valores, en concreto por debajo de 10, de modo que antes de llegar \\(x=10\\) la probabilidad acumulada llega al valor 1, como se aprecia en la Figura 1.1-derecha.La probabilidad que nos reclaman en el enunciado es \\[Pr(N\\geq 3)=1-Pr(N \\leq 2),\\] que calculamos y podemos aproximar por MC partir, por ejemplo, de 1000 simulaciones.El error estimado de esta aproximación, que calculamos con la raíz cuadrada de (1.3) esde donde podríamos calcular un intervalo de confianza para la aproximación MC de \\(Pr(N \\geq 3)\\) al 95% utilizando la distribución (1.4) y la fórmula (1.5):Ejemplo 1.6  Una empresa de fabricación produce piezas, de las cuales el 97% están dentro de las especiﬁcaciones y el 3% son defectuosas (fuera de las especiﬁcaciones). Aparentemente hay ningún patrón en la producción de piezas defectuosas. La cadena de producción empaqueta las piezas en cajas de 20 piezas cada una, y produce 1000 cajas al día. Al gerente de la empresa le gustaría estimar el número de cajas con al menos dos piezas defectuosas, de entre todas las que se producen al día durante un día cualquiera.Si \\(N\\) es la variable aleatoria que recoge el número de piezas defectuosas en una caja, tenemos que:\\[N \\sim Bi(20, 0.03)\\]La probabilidad de que una caja tenga al menos dos piezas defectuosas se calcula con \\(p_N=Pr(N \\geq 2)=1-Pr(N\\leq 1)\\).Sin embargo, lo que nos piden es, de un total de 1000 cajas, cuál es el número esperado de cajas con al meos dos piezas defectuosas. Para ello, surge la variable \\(D_N\\) que representa el número de cajas, de un total de 1000, con al menos 2 piezas defectuosas, que es binomial de tamaño 1000 y probabilidad \\(p_N\\),\\[D_N \\sim Bin(1000,p_N),\\]y lo que nos están pidiendo es \\(E(D_N)=1000 p_N\\).Si simulamos con la distribución de \\(N\\) lo acontecido un día, esto es, con 1000 cajas o simulaciones, y contamos el número de cajas con 2 o más piezas defectuosas, obtenemos una aproximación la cantidad que nos piden.El problema es que todos los días son iguales. De hecho si repites los siguientes cálculos varias veces, verás como el resultado varía. La aproximación Monte Carlo habría de considerar simulaciones de la variable \\(D_n\\) , esto es, nsim días, para con ellos poder sacar una conclusión “promedio” de lo que puede ocurrir un día cualquiera.","code":"\n# los valores posibles de la variable Bin(1000,0.03) son\nxs <- 0:50\nn=50\np=0.03\n# Data frame\ndatos <- data.frame(xs = xs, probs = dbinom(xs, n,p), \n                    probsacum = pbinom(xs, n,p))\n# función de masa de probabilidad\ng1 <- ggplot(datos, aes(x=xs, y=probs)) + \n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  ylim(0,0.5) +\n  labs(x =\"x\", y = \"Probabilidad puntual. Pr(N=x)\")\n# función de distribución\ng2 <- ggplot(datos, aes(xs, probsacum)) + \n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  scale_y_continuous(breaks = scales::breaks_extended(10)) +\n  labs(x =\"x\", y =\"Probabilidad acumulada. Pr(N<=x)\")\ngrid.arrange(g1, g2, nrow = 1)\nnsim=1000\nn=50\np=0.03\n# valor real de la probabilidad\nprob=1-pbinom(2,n,p)\ncat(\"Pr(N>=3)=\",round(prob,3))## Pr(N>=3)= 0.189\nset.seed(1234)\n# simulaciones\nI.a=(rbinom(nsim,n,p)>=3)*1  # función indicatriz para la probabilidad requerida\nprob=mean(I.a)\ncat(\"AproxMC=\",prob)## AproxMC= 0.193\nerror=sqrt(sum((I.a-prob)^2)/(nsim^2))\ncat(\"Error.AproxMC=\",round(error,3))## Error.AproxMC= 0.012\n# límites del IC redondeados a 3 cifras decimales\nic.low=round(prob-qnorm(0.975)*error,3)\nic.up=round(prob+qnorm(0.975)*error,3)\ncat(\"IC(95%)[AproxMC]=[\",ic.low,\",\",ic.up,\"]\")## IC(95%)[AproxMC]=[ 0.169 , 0.217 ]\nn=20\np=0.03\nprob=(1 - pbinom(1, n,p))\ncat(\"Probabilidad de que una caja tenga al menos dos defectos=\",prob)## Probabilidad de que una caja tenga al menos dos defectos= 0.119838\nn=20\np=0.03\nsum(rbinom(1000,n,p)>=2)## [1] 99\nnsim=5000 # número de días simulados\nn=1000\np=prob\n# valor real del valor esperado\nmedia=n*p\ncat(\"E(D_N)=\",round(media,3))## E(D_N)= 119.838\n# simulaciones\nxi=rbinom(nsim,n,p)\nm=mean(rbinom(nsim,n,p))\ncat(\"AproxMC=\",m)## AproxMC= 119.7926\n# Error MC\nerror=sqrt(sum((xi-m)^2)/(nsim^2))\n# límites del IC redondeados a 3 cifras decimales\nic.low=round(m-qnorm(0.975)*error,3)\nic.up=round(m+qnorm(0.975)*error,3)\ncat(\"IC(95%)[AproxMC]=[\",ic.low,\",\",ic.up,\"]\")## IC(95%)[AproxMC]=[ 119.51 , 120.076 ]"},{"path":"intro.html","id":"geométrica","chapter":"Unidad 1 Conceptos básicos","heading":"1.3.3 Geométrica","text":"Imaginemos una situación experimental donde se repite un experimento hasta que sucede un “éxito.” En otras palabras, se piensa en \\(\\theta\\) como la probabilidad de éxito para un solo ensayo, y realizamos sucesivamente los ensayos hasta que se produce un éxito. La variable aleatoria \\(N\\) se define entonces como el número de ensayos Bernouilli realizados hasta conseguir un éxito. Nótese que aunque la variable aleatoria geométrica es discreta, su rango es inﬁnito, y su fmp viene dada por:\\[\\begin{equation}\nPr(N = x) = \\theta (1-\\theta)^{x}  \\text{ para } x = \\text{1, 2,...}\n\\tag{1.10}\n\\end{equation}\\]con \\(x\\) el número de repeticiones hasta alcanzar un éxito, y \\(\\theta\\) la probabilidad de éxito.Definición 1.11  La variable aleatoria \\(N\\) cuya función de masa de probabilidad viene dada en (1.10) se denomina variable Geométrica de parámetro \\(\\theta\\), y se denota por:\\[N \\sim Ge(\\theta)\\]Las funciones de R relacionadas con esta distribución se presentan continuación, y tras ello un ejemplo de aplicación de la variable Geométrica.La función dgeom(x, prob) nos permite evaluar la \\(Pr(N=x)\\) para una variable Geométrica con probabilidad de éxito prob.pgeom(x, prob) calcula la función de distribución.rgeom(n, prob) permite generar \\(n\\) valores de una variable Geométrica con probabilidad de éxito \\(prob\\). Los resultados que proporciona son el número de repeticiones realizadas hasta alcanzar el primer éxito.Ejemplo 1.7  Una vendedora de coches ha hecho un análisis estadístico de su historial de ventas anterior y ha determinado que cada día tiene un 10% de probabilidad de vender un coche de lujo. Tras un cuidadoso análisis posterior, también está claro que la venta de un coche de lujo en un día es independiente de la ventas realizadas cualquier otro día. El día de Año Nuevo (un día festivo en el que el concesionario estaba cerrado) la vendedora está intentando predecir cuándo venderá su primer coche de lujo del año.Si consideramos \\(N\\) como la variable aleatoria que indica el día de la primera venta de coches de lujo (N = 1 implica que la venta se realizaría el día 2 de enero), entonces:\\[N \\sim Ge(0.1)\\]En este caso el valor esperado del número de días transcurridos hasta la venta del primer coche de lujo es \\(E(N) = 0.9/0.1 = 9\\) días, con una desviación típica de 9.5 días. Así pues, es posible que el día 10 de enero tenga su primera venta. En la Figura 1.2 se muestran la fmp y la función de distribución asociadas.\nFigura 1.2: Función de masa de probabilidad y Función de distribución para el día en que venderá el primer coche de lujo.\nHacemos continuación un análisis de simulación para aproximar los datos teóricos dados en la definición 1.11. Simulamos 1000 valores de una \\(Ge(0.1)\\), con los que calculamos una aproximación al valor esperado de los días que deben transcurrir para vender un coche de lujo, y construimos un intervalo de confianza para la aproximación MC según (1.5).","code":"\n# Valores de N\nxs <- seq(0, 60, 1)\n# Data frame\ndatos <- data.frame(xs = xs, probs = dgeom(xs, 0.1), \n                    probsacum = pgeom(xs, 0.1))\n# función de masa de probabilidad\ng1 <- ggplot(datos, aes(xs, probs)) + \n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  ylim(0,0.12) +\n  labs(x =\"x\", y = \"Probabilidad puntual. Pr(N=x)\")\n# función de distribución\ng2 <- ggplot(datos, aes(xs, probsacum)) + \n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  scale_y_continuous(breaks = scales::breaks_extended(10)) +\n  labs(x =\"x\", y = \"Probabilidad acumulada Pr(N<=x)\")\ngrid.arrange(g1, g2, nrow = 1)\n# Parámetros de la simulación\n\nset.seed(1970)\nnsim <- 10000\nprob <- 0.1\nmedia<-(1-prob)/prob\ncat(\"E(N)=\",media)## E(N)= 9\n# Valores simulados\ndatos <- rgeom(nsim, prob)\n# Aproximación MC del valor esperado\nm=round(mean(datos),0)\ncat(\"AproxMC=\",m)## AproxMC= 9\n# Error MC\nerror=sqrt(sum((datos-m)^2)/(nsim^2))\n# límites del IC redondeados a 3 cifras decimales\nic.low=round(m-qnorm(0.975)*error,3)\nic.up=round(m+qnorm(0.975)*error,3)\ncat(\"IC(95%)[AproxMC]=[\",ic.low,\",\",ic.up,\"]\")## IC(95%)[AproxMC]=[ 8.811 , 9.189 ]"},{"path":"intro.html","id":"poisson","chapter":"Unidad 1 Conceptos básicos","heading":"1.3.4 Poisson","text":"La distribución de Poisson se emplea como un modelo para variables aleatorias de tipo discreto cuando se quieren obtener las probabilidades de ocurrencia de un evento que se distribuye al azar en el espacio o el tiempo. Algunos ejemplos de esta distribución se presentan continuación.En el estudio de cierto organismo acuático, se toman un gran número de muestras de un lago y se cuenta el número de dichos organismos que aparecen en cada muestra. Podríamos plantear como objetivo el conocer cuál es la probabilidad de encontrar dicho organismo en una próxima muestra si la media observada en el conjunto de muestras es de 2 organismos.En el estudio de cierto organismo acuático, se toman un gran número de muestras de un lago y se cuenta el número de dichos organismos que aparecen en cada muestra. Podríamos plantear como objetivo el conocer cuál es la probabilidad de encontrar dicho organismo en una próxima muestra si la media observada en el conjunto de muestras es de 2 organismos.En un estudio sobre la efectividad de un insecticida sobre cierto tipo de insecto, se fumiga una gran región. Posteriormente se crea una cuadrícula sobre el terreno, se selecciona de forma aleatoria un conjunto de ellas, y se cuenta el número de insectos vivos dentro de cada una. Planteamos como objetivo conocer cuál es la probabilidad de que encontremos ningún insecto vivo en una próxima cuadrícula si se sabe que la media de insectos vivos en las cuadrículas analizadas es de 0.5.En un estudio sobre la efectividad de un insecticida sobre cierto tipo de insecto, se fumiga una gran región. Posteriormente se crea una cuadrícula sobre el terreno, se selecciona de forma aleatoria un conjunto de ellas, y se cuenta el número de insectos vivos dentro de cada una. Planteamos como objetivo conocer cuál es la probabilidad de que encontremos ningún insecto vivo en una próxima cuadrícula si se sabe que la media de insectos vivos en las cuadrículas analizadas es de 0.5.Un grupo de investigadores observó la ocurrencia de hemangioma capilar retiniano (RCH) en pacientes con la enfermedad de von Hippel-Lindau (VHL). RCH es un tumor vascular benigno de la retina. Usando una revisión retrospectiva de series de casos consecutivos, los investigadores encontraron que el número de medio de tumores RCH por ojo para pacientes con VHL era de 4. Están interesados en conocer cuál es la probabilidad de que se detecten más de cuatro tumores por ojo.Un grupo de investigadores observó la ocurrencia de hemangioma capilar retiniano (RCH) en pacientes con la enfermedad de von Hippel-Lindau (VHL). RCH es un tumor vascular benigno de la retina. Usando una revisión retrospectiva de series de casos consecutivos, los investigadores encontraron que el número de medio de tumores RCH por ojo para pacientes con VHL era de 4. Están interesados en conocer cuál es la probabilidad de que se detecten más de cuatro tumores por ojo.La variable aleatoria \\(N\\) se define entonces como el número de eventos que ocurren en un espacio o un tiempo determinados, y viene caracterizada por la denominada tasa de eventos o número medio de eventos que ocurren en el tiempo o espacio, y que se denota habitualmente por \\(\\lambda\\). El rango de esta variable es infinito y su fmp viene dada por:\\[\\begin{equation}\nPr(N = x) = \\frac{e^{-\\lambda}\\lambda^x}{x!}  \\text{ para } x = \\text{1, 2,...}\n\\tag{1.11}\n\\end{equation}\\]con \\(\\lambda\\) es la tasa y \\(x\\) es el número de eventos que han ocurrido.Definición 1.12  La variable aleatoria \\(X\\) cuya función de masa de probabilidad viene dada en (1.11) se denomina variable poisson de parámetro \\(\\lambda > 0\\), y se denota por:\\[N \\sim Po(\\lambda)\\]continuación vemos diferentes ejemplos de uso de la distribución de Poisson, tras presentar las funciones de R relacionadas.La función dpois(x, lambda) nos permite evaluar la \\(Pr(X=x)\\) para una variable poisson de media \\(\\lambda\\).ppois(x, lambda) calcula la función de distribución.rpois(n, lambda) permite generar \\(n\\) valores de una variable Poisson con media \\(\\lambda\\). Los resultados que proporciona son el número de eventos que ocurren en el tiempo o espacio determinado.Ejemplo 1.8  Una empresa de asesoramiento está realizando el análisis del funcionamiento de una panadería y ha estimado que el número medio de barras de pan que se venden en un periodo de media hora es de 12. La empresa está interesada en saber cuál es la capacidad de venta en cada franja de diez minutos (pues es prácticamente el tiempo de horneado), y también cuál es la probabilidad de que el número de barras que se venden en diez minutos sea exactamente de tres.Como nuestro interés radica en un periodo de diez minutos y el número de intervalos de diez minutos en un periodo de 30 minutos es tres, tenemos que el número medio de barras puestas la venta en ese periodo viene dado por:\\[\\lambda = 12/3 = 4.\\]La variable aleatoria que reproduce el número de barras que se venden en una franja de cinco minutos es:\\[N \\sim Po(4)\\]En este caso el valor esperado del número de barras que se venden es 4 y la desviación típica es igual 2(\\(=\\sqrt{4}\\)). En la Figura 1.3 se muestran la fmp y la función de distribución asociadas.\nFigura 1.3: Función de masa de probabilidad y Función de distribución para el número de barras de pan que se venden cada cinco minutos.\nPodemos reconoder en la Figura 1.3-izquierda los valores más probables con las barras más altas (3 y 4). De hecho, en la Figura 1.3-derecha, la probabilidad de que lo sumo se vendan menos de 5 barras es algo superior 0.6.Para calcular la probabilidad pretendida, esto es, \\(Pr(N=3)\\) utilizamos la función fmp correspondiente en R y la aproximamos por MC con 1000 simulaciones, dando también una banda de confianza.Si la aproximación la hacemos con 10 veces más simulaciones, el intervalo de estimación resultará más preciso:Ejemplo 1.9  Una empresa de fabricación de galletas de chocolate está analizando la calidad en su empresa para responder del mejor modo posible sus clientes. Para ello ha fijado que con probabilidad 0.8 las galletas deben contener al menos tres trozos de chocolate para satisfacer las exigencias de los clientes. Se trata pues de fijar el valor medio de trozos de chocolate que debe ir suministrando en la cadena de producción para cumplir con el nivel de exigencia establecido.Si \\(N\\) es la variable aleatoria que indica el número de trozos de chocolate en una galleta, tenemos que:\\[N \\sim Po(\\lambda)\\]donde en este caso el valor de \\(\\lambda\\) es desconocido y representa el número medio de trozos de chocolate en cada galleta. Planteamos un estudio de simulación para aproximar dicho valor.Algoritmo para aproximar el valor de \\(\\lambda\\).Considerar una secuencia de valores de \\(\\lambda_i\\), \\(=1,...,K\\)Obtener una muestra de tamaño \\(nsim\\) para cada distribución \\(Po(\\lambda_i)\\), \\(M_i=\\{x_{i_1},\\ldots,x_{i_{nsim}}\\}\\).Con cada muestra \\(M_i\\) aproximar la probabilidad de que el número de trozos sea mayor o igual 3, \\(p_i\\approx Pr(N_{\\lambda_i}\\geq3)\\).Obtener el valor mínimo de \\(\\lambda\\), de entre \\(\\{\\lambda_1,\\ldots,\\lambda_K\\}\\) que verifica \\(p_i \\geq 0.8\\).En la Figura 1.4 se muestra el proceso de simulación realizado continuación y el resultado obtenido para el valor de \\(\\lambda\\) para cumplir los requisitos de la empresa.\nFigura 1.4: Probabilidad estimada de conseguir al menos 3 trozos de chocolate en cada galleta, en función de lambda.\nAsí pues, el número medio de trozos de chocolate que ha de suministrarse cada galleta ha de ser al menos de 4.25.","code":"\n# Valores de N\nlambda=4\nxs <- seq(0, 10, 1)\n# Data frame\ndatos <- data.frame(xs = xs, probs = dpois(xs, lambda), \n                    probsacum = ppois(xs, lambda))\n# función de masa de probabilidad\ng1 <- ggplot(datos, aes(xs, probs)) + \n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  scale_x_continuous(breaks = 0:10, labels = 0:10) +\n  ylim(0,0.3) +\n  labs(x =\"x\", y = \"Probabilidad puntual. Pr(N=x)\")\n# función de distribución\ng2 <- ggplot(datos, aes(xs, probsacum)) + \n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  scale_x_continuous(breaks = 0:10, labels = 0:10) +\n  scale_y_continuous(breaks = scales::breaks_extended(10)) +\n  labs(x =\"x\", y = \"Probabilidad acumulada Pr(N<=x)\")\ngrid.arrange(g1, g2, nrow = 1)\nlambda=4\n# Probabilidad buscada P(N=3) para la poisson con media 2\nmedia=dpois(3,lambda)\ncat(\"Pr(N=4)=\",round(media,3))## Pr(N=4)= 0.195\nnsim <- 10000\n# Simulamos de la poisson y evaluamos la función indicatriz para la prob de interés\nset.seed(1970)\nI.a <- (rpois(nsim, lambda)==3)*1\n# Realizamos la aproximación MC\nm=mean(I.a)\ncat(\"AproxMC=\",m)## AproxMC= 0.1934\n# Error MC\nerror=sqrt(sum((I.a-m)^2)/(nsim^2))\n# límites del IC redondeados a 3 cifras decimales\nic.low=round(m-qnorm(0.975)*error,3)\nic.up=round(m+qnorm(0.975)*error,3)\ncat(\"IC(95%)[AproxMC]=[\",ic.low,\",\",ic.up,\"]\")## IC(95%)[AproxMC]=[ 0.186 , 0.201 ]\nlambda=4\n# Probabilidad buscada P(N=3) para la poisson con media 2\nmedia=dpois(3,lambda)\ncat(\"Pr(N=4)=\",round(media,3))## Pr(N=4)= 0.195\nnsim <- 10000*10\n# Simulamos de la poisson y evaluamos la función indicatriz para la prob de interés\nset.seed(1970)\nI.a <- (rpois(nsim, lambda)==3)*1\n# Realizamos la aproximación MC\nm=mean(I.a)\ncat(\"AproxMC=\",m)## AproxMC= 0.19375\n# Error MC\nerror=sqrt(sum((I.a-m)^2)/(nsim^2))\n# límites del IC redondeados a 3 cifras decimales\nic.low=round(m-qnorm(0.975)*error,3)\nic.up=round(m+qnorm(0.975)*error,3)\ncat(\"IC(95%)[AproxMC]=[\",ic.low,\",\",ic.up,\"]\")## IC(95%)[AproxMC]=[ 0.191 , 0.196 ]\n# Paso 1\nset.seed(1970)\nnsim <- 5000\nlams <- seq(0.1, 5, 0.01) # valores de lambda\nnlams <- length(lams)     # número de lambdas para evaluar\nprob <- c()  # vector de probabilidades\n\n# Pasos 2 y 3\nfor(i in 1:nlams){\n  datos <- rpois(nsim, lams[i])    \n  prob[i] <- mean(datos >= 3)   \n}\n\n# Paso 4. Resultado del problema\nlambda=lams[min(which(prob >= 0.8))];lambda## [1] 4.25\n# Pintamos los resultados de la simulación realizada\ndat=data.frame(lams=lams,prob=prob)\nggplot(dat,aes(x=lams,y=prob))+\n  geom_point()+\n  geom_hline(yintercept=0.8)+\n  geom_vline(xintercept=lambda)+\n  labs(x=\"lambda\",y=\"Pr(N>=3)\")"},{"path":"intro.html","id":"distribuciones-continuas","chapter":"Unidad 1 Conceptos básicos","heading":"1.4 Distribuciones continuas","text":"En este punto estudiamos las principales variables de tipo continuo. La especificación de estas variables se hace partir de la función de densidad.","code":""},{"path":"intro.html","id":"uniforme","chapter":"Unidad 1 Conceptos básicos","heading":"1.4.1 Uniforme","text":"La distribución uniforme es la distribución de probabilidad continua más sencilla y se refiere eventos infinitos que tienen la misma probabilidad de ocurrir en una intervalo dado. Si \\(\\) y \\(b\\) son dos números reales con \\(< b\\) entonces la función de distribución asociada la probabilidad acumulada la izquierda de cualquier valor \\(x \\[, b]\\) viene dada por:\\[\\begin{equation}\nF(x) = \n\\begin{cases}\n0 & \\text{ si } x < \\\\\n\\frac{x-}{b-} & \\text{ si } \\leq x \\leq b\\\\\n1 & \\text{ si } \\leq x \\leq b.\n\\end{cases}\n\\tag{1.12}\n\\end{equation}\\]Definición 1.13  Una variable aleatoria \\(X\\) tiene una distribución uniforme en el intervalo \\([, b]\\), con $,b R,\\[X \\sim U(,b)\\]si su función de densidad viene dada por la expresión\\[\\begin{equation}\nf(x) = \n\\begin{cases}\n\\frac{1}{b-} & \\text{ si } \\leq x \\leq b\\\\\n0 & \\text{ en otro caso }\n\\end{cases}\n\\tag{1.13}\n\\end{equation}\\]La variable uniforme más famosa es la \\(U(0,1)\\) ya que se utiliza habitualmente para modelizar la incertidumbre sobre una probabilidad desconocida, y es la base para muchos de los algoritmos de simulación de variables y procesos que estudiaremos en el futuro.La función runif(n, , b) permite generar \\(n\\) valores de una variable uniforme en el intervalo \\([, b]\\); runif(n) da una muestra para una distribución uniforme en [0, 1].dunif(x,,b) da la fdp en \\(x\\).punif(x,,b) da la probabilidad acumulada para cualquier punto \\(x \\[,b]\\).","code":""},{"path":"intro.html","id":"exponencial","chapter":"Unidad 1 Conceptos básicos","heading":"1.4.2 Exponencial","text":"La distribución exponencial es una distribución muy común en la modelización probabilística. Esta distribución describe procesos que describen el tiempo entre sucesos consecutivos, con la peculiaridad de que sus probabilidades dependen del instante en que se produzcan los eventos. Es decir:\\[Pr(X > t+s | X > t) = Pr(X > s).\\]Esta propiedad es característica de la distribución exponencial y se denomina “propiedad de la pérdida de memoria.”Ejemplos de este tipo de distribución son:El tiempo que tarda una partícula radiactiva en desintegrarse. El conocimiento de la ley que sigue este evento se utiliza en ciencias para, por ejemplo, la datación de fósiles o cualquier materia orgánica mediante la técnica del carbono 14.El tiempo que tarda una partícula radiactiva en desintegrarse. El conocimiento de la ley que sigue este evento se utiliza en ciencias para, por ejemplo, la datación de fósiles o cualquier materia orgánica mediante la técnica del carbono 14.El tiempo que puede transcurrir en un servicio de urgencias, entre llegadas de pacientes, o en una fábrica entre roturas de una máquina.El tiempo que puede transcurrir en un servicio de urgencias, entre llegadas de pacientes, o en una fábrica entre roturas de una máquina.Esta distribución está muy relacionada con unos procesos que estudiaremos más adelante, denominados Procesos de Poisson.La distribución exponencial viene completamente especificada, través del parámetro \\(\\lambda >0\\) que mide el número esperado de veces que ocurre el evento de interés por cada unidad de tiempo, y cuya función de distribución viene dada por:\\[\\begin{equation}\nF(x) = \n\\begin{cases}\n0 & \\text{ si } x < 0 \\\\\n1 - e^{\\lambda x} & \\text{ si } x \\geq 0.\n\\end{cases}\n\\tag{1.14}\n\\end{equation}\\]Definición 1.14  Una variable aleatoria \\(X\\) tiene una distribución exponencial de parámetro \\(\\lambda\\), que se denota por\\[X \\sim Exp(\\lambda)\\]si su función de densidad viene dada por\\[\\begin{equation}\nf(x)=\\lambda e^{-\\lambda x}, \\quad x \\geq 0,\n\\end{equation}\\]de forma que \\(E(X) = 1/\\lambda\\) y \\(V(X) = 1/\\lambda^2.\\)Las funciones relacionadas con la distribución exponencial en R son:La función dexp(x, lambda) nos permite evaluar la función de densidad para una variable poisson de parámetro \\(\\lambda\\).pexp(x, lambda) nos permite evaluar la función de distribución.rexp(n, lambda) permite generar \\(n\\) valores de una variable Exponencial de parámetro \\(\\lambda\\).continuación estudiamos dos ejemplos de uso de la distribución exponencial. Como siempre presentamos los resultados téoricos y procedemos mediante simulación para ver la aproximación conseguida.Ejemplo 1.10  Se ha comprobado que el tiempo de vida de cierto tipo de marcapasos sigue una distribución exponencial con media 16 años. (1) ¿Cuál es la probabilidad de que una persona la que se le ha implantado este marcapasos se le deba reimplantar otro antes de 20 años? (2) Si el marcapasos lleva funcionando correctamente 5 años en un paciente, ¿cuál es la probabilidad de que haya que cambiarlo antes de 25 años desde que se implantó?Si \\(T\\) es la variable aleatoria que indica el tiempo de vida del marcapasos tenemos que:\\[T \\sim Exp(\\lambda = 1/16)\\]Se puede reponder fácilmente las preguntas planteadas sin más que hacer uso de la función pexp(). Sin embargo, también simularemos para aproximarlas. Hemos de calcular(1). Si es preciso implantar antes de 20 años, es porque el tiempo de vida va ser superior 20. Hemos de calcular pues, \\(Pr(T \\leq 20)\\). (2). Nos piden \\(Pr(T \\leq 25|T>5)=Pr(T\\leq 20)\\), por la propiedad de la pérdida de memoria. Es decir, respondiendo (1) tendremos respondidas las dos preguntas formuladas.\nFigura 1.5: Función de densidad del tiempo de vida del marcapasos (en años)\nObtenemos la probabilidad deseada:La probabilidad de que el marcapasos dure más de 20 años y haya que reemplazarlo es de 0.289, por lo que efectivamente, es muy recomendable reemplazarlo antes. Sin embargo, al paciente en la pregunta (2) se le daría la misma recomendación, cuando la probabilidad de que el marcapasos dure más de 25 años desde su implante, que sería el tiempo que lo llevaría, es considerablemente inferior, 0.21. es pues recomendable, utilizar esta distribución para modelizar el tiempo de vida de un implante.Ejemplo 1.11  Un motor eléctrico tiene una vida media de 6 años y se modeliza con una distribución exponencial. ¿Cuál debe ser el tiempo de garantía que debe tener el motor si se desea que lo sumo el 15 % de los motores fallen antes de que expire su garantía?Si \\(T\\) es la variable aleatoria que indica el tiempo de vida del producto tenemos que: \\[T \\sim Exp(\\lambda = 1/6).\\]\nEn este caso estamos interesados en encontrar el tiempo para que podamos garantizar que el 85% de los motores siguen funcionando, es decir, buscamos el cuantil 0.15 de la distribución de \\(T\\). Planteamos un análisis de simulación para estimar dicho valor.Para que tan sólo el 15% de los motores necesiten reparación durante el periodo de garantía, debemos establecer una garantía de aproximadamente 1 año.En la Figura 1.6 se representan, para los datos simulados, los cuantiles aproximados versus su probabilidad asociada. Con el gráfico se puede atisbar también el periodo de garantía recomendado.\nFigura 1.6: Tiempo de garantía recomendado en función de la probabilidad de que los motores necesiten reparación.\nCon esta gráfica podemos establecer el tiempo de garantía en función de las especificaciones de la empresa, es decir, fijando el porcentaje de motores que necesitarán reparación.","code":"\nlambda <- 1/16\n# Data frame para la representación gráfica\nsec <- seq(0, 80, by = 0.01)\ndatos<- data.frame(sec = sec, densidad = dexp(sec,lambda))\n# Gráfico función de densidad\nggplot(datos, aes(sec, densidad)) + \n  geom_line() +\n  scale_x_continuous(breaks = seq(0,80,5), labels = seq(0,80,5)) +\n  scale_y_continuous(breaks = scales::breaks_extended(10)) +\n  geom_vline(xintercept = 20, col = \"red\") +\n  labs(x =\"Tiempo de vida del marcapasos (en años)\", \n       y = \"Función de densidad\")\n# Probabilidad real\nlambda=1/16\np=pexp(20,lambda)\ncat(\"Pr(T<=20)=\",round(p,3))## Pr(T<=20)= 0.713\n# Parámetros de la simulación\nset.seed(123)\nnsim <- 5000\n# Simulaciones\ndatos <- rexp(nsim, lambda)\n# Probabilidad de interés\npMC=mean(datos <= 20)\ncat(\"Aprox.MC[Pr(T<=20)]=\",round(pMC,3))## Aprox.MC[Pr(T<=20)]= 0.711\n# Calculamos el valor real para el periodo de garantía\nlambda <- 1/6\nq=qexp(0.15,lambda)\ncat(\"Periodo de garantía recomendado=\",round(q,2))## Periodo de garantía recomendado= 0.98\n# Parámetros de la simulación\nset.seed(123)\nnsim <- 5000\n# simulaciones\ndatos <- rexp(nsim, lambda)\n# cuantil de interés\nqMC=quantile(datos, 0.15)\ncat(\"Periodo de garantía aproximado=\",round(qMC,2))## Periodo de garantía aproximado= 1.02\n# cuantil de interés\nprobs <- seq(0.05, 0.95, by = 0.05)\ncuantiles <- quantile(datos, probs)\ndatoscuan <- data.frame(probs, cuantiles)\n# Gráfico\nggplot(datoscuan, aes(probs,cuantiles)) + \n  geom_line() +\n  scale_x_continuous(breaks = probs, labels = probs) +\n  scale_y_continuous(breaks = scales::breaks_extended(10)) +\n  geom_vline(xintercept = 0.15, col = \"red\") +\n  labs(x =\"Probabilidad\", y = \"Tiempo a la reparación (en años)\")  "},{"path":"intro.html","id":"gamma","chapter":"Unidad 1 Conceptos básicos","heading":"1.4.3 Gamma","text":"La distribución Gamma, al igual que ocurre con la exponencial, se utiliza habitualmente para modelizar variables aleatorias positivas y asimétricas, y sobre todo para describir procesos de eventos que ocurren en el tiempo. La función de densidad de una variable aleatoria Gamma se caracteriza por dos parámetros: \\(\\alpha\\) o parámetro de forma, y \\(\\beta\\) o parámetro de escala. El parámetro de forma se denomina así porque al variar su valor se obtienen diferentes formas para la fdp. La variación del parámetro de escala cambia la forma de la distribución, pero tiende “estirar” o “comprimir” el rango de valores sobre el que se define la probabilidad.Definición 1.15  Una variable aleatoria \\(X\\), con \\(x \\geq 0\\), tiene una distribución Gamma de parámetros \\(\\alpha > 0\\) y \\(\\beta > 0\\), denotada por\\[X \\sim Ga(\\alpha, \\beta)\\]si su función de densidad viene dada por la expresión\\[\\begin{equation}\nf(x) = \\frac{x^{\\alpha -1} e^{-x/\\beta}}{\\beta^{\\alpha} \\Gamma(\\alpha)}; \\quad \\text{ para } x \\geq 0,\n\\tag{1.15}\n\\end{equation}\\]con \\(\\Gamma()\\) la función gamma, de forma que \\(E(X) = \\alpha\\beta\\) y \\(V(X) = \\alpha\\beta^2.\\)Un caso especial de la distribución Gamma es la distribución Erlang, que se denota por \\(X \\sim Erlang(k, \\beta)\\), y que se utiliza habitualmente en la modelización de sistemas de colas de espera. Su función de densidad viene dada por :\\[\\begin{equation}\nf(x) = \\frac{k(kx)^{\\alpha -1} e^{-xk/\\beta}}{\\beta^{k} (k-1)!}; \\quad \\text{ para } x \\geq 0,\n\\tag{1.16}\n\\end{equation}\\]con \\(E(x) = \\beta\\) y \\(V(X) = \\beta^2/k\\). La utilidad de una variable aleatoria Erlang con parámetros \\(k\\) y \\(\\beta\\) es que es el resultado de sumar \\(k\\) variables aleatorias exponenciales (independientes) cada una con media \\(\\beta/k\\). En la modelización de los tiempos relacionados con un proceso industrial, la distribución exponencial suele ser inadecuada porque la desviación estándar es tan grande como la media. Los ingenieros suelen tratar de diseñar sistemas que produzcan una desviación estándar de los tiempos del proceso que resulte significativamente menor que su media. La distribución Erlang tiene esta propiedad: su desviación estándar disminuye medida que aumenta \\(k\\), de modo que los tiempos de proceso con una desviación estándar pequeña menudo suelen ser aproximados por una variable aleatoria Erlang.La función dgamma(x, shape, scale) nos permite evaluar la función de densidad para una variable Gamma.pgamma(x, shape, scale) calcula la función de distribución.rgamma(n, shape, scale) permite generar \\(n\\) valores de una variable Gamma.Para simular un dato de una distribución \\(y \\sim (Erlang(k, \\beta)\\)) generamos \\(k\\) datos exponenciales de \\(x_i \\sim Exp(\\beta/k), =1,\\ldots,k,\\) y calculamos la suma de todos esos valores,\\(y=\\sum_i x_i\\). Repetir este proceso tantas veces como indique el tamaño de la muestra simulada que deseamos para la distribución Erlang.Si disponemos de la media y varianza de los datos resulta muy fácil ajustar los parámetros de la distribución Gamma o Erlang sin más que resolver las ecuaciones que nos dan el valor esperado y la varianza. Si \\(\\bar{x}\\) y \\(s^2\\) son respectivamente la media y varianza, podemos ajustar los parámetros de la Gamma con:\\[ \\beta = s^2/\\bar{x}; \\quad \\alpha = \\bar{x}/\\beta\\]mientras que para la Erlang tenemos:\\[ \\beta = \\bar{x}; \\quad k = \\bar{x}^2/s^2.\\]continuación se presenta la función para generar datos Erlang patir de datos exponenciales:","code":"\n# Función para generar \"nsim\" simulaciones de una Erlang \n# con parámetros k (entero) y beta>0\nrerlang <- function(nsim, k, beta)\n{\n  # verificamos que k es entero\n  if(k%%1 == 0)\n  {\n    # parámetro de la exponencial\n    lambda <- beta/k\n    # Generamos y almacenamos datos exponenciales\n    datosexp <- matrix(rexp(nsim*k, lambda), nrow = nsim)\n    # Obtenemos la muestra de la Erlang\n    datoserl <- apply(datosexp, 1, sum)\n    return(datoserl)\n  }\n  else{\n    cat(\"k debe ser entero\")\n  }\n}"},{"path":"intro.html","id":"weibull","chapter":"Unidad 1 Conceptos básicos","heading":"1.4.4 Weibull","text":"La distribución Weibull se utiliza para describir la resistencia la rotura de diversos materiales o para describir los tiempos de fallo de muchos tipos de sistemas diferentes. La distribución Weibull tiene dos parámetros: un parámetro de escala, \\(\\beta\\) , y un parámetro de forma \\(\\alpha\\), ambos positivos. La funcion de distribución asociada viene dada por:\\[\\begin{equation}\nF(x) = \n\\begin{cases}\n0 & \\text{ si } x < 0 \\\\\n1 - e^{-(x/\\beta)^{\\alpha}} & \\text{ si } x \\geq 0\n\\end{cases}\n\\tag{1.17}\n\\end{equation}\\]Como en el caso de la distribución Gamma el parámetro de forma determina la forma general de la fdp y el parámetro de escala expande o contrae la fdp.Definición 1.16  Una variable aleatoria \\(X\\) tiene una distribución Weibull de parámetros \\(\\alpha>0\\) y \\(\\beta>0\\), que se denota por\\[X \\sim Weib(\\alpha, \\beta)\\]si su función de densidad viene dada por la expresión\\[\\begin{equation}\nf(x)=\\frac{\\alpha}{\\beta}\\frac{x}{\\beta}^{\\alpha-1}e^{-(x/\\beta)^{\\alpha}}, \\quad x \\geq 0.\n\\tag{1.18}\n\\end{equation}\\]El valor esperado y la varianza vienen dados por:\\[E(X) = \\beta \\Gamma(1 + 1/\\alpha); \\quad V(X) = \\beta^2 (\\Gamma(1 + 2/\\alpha) - (\\Gamma(1 + 1/\\alpha))^2).\\]En R tenemos las siguientes funciones relacionadas con la distribución Weibull.La función dweibull(x, shape, scale) nos permite evaluar la función de densidad para una variable Weibullpweibull(x, shape, scale) calcula la función de distribución.rweibull(n, shape, scale) permite generar \\(n\\) valores de una variable Weibull.partir de la media (\\(\\bar{x}\\)) y varianza (\\(S^2\\)) de un conjunto de datos, es posible obtener los parámetros de la distribución Weibull sin más que resolver las ecuaciones:\\[\\begin{eqnarray}\n\\beta &=& \\frac{\\bar{x}}{\\Gamma(1 + 1/ \\alpha)} \\\\\n\\frac{s^2}{\\bar{x}^2} - \\frac{\\Gamma(1+ 2/\\alpha)}{(\\Gamma(1 + 1/ \\alpha))^2} + 1 &=& 0.\n\\tag{1.19}\n\\end{eqnarray}\\]continuación se propone una función que permite obtener los parámetros partir de la media y varianza de los datos, junto con un pequeño ejemplo para verificar su funcionalidad.","code":"\nestima.weibull <- function(m, s)\n{\n  #m=media, s=desviación típica\n  library(rootSolve)\n  # Función para optimizar alpha\n  fun.alpha <- function(a, m, s)\n              {\n                res<- 1 + (s/m)^2 - gamma(1+2/a)/(gamma(1+1/a))^2\n                return(res)\n              }\n  # Obtención de alpha\n    alpha <- round(uniroot(fun.alpha, c(0.1, 10000),m=m,s=s)$root,2)\n  # Obtención de beta\n  beta <- round(m/gamma(1+1/alpha), 2)\n  # Devolvemos alpha y beta\n  return(c(alpha, beta))\n}\n\n# Datos de ejemplo\nm <- 80     # media\ns <- sqrt(50)  # desviación típica\n# Estimación\nres=estima.weibull(m,s)\ncat(\"Weibull alpha=\",res[1],\", Weibull beta=\",res[2])## Weibull alpha= 13.83 , Weibull beta= 83.06"},{"path":"intro.html","id":"normal","chapter":"Unidad 1 Conceptos básicos","heading":"1.4.5 Normal","text":"La distribución normal es la distribución más común, reconocida por la mayoría de personas por su curva en forma de “campana,” y también llamada “campana de Gauss.” Aunque la distribución normal se utiliza mucho en la modelización de procesos y sitemas, es sin duda, la más relevante de las distribuciones aleatorias, ya que representa el supuesto básico distribucional para resolver muchos de los problemas de inferencia estadística habituales, como veremos en la sección final de esta unidad.Definición 1.17  Una variable aleatoria \\(X\\) tiene una distribución Normal de parámetros \\(\\mu\\) y \\(\\sigma\\) con \\(\\sigma >0\\), denotada por\\[ X \\sim N(\\mu, \\sigma^2),\\]si su función de densidad viene dada por\\[\\begin{equation}\nf(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} exp\\left(\\frac{-(x-\\mu)^2}{2\\sigma^2}\\right), \\quad x \\R\n\\end{equation}\\]con \\(E(X) = \\mu\\) y \\(V(X) = \\sigma^2\\), y que se denota:El parámetro \\(\\mu\\) identifica la media, y por lo tanto el centro de la distribución al ser simétrica, y el parámetro \\(\\sigma\\) la desviación típica.El caso más destacado es la denominada distribución Normal estándar, para la que \\(\\mu = 0\\) y \\(\\sigma = 1\\), por su utilización en problemas inferenciales sencillos donde la variabilidad es conocida.partir de cualquier distribución Normal podemos transformar una distribución Normal estándar. Si \\(X \\sim N(\\mu, \\sigma^2)\\) entonces la variable aleatoria \\(Z\\) definida como\\[Z = \\frac{X - \\mu}{\\sigma} \\sim N(0,1).\\]Vinculadas la distribución Normal surgen las distribuciones \\(t\\) de Student, Chi-chadrado y \\(F\\) de Snedecor (también llamada de Fisher-Snedecor), que son ampliamente utilizadas en inferencia estadística. En el último apartado de esta unidad veremos cómo utilizar estas distrbuciones para resolver mediante simulación problemas de intervalos de confianza o contrastes de hipótesis.Si \\(\\bar{X_n}=\\sum_i X_i/n\\) representa la media muestral de \\(n\\) v.. \\(N(\\mu,\\sigma)\\) y \\(S^2=\\sum_i(X_i-\\bar{X_n})^2/(n-1)\\) su varianza muestral, entonces la variable \\(Y\\) \\[ Y= \\frac{\\bar{X_n}-\\mu}{S/\\sqrt{n}}\\sim St(n-1)\\] sigue una distribución t de Student con \\(n-1\\) grados de libertad, y se denota por \\(Y\\sim St(n-1)\\).Si tenemos un conjunto de variables normales estándar independientes, \\(X_i\\sim N(0,1), =1,\\ldots,n\\), entonces su suma al cuadrado sigue una distribución chi-cuadrado con \\(n\\) grados de libertad. \\[Z=\\sum_{=1}^n X_i^2 \\sim \\chi^2_{n}\\] Por último, partir de dos distribuciones chi-cuadrado independientes, \\(U\\sim \\chi^2_n\\) y \\(V\\sim \\chi^2_m\\), tenemos que su cociente, corregido por sus grados de libertad, sigue una distribución F de Snedecor con \\(n\\) y \\(m\\) grados de libertad, \\[ W=\\frac{U/n}{V/m} \\sim F_{(n,m)}.\\]Para la distribución Normal,La función dnorm(x, mean, sd) nos permite evaluar la función de densidad para una variable Normal.pnorm(x, mean, sd) calcula la función de distribución.rnorm(n, mean, sd) permite generar \\(n\\) valores de una variable Normal.Para la distribución t de Student con \\(df1\\) grados de libertad, las funciones correspondientes son dt(x, df1), pt(x, df1) y rt(n,df1).Para la distribución chi-cuadrado con \\(df1\\) grados de libertad, contamos con las funciones dchisq(x,df1), pchisq(x,df1) y rchisq(n,df1) respectivamente.Para la distribución F de Snedecor con \\(df1\\) y \\(df2\\) grados de libertad, tenemos las correspondencias df(x, df1, df2), pf(x, df1, df2) y rf(n,df1,df2).En la Figura 1.7 aparecen representadas varias distribuciones normales con distinta media y varianza.\nFigura 1.7: Funciones de densidad para varias distribuciones normales.\nEn la Figura 1.8 aparecen representadas varias distribuciones t de Student con distintos grados de libertad.\nFigura 1.8: Funciones de densidad para varias distribuciones T de Student.\nEn la Figura 1.9 aparecen representadas varias distribuciones chi-cuadrado con distintos grados de libertad.\nFigura 1.9: Funciones de densidad para varias distribuciones Chi-cuadrado.\nEn la Figura 1.10 aparecen representadas varias distribuciones F de Snedecor con distintos grados de libertad.\nFigura 1.10: Funciones de densidad para varias distribuciones F-Snedecor.\n","code":"\nx=seq(-10,10,0.1)\ny1=dnorm(x)\ny2=dnorm(x,0,3)\ny3=dnorm(x,2,1)\ny4=dnorm(x,2,3)\ndatos=as.tibble(cbind(x,y1,y2,y3,y4))## Warning: `as.tibble()` was deprecated in tibble 2.0.0.\n## Please use `as_tibble()` instead.\n## The signature and semantics have changed, see `?as_tibble`.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\nlevels=c(\"N(0,1)\"=\"y1\",\"N(0,3)\"=\"y2\",\"N(2,1)\"=\"y3\",\"N(2,3)\"=\"y4\")\ndatos=datos %>%\n  pivot_longer(cols=2:5,names_to=\"tipo\",values_to=\"valor\") \ndatos$tipo=fct_recode(datos$tipo,!!!levels)\n\nggplot(datos,aes(x=x,y=valor,color=tipo))+\n  geom_line()+\n  labs(color=\"Distribuciones\",y=\"Función de densidad\")\nx=seq(-5,5,0.1)\ny1=dt(x,2)\ny2=dt(x,5)\ny3=dt(x,10)\ny4=dnorm(x)\ndatos=as.tibble(cbind(x,y1,y2,y3,y4))\nlevels=c(\"St(2)\"=\"y1\",\"St(5)\"=\"y2\",\"St(10)\"=\"y3\",\"N(0,1)\"=\"y4\")\ndatos=datos %>%\n  pivot_longer(cols=2:5,names_to=\"tipo\",values_to=\"valor\") \ndatos$tipo=fct_recode(datos$tipo,!!!levels)\n\nggplot(datos,aes(x=x,y=valor,color=tipo))+\n  geom_line()+\n  labs(color=\"Distribuciones\",y=\"Función de densidad\")\nx=seq(0,200,0.1)\ny1=dchisq(x,5)\ny2=dchisq(x,10)\ny3=dchisq(x,50)\ny4=dchisq(x,100)\ndatos=as.tibble(cbind(x,y1,y2,y3,y4))\nlevels=c(\"Chi2(5)\"=\"y1\",\"Chi2(10)\"=\"y2\",\"Chi2(50)\"=\"y3\",\"Chi2(100)\"=\"y4\")\ndatos=datos %>%\n  pivot_longer(cols=2:5,names_to=\"tipo\",values_to=\"valor\") \ndatos$tipo=fct_recode(datos$tipo,!!!levels)\n\nggplot(datos,aes(x=x,y=valor,color=tipo))+\n  geom_line()+\n  labs(color=\"Distribuciones\",y=\"Función de densidad\")\nx=seq(0,5,0.01)\ny1=df(x,5,5)\ny2=df(x,1,5)\ny3=df(x,50,10)\ny4=df(x,100,200)\ndatos=as.tibble(cbind(x,y1,y2,y3,y4))\nlevels=c(\"F(5,5)\"=\"y1\",\"F(1,5)\"=\"y2\",\"F(50,10)\"=\"y3\",\"F(100,200)\"=\"y4\")\ndatos=datos %>%\n  pivot_longer(cols=2:5,names_to=\"tipo\",values_to=\"valor\") \ndatos$tipo=fct_recode(datos$tipo,!!!levels)\n\nggplot(datos,aes(x=x,y=valor,color=tipo))+\n  geom_line()+\n  labs(color=\"Distribuciones\",y=\"Función de densidad\")"},{"path":"intro.html","id":"transformadainversa","chapter":"Unidad 1 Conceptos básicos","heading":"1.5 Simular con la Transformada Inversa","text":"Aunque las distribuciones estudiadas en el punto anterior, al ser habituales provocan que los algoritmos de simulación y sus funciones de probabilidad ya estén implementadas en la mayoría de los paquetes estadísticos y de cálculo, en otras ocasiones, ante otras distribuciones menos comunes, disponemos de un método directo para la simulación de muestras aleatorias, y necesitamos recurrir algoritmos genéricos de simulación de variables.Presentamos continuación un algoritmo genérico para simular de variables discretas o continuas definidas trozos: el algoritmo de la transformada inversa, que pasamos describir, tanto para variables continuas como para variables discretas.Definición 1.18  Algoritmo de la transformada inversa para variables continuasDada una variable aleatoria \\(X\\) de tipo continuo, cuya función de distribución viene dada por \\(F(x)\\), y cuya función de distribución inversa se denota por \\(F^{-1}(x)\\), el algoritmo de la transformada inversa permite obtener una muestra de tamaño \\(n\\) de la variable \\(X\\) mediante el siguiente procedimiento:Generar \\(n\\) valores uniformes en el intervalo \\([0,1]\\),\\[u_i\\sim U(0,1), \\quad =1,...,n\\]Devolver \\(x_i = F^{-1}(u_i)\\).Así los valores \\(\\{x_1,...,x_n\\}\\) constituyen una muestra de \\(X\\).El algoritmo es conceptualmente similar para variables discretas, si bien por la discretización, varía levemente.Definición 1.19  Algoritmo de la transformada inversa para variables discretasDada una variable aleatoria \\(X\\), de tipo discreto, con \\(k\\) posibles valores diferentes \\(x_1,...,x_k\\), y cuya función de distribución viene dada por:\\[F(x) = Pr(X \\leq x) = \\sum_{x_i \\leq x} Pr(X = x_i), =1,...,k,\\]el algoritmo de la transformada inversa permite obtener una muestra de tamaño \\(n\\) de la variable \\(X\\) mediante el siguiente procedimiento:Generar \\(n\\) valores uniformes en el intervalo \\([0,1]\\), \\[u_i\\sim U(0,1), \\quad =1,...,n\\]Para cada \\(u_i\\) generado se determina el entero \\(\\) más pequeño que satisface \\(u_i \\leq F(x_I)\\), del conjunto \\(\\{x_1,...,x_k\\}\\)Devolver \\(x_I\\) para cada valor simulado.Así los valores \\(\\{x_1,...,x_n\\}\\) constituyen una muestra de \\(X\\).En los puntos siguientes vamos mostrar el uso de los algoritmos 1.18 y 1.19 en diferentes ejemplos de variables de tipo discreto y continuo.","code":""},{"path":"intro.html","id":"otras-distribuciones-discretas","chapter":"Unidad 1 Conceptos básicos","heading":"1.6 Otras distribuciones discretas","text":"Analizamos diferentes ejemplos en los que estamos interesados en evaluar un sistema que involucra una o más variables de tipo discreto, y donde únicamente disponemos de información sobre la función de masa de probabilidad o sobre la función de distribución.","code":""},{"path":"intro.html","id":"una-variable-discreta","chapter":"Unidad 1 Conceptos básicos","heading":"1.6.1 Una variable discreta","text":"Supongamos un sistema en el que contamos con información de una única variable discreta de interés que deseamos estudiar. En los casos más sencillos que tratamos aquí, las situaciones planteadas se pueden resolver teóricamente sin mucha dificultad, pero el objetivo es mostrar el uso de la simulación para llegar resultados aproximados los que proporcionan los métodos análiticos.Ejemplo 1.12  Una empresa que fabrica piezas para maquinaria de fabricación de calzado tiene diseñada la cadena de producción de tal forma que las piezas fabricadas se almacenan (y venden) en cajas de dos unidades. El beneficio estimado de una caja sin defectos es de 300 euros. La política de la empresa establece que si al servir una caja los clientes, esta contiene una pieza defectuosa, debe ser devuelta de forma inmediata para su reemplazo, lo que supone una pérdida de 50 euros por pieza defectuosa (y la devolución de los 300 euros de beneficio por la venta). El problema es que una vez cerradas las cajas en la cadena de producción se inspeccionan para estimar el número de cajas que se podrían devolver. La única información disponible hace referencia la tasa de defectos observada en cada caja cuando esta es devuelta, junto con el porcentaje de cajas que son devueltas. En base esta información, si \\(N\\) refleja el número de piezas defectuosas observadas, la empresa ha establecido que:\\[\\begin{equation}\nPr(N = k) = \n\\begin{cases}\n0.82 & \\text{ para } k = 0\\\\\n0.15 & \\text{ para } k = 1\\\\\n0.03 & \\text{ para } k = 2\\\\\n\\end{cases}\n\\tag{1.20}\n\\end{equation}\\]La empresa quiere estudiar el beneficio estimado de acuerdo la politica de producción actual para el próximo mes, sabiendo que se pueden llegar producir hasta 1500 cajas en ese periodo. Además la empresa está interesada en conocer el beneficio estimado si cambiara su politica de calidad reduciendo su tasa de defectos por caja de acuerdo las siguientes proporciones:\\[\\begin{equation}\nPr(N = k) = \n\\begin{cases}\n0.85 & \\text{ para } k = 0\\\\\n0.13 & \\text{ para } k = 1\\\\\n0.02 & \\text{ para } k = 2\\\\\n\\end{cases}\n\\tag{1.21}\n\\end{equation}\\]Para resolver las inquietudes de la empresa, vamos simular el proceso en las dos situaciones planteadas, para el horizonte propuesto de un mes, esto es, simulando las 1500 cajas y estimando el beneficio obtenido de acuerdo las políticas de calidad dadas en (1.20) y (1.21).Proponemos el siguiente algoritmo de simulación para obtener la ganancia asociada cada una de las políticas de calidad, y con dichas ganancias compararlas y concluir cuál es la más beneficiosa.Algoritmo de simulación Ante una política de calidad:Fijar las condiciones de simulación: nº cajas (\\(nsim = 1500\\)).Obtener las función de distribución acumulada vinculada con la politica de calidad de interés y aplicar el algoritmo dado en al definición 1.19 para obtener una muestra de \\(N\\), \\(x_1,...,x_n\\), relativas al número de piezas defectuosas en cada caja.Calcular el beneficio obtenido para cada caja, vinculado cada valor \\(x_i\\), denominado \\(b_i\\).Obtener la ganancia global con todas las cajas simuladas como:\\[G = \\sum_{=1}^n b_i\\]Lancemos el algoritmo para cada situación y obtengamos los beneficios esperados.En consecuencia, se aprecia cómo una leve mejora de la calidad en la producción (reduciendo la tasa de defectos) proporciona la empresa una ganancia sustancial, por lo que la política S2 sin duda es la más ventajosa para su negocio.Ejemplo 1.13  Una empresa de inversiones está considerando tres nuevos planes de inversión. Cada plan requiere una inversión de 25.000 dólares y el retorno será un año después. El plan retornará de forma fija 27.500 dólares. El plan B retornará 27.000 dólares o 28.000 dólares, con probabilidades 0.4 y 0.6, respectivamente. El plan C retornará 24.000, 27.000 o 33.000 dólares con probabilidades de 0.2, 0.5 y 0.3, respectivamente. Si el objetivo de la empresa es maximizar el rendimiento esperado, ¿qué plan debería elegir?Hay que tener en cuenta que en este caso sólo es relevante el rendimiento esperado, sino también la volatilidad esperada para ese beneficio, expresada en términos de variabilidad o incertidumbre. Será pues interesante, calcular el rendimiento o el retorno esperado en cada situación, además de su varianza o desviación típica.Vamos plantear un proceso de simulación para estimar los beneficios y volatilidad asociadas cada plan. Fijaremos el mismo número de simulaciones en cada plan, con el fin de hacer comparables los resultados. El algoritmo se presenta continuación.Algoritmo de simulaciónFijar condiciones de simulación (\\(nsim = 1000\\))Obtener la función de distribución acumulada vinculada con cada uno de los planes de inversión y aplicar el algoritmo dado en la definición 1.19 para obtener una muestra de cada uno de ellos.Calcular el beneficio obtenido para cada simulación en cada plan.Obtener la ganancia estimada de cada plan como la media de los beneficios obtenidos para cada simulación, y la volatilidad como la desviación típica de los beneficios obtenidos.Y procedemos con la simulación, calculando el beneficio esperado y la desviación típica en cada plan de inversión. Considerando que el plan tiene incertidumbre alguna (Varianza=0) y el beneficio fijo que generará será de $2500, lo incluimos en la simulación.Podemos ver que aunque el plan C es el que proporcioanrá más retorno esperado, también es el que tiene una mayor volatilidad (sd), lo que produce incertidumbre y podría repercutir en una mayor pérdida al final del periodo de inversión. El plan tiene un beneficio fijo sin volatilidad ninguna, pero es inferior al beneficio del plan B. efetos estadísticos, ya que la volatilidad (desviación típica) del plan B toma un valor inferior la media, el coeficiente de variación (\\(cv=sd/media\\)) resulta inferior 1, y en consecuencia da una alternativa razonable al plan . Por contra, ocurre así en el plan C (\\(cv>1\\)) lo que lo coloca en una situación de inferioridad frente los otros planes de inversión.Con el fin de afinar en nuestra comparación de los tres planes de inversión, nos vamos conformar con valores esperados y desviaciones típicas, y vamos calcular la probabilidad de que beneficio obtenido sea mayor 2500 dólares con cada plan, cálculo que podemos resolver fácilmente partir de las simulaciones obtenidas.Con este cálculo, el plan B sale claramente reforzado, con una probabilidad destacable de generar un beneficio superior $2500 (prob=0.6), frente al plan (prob=0) y al C (prob=0.29). El plan puede superar unos rendimientos superiores 2500, al ser este valor su fijo.","code":"\n# Parámetros de la simulación\nset.seed(19)\nnsim <- 1500\n# datos uniformes\nunif <- runif(nsim)\n# Valores a devolver (piezas defectuosas por caja)\nvalores <- c(0, 1, 2)\n# Valores a devolver y probabilidad acumulada para la política 1\nprob1 <- c(0.82, 0.15, 0.03)\nprobacum1 <- cumsum(prob1)\n# Valores a devolver y probabilidad acumulada para la política 2\nprob2 <- c(0.85, 0.13, 0.02)\nprobacum2 <- cumsum(prob2)\n# Inicialización de variables donde almacenamos las simulaciones\nxs1 <- c(); benef1 <- c()\nxs2 <- c(); benef2 <- c()\n# Simulación de la variable de interés\ni <- 1\nwhile (i <= nsim)\n{\n  # politica 1\n  xs1[i] <- valores[min(which(unif[i] <= probacum1))] \n  benef1[i] <- ifelse(xs1[i]==0, 300, -50*xs1[i]) # beneficios\n  # politica 2\n  xs2[i] <- valores[min(which(unif[i] <= probacum2))]  \n  benef2[i] <- ifelse(xs2[i]==0, 300, -50*xs2[i])\n    # nueva simulación\n  i <- i+1\n}\n# Resultados para las nsim simulaciones\nsimulacion <- data.frame(defec.s1 = xs1, benef.s1 = benef1, \n                         defec.s2 = xs2, benef.s2 = benef2)\ncat(\"Una muestra de las simulaciones realizadas es ...\\n\")## Una muestra de las simulaciones realizadas es ...\nhead(simulacion)##   defec.s1 benef.s1 defec.s2 benef.s2\n## 1        0      300        0      300\n## 2        0      300        0      300\n## 3        0      300        0      300\n## 4        0      300        0      300\n## 5        0      300        0      300\n## 6        0      300        0      300\n# Rendimientos globales\nbeneficios=simulacion %>% \n  summarise(G1 = sum(benef.s1), G2 = sum(benef.s2), \n                         Dif = G2 - G1)\ncat(\"Beneficios S1 (€):\",beneficios$G1,\n    \"Beneficios S2 (€):\",beneficios$G2,\n    \"Diferencia S2-S1 (€):\",beneficios$Dif)## Beneficios S1 (€): 350950 Beneficios S2 (€): 367200 Diferencia S2-S1 (€): 16250\n# Parámetros de la simulación\nset.seed(1970)\nnsim <- 1000\n# datos uniformes\nunif <- runif(nsim)\n# Beneficios asociados a cada plan\nBpB <- c(2000, 3000)  # beneficio variable\nBpC <- c(-1000, 2000, 8000) # beneficio variable\n# Distribuciones de probabilidiad para los planes B y C\nprobB <- c(0.4, 0.6)\nprobacumB <- cumsum(probB) # función de distribución plan B\nprobC <- c(0.2, 0.5, 0.3)\nprobacumC <- cumsum(probC) # función de distribución plan \n# Inicialización de variables donde almacenamos las beneficios \n# individuales para cada simulación\nbenefB <- c()\nbenefC <- c()\n# Simulación de la variable de interés\ni <- 1\nwhile (i <= nsim)\n{\n  # plan B\n  benefB[i] <- BpB[min(which(unif[i] <= probacumB))] \n  # plan C\n  benefC[i] <- BpC[min(which(unif[i] <= probacumC))]  \n  # nueva simulación\n  i <- i+1\n}\n# Resultado\nsimulacion <- data.frame(A=rep(2500,nsim),B = benefB, C = benefC)\ncat(\"Una muestra de las simulaciones realizadas es ...\\n\")## Una muestra de las simulaciones realizadas es ...\nhead(simulacion)##      A    B     C\n## 1 2500 2000 -1000\n## 2 2500 3000  8000\n## 3 2500 2000 -1000\n## 4 2500 2000 -1000\n## 5 2500 3000  8000\n## 6 2500 3000  8000\nbeneficios=simulacion %>% \n  summarise(mPB = mean(B), sdPB = sd(B), \n            mPC = mean(C), sdPC = sd(C))\n\ncat(\"Beneficios PlanA ($):\",2500,\n    \"Volatilidad (sd):\",0,\n   \"Beneficios PlanB ($):\",beneficios$mPB,\n    \"Volatilidad (sd):\",beneficios$sdPB,\n    \"Beneficios PlanC ($):\",beneficios$mPC, \n    \"Volatilidad (sd):\",beneficios$sdPC)## Beneficios PlanA ($): 2500 Volatilidad (sd): 0 Beneficios PlanB ($): 2604 Volatilidad (sd): 489.3091 Beneficios PlanC ($): 3122 Volatilidad (sd): 3315.435\n# Probabilidad beneficio > 2500\nc(prA = sum(simulacion$A>2500)/1000, \n  prB = sum(simulacion$B>2500)/1000, \n  prC = sum(simulacion$C>2500)/1000)##   prA   prB   prC \n## 0.000 0.604 0.289"},{"path":"intro.html","id":"mixturas-de-discretas","chapter":"Unidad 1 Conceptos básicos","heading":"1.6.2 Mixturas de Discretas","text":"Estas situaciones son muy habituales e involucran la combinación de diferentes variables de tipo discreto en un mismo sistema, en lo que se viene denominar mixtura de variables aleatorias de tipo discreto o modelos secuenciales. Sobre este tipo de distribuciones resulta bastante sencillo plantear un algoritmo de simulación. Antes de comenzar veamos desde un punto de vista téorico el concepto de mixtura de variables.Definición 1.20  Sean \\(X_1, X_2,...,X_n\\) un conjunto de variables aleatorias independientes de tipo discreto y sea \\(\\) una variable indicador de tipo discreto, definida en los valores \\(\\{1,..., n\\}\\), tal que \\[Pr(=j)=p_j, j=1,..., n, \\quad \\sum_{j=1}^n p_j = 1.\\]La variable aleatoria \\(T\\) que se define como:\\[ T = \\sum_{j =1}^n p_j X_j\\]se denomina mixtura del conjunto \\(X_1,...,X_n\\) con índice \\(\\), y además cumple que:\\[E(T) = \\sum_{j=1}^n p_j E(X_j)\\]\\[E(T^2) = \\sum_{j=1}^n p_j (V(X_j) + E(X_j)^2).\\]Así, la varianza de \\(T\\) se puede calcular fácilmente partir de la expresión:\\[V(T) = E(T^2) - E(T)^2\\]El algoritmo para simular de una mixtura es bastante sencillo y se basa en la aplicación consecutiva en dos pasos del algoritmo de la transformada inversa para variables discretas en la Definición 1.19.Definición 1.20  Algoritmo simulación mixtura variables discretasEn la situación descrita en la definición 1.20 el algoritmo para generar una muestra de la mixtura debe proporcioanr en cada simulación un vector de dos componentes: variable seleccionada (\\(\\)) y valor generado de \\(X_I\\). En concreto:Paso 1. Establecer el tamaño de muestra simular \\(nsim\\).Repetir los pasos 2 y 3 para cada iteración \\(\\) de \\(1, 2,..., nsim\\):Paso 2. Simular un valor para el indicador \\(I_i\\) de la variable de mixtura, mediante el algoritmo de la transformada inversa para una variable discreta (Definición 1.19) con probabilidades \\(p_1,...,p_n\\), y seleccionar la variable \\(X_{I_i}\\) para dicho indicador.Paso 2. Simular un valor para el indicador \\(I_i\\) de la variable de mixtura, mediante el algoritmo de la transformada inversa para una variable discreta (Definición 1.19) con probabilidades \\(p_1,...,p_n\\), y seleccionar la variable \\(X_{I_i}\\) para dicho indicador.Paso 3. Simular un valor \\(x_{I_i}\\) mediante el algoritmo de la transformada inversa para \\(X_i\\).Paso 3. Simular un valor \\(x_{I_i}\\) mediante el algoritmo de la transformada inversa para \\(X_i\\).Paso 4. Devolver el conjunto de simulaciones \\(\\{I_i, x_{I_i}\\}_{=1}^{nsim}.\\)Paso 4. Devolver el conjunto de simulaciones \\(\\{I_i, x_{I_i}\\}_{=1}^{nsim}.\\)Pasamos estudiar un par de ejemplos de situaciones secuenciales para variables discretas que se pueden modelizar según una mixtura y donde podemos aplicar el algoritmo anterior.Ejemplo 1.14  Una tienda de electrodomésticos desea analizar las ventas de hornos microondas. Los gerentes de la tienda saben que en muchas ocasiones la gente entra en la tienda simplemente para curiosear, pero de todas las personas con intenciones claras de compra, el 50% acaba comprando uno de los tres modelos disponibles y el otro 50% finalmente realiza ninguna compra. De los clientes que compran un horno, el 25% adquiere el modelo sencillo, el 50% el modelo estándar y el 25% el modelo de lujo. El modelo sencillo produce una ganancia de 30 dólares; el modelo estándar produce una ganancia de 60 dólares y el modelo de lujo produce una ganancia de 75 dólares.Los gerentes están interesados en estimar el beneficio medio por cliente de todos aquellos con intención de comprar, y que por tanto utilizan el asesoramiento (y tiempo) de los vendedores.El enfoque habitual para estimar el beneficio promedio sería mantener registros de todos los clientes que hablan con los vendedores y calcular con esos datos una estimación del beneficio esperado por cliente. Sin embargo, este proceso puede ser simulado sin mucha dificultad partir de la información proporcionada, para estimar, por ejemplo, el beneficio promedio por cliente para los próximos cien clientes.Este proceso se puede describir mediante una mixtura con dos variables \\(X_0\\) y \\(X_1\\) que expresan cuál es el beneficio que genera un cliente que entra en la tienda, mediante una variable indicador \\(\\), que identifica si un cliente está interesado o en comprar.Sea \\(X_i\\) la ganancia generada por cada cliente que entra la tienda, para cada uno de los tipos de cliente: 0=compra, 1=sí compra: \\[X_i, \\quad =0,1\\]La probabilidad de que un cliente compre o viene dada por: \\[\\begin{equation*}\nPr(= )=\n\\begin{cases}\n0.5 & =1 \\text{ (si compra)} \\\\\n0.5 & =0 \\text{ (si compra) }\n\\end{cases}\n\\end{equation*}\\]De modo que un cliente que compra produce beneficios 0 con probabilidad 1,\\[Pr(X_0=0)=1,\\] y el beneficio de un cliente que compra tiene como distribución de probabilidad:\\[\\begin{equation*}\nPr(X_1 = k) = \n\\begin{cases}\n0.25 & \\text{ para } k = 30 \\text{ modelo sencillo}\\\\\n0.50 & \\text{ para } k = 60 \\text{ modelo estándar}\\\\\n0.25 & \\text{ para } k = 75 \\text{ modelo lujo}.\n\\end{cases}\n\\end{equation*}\\]Es fácil simular cualquiera de estas distribuciones discretas mediante el algoritmo de la transformada inversa para variables discretas en la Definición 1.19, para acabar simulando de \\(T\\) con el algoritmo anterior en la Definición 1.20.Simulemos pues el proceso de venta para 30 clientes, recopilando, además de la ganancia que genera cada uno, la ganancia acumulada por las compras realizadas. Construimos una función para simular el proceso, en la que introducimos como parámetros la semilla de inicialización de la simulación y el número de clientes, por si deseamos ampliar el espectro de simulación en algún momento.Generamos el proceso para 30 clientes y analizamos los resultadosEl beneficio acumulado tras el paso de 30 clientes un día cualquiera que hemos simulado es de 600 dólares.En la Figura 1.11 se han representado los resultados de las simulaciones generadas (30 clientes que pasan la tienda), así como los beneficios acumulados por las ventas realizadas.\nFigura 1.11: Frecuencia relativa de cada tipo de venta (izquierda) y beneficio acumulado para los 30 clientes (derecha).\nPodemos también calcular la ganancia promedio que se obtiene con esos 30 clientes partir de la variable simulaciones$Bind, que resulta deSi queremos aproximar el beneficio esperado por cliente, bastará simular muchos clientes, y promediar los beneficios que le dan la tienda, o incluso el beneficio esperado por cliente que compra un microondas.Así, el beneficio medio por cliente es aproximadamente de 29.03 dólares, mientras que el beneficio esperado por cliente que compra un microondas es de 57.25 dólares. El beneficio esperado por cada 30 clientes que entran en la tienda será de \\(20.025 \\times 30=870.75\\) dólares.Ejemplo 1.15  Un fabricante de galletas presenta muchos productos nuevos cada año, de los cuales cerca del 60% fracasan, 30% tienen un éxito moderado y un 10% tienen un gran éxito. Para mejorar sus posibilidades, el fabricante somete una prueba sus nuevos productos, ante un grupo de clientes que actúa como jurado calificador. De los productos que fracasaron, 50% son calificados como malos, 30% como regulares y 20% como buenos. Para los que tuvieron un éxito moderado, la calificación es mala para un 20%, regular para un 40% y buena para otro 40%. Para los que tuvieron un gran éxito, los porcentajes son: malos 10%, regulares 30% y buenos 60%. El fabricante está interesado en conocer:¿Cuál es la probabilidad conjunta de que un producto tenga un éxito moderado y reciba una mala calificación?¿Cuál es la probabilidad conjunta de que un producto tenga un éxito moderado y reciba una mala calificación?Si un nuevo producto tiene una buena calificación, ¿cuál es la probabilidad de que fracase?Si un nuevo producto tiene una buena calificación, ¿cuál es la probabilidad de que fracase?¿Cuál es la probabilidad de que un producto tenga éxito moderado dado que este obtuvo una mala calificación?¿Cuál es la probabilidad de que un producto tenga éxito moderado dado que este obtuvo una mala calificación?Modelicemos el problema como una mixtura de distribuciones discretas según la Definición 1.20.Sea \\(I_i\\) la variable indicadora tal que\\[\\begin{equation*}\nPr(= k) = \n\\begin{cases}\n0.25 & \\text{ para } k = 1 \\text{ fracaso}\\\\\n0.50 & \\text{ para } k = 2 \\text{ éxito moderado}\\\\\n0.25 & \\text{ para } k = 3 \\text{ gran éxito}.\n\\end{cases}\n\\end{equation*}\\]Luego definimos las variables \\(X_i\\) que representan la calificación del jurado de un producto cuyo éxito o fracaso funcionó según \\(=\\): \\(X_1\\) calificación de un producto que fue un fracaso (\\(=1\\)), \\(X_2\\) calificación de un producto con un éxito moderado (\\(=2\\)) y \\(X_3\\) calificación de un producto con una gran éxito (\\(=3\\)). Las distribuciones de \\(X_1, X_2, X_3\\) vienen dadas por:\\[\\begin{equation*}\nPr(X_1 = k) = \n\\begin{cases}\n0.5 & \\text{ para } k = 1 \\text{ malo}\\\\\n0.3 & \\text{ para } k = 2 \\text{ regular}\\\\\n0.2 & \\text{ para } k = 3 \\text{ bueno}.\n\\end{cases}\n\\end{equation*}\\]\\[\\begin{equation*}\nPr(X_2 = k) = \n\\begin{cases}\n0.2 & \\text{ para } k = 1 \\text{ malo}\\\\\n0.4 & \\text{ para } k = 2 \\text{ regular}\\\\\n0.4 & \\text{ para } k = 3 \\text{ bueno}.\n\\end{cases}\n\\end{equation*}\\]\\[\\begin{equation*}\nPr(X_3 = k) = \n\\begin{cases}\n0.1 & \\text{ para } k = 1 \\text{ malo}\\\\\n0.3 & \\text{ para } k = 2 \\text{ regular}\\\\\n0.6 & \\text{ para } k = 3 \\text{ bueno}.\n\\end{cases}\n\\end{equation*}\\]Veamos el algoritmo de simulación necesario para este problema. Queremos simular productos que pueden haber tenido un gran éxito, un éxito moderado y o haber fracasado. Y para cada uno de ellos, queremos simular su calificación por el jurado que lo evaluó.Consideramos una variable \\(\\) que indica el éxito de un nuevo producto y \\(X_I\\) que indica la evaluación del producto por un jurado (para cada tipo de producto \\(\\)). En esta situación debemos proporcionar las simulaciones correspondientes \\(\\) e \\(X_I\\). En concreto:Paso 1. Establecer tamaño de muestra simular \\(nsim\\).Repetir los pasos 2 y 3 para cada iteración \\(\\) de \\(1, 2,..., nsim\\):Paso 2. Simular de la variable indicador, \\(I_i\\), mediante el algoritmo de la transformada inversa para una variable discreta con probabilidades \\(0.6, 0.3, 0.1\\) (fracaso, éxito moderado, gran éxito), y seleccionar la variable \\(X_{I_i}\\).Paso 2. Simular de la variable indicador, \\(I_i\\), mediante el algoritmo de la transformada inversa para una variable discreta con probabilidades \\(0.6, 0.3, 0.1\\) (fracaso, éxito moderado, gran éxito), y seleccionar la variable \\(X_{I_i}\\).Paso 3. Simular un valor \\(x_{I_i}\\) mediante el algoritmo de la transformada inversa para \\(X_i\\) con valores malos, regulares, buenos, y probabilidades dadas por:\nfracasos (0.5, 0.3, 0.2)\néxito moderado (0.2, 0.4, 0.4)\ngran éxito (0.1, 0.3, 0.6)\nPaso 3. Simular un valor \\(x_{I_i}\\) mediante el algoritmo de la transformada inversa para \\(X_i\\) con valores malos, regulares, buenos, y probabilidades dadas por:fracasos (0.5, 0.3, 0.2)éxito moderado (0.2, 0.4, 0.4)gran éxito (0.1, 0.3, 0.6)Paso 4. Devolver el conjunto de simulaciones \\(\\{(I_i, x_{I_i})\\}_{=1}^{nsim}.\\)Paso 4. Devolver el conjunto de simulaciones \\(\\{(I_i, x_{I_i})\\}_{=1}^{nsim}.\\)Procedamos pues, simular el proceso para, con las simulaciones, responder las preguntas planteadas por la empresa.partir de las simulaciones, obtenemos la tabla conjunta de frecuencias (Tabla 1.1) y las frecuencias relativas (Tabla 1.2), que constituyen una aproximación de las probabilidades de ocurrencia.\nTabla 1.1: Frecuencias observadas en las simulaciones.\n\nTabla 1.2: Frecuencias relativas observadas en las simulaciones. Aproximación de la distribución conjunta.\nPodemos contestar ahora las preguntas planteadas sin más que mirar la tabla anterior o realizar calculos sencillos con los datos obtenidos:¿Cuál es la probabilidad conjunta de que un producto tenga un éxito moderado y reciba una mala calificación? Estamos interesados en la probabilidad\\[Pr(\\text{Éxito = \"Moderado\" y Evaluación =  \"Malo\"})\\]cuyo valor es 0.0584.Si un nuevo producto tiene una buena calificación, ¿cuál es la probabilidad de que fracase? Para responder esta pregunta podemos aplicar el Teorema de Bayes para resolver la probabilidad condicionada siguiente partir de las frecuencias observadas en la simulación y mostradas en la Tabla 1.1,\\[Pr(\\text{E= \"Fracaso\" | Eval= \"Bueno\"}) =\n\\frac{Pr(\\text{ E=\"Fracaso\" , Eval= \"Bueno\"})}{Pr(\\text{ Eval= \"Bueno\"})}\\]donde \\(E=\\)Éxito y \\(Eval=\\)Evaluación,o directamente seleccionar sobre la Tabla 1.2 las simulaciones en las que el producto fue evaluado como “Bueno” por el jurado, y contabilizar en cuántas de ellas el producto finalmente fracasó (través del ratio correspondiente).\nTabla 1.3: Distribución condicionada que el producto fue evaluado como Bueno por el jurado.\nLa probabilidad de interés resulta 0.4080. De hecho, en la Tabla 1.3 se muestran, en la columna “resultado,” las probabilidades condicionadas que el jurado emitió una buena calificación del producto. ¿Cómo podemos interpretar esas probabilidades?¿Cuál es la probabilidad de que un producto tenga éxito moderado dado que éste obtuvo una mala calificación? Procedemos como en la pregunta anterior ya que estamos interesados en\\[Pr(\\text{E= \"Moderado\" | Eval = \"Malo\"}) = \\frac{Pr(\\text{E= \"Moderado\" , Eval = \"Malo\"})}{Pr(\\text{ Eval= \"Malo\"})}\\]y lo resolvemos de nuevo generando la distribución condicionada que la evaluación por el jurado sea “Mala,” que se muestra en la Tabla 1.4\nTabla 1.4: Distribución condicionada que el producto fue evaluado como Malo por el jurado.\nLa probabilidad de interés es 0.1574. ¿Cómo podemos interpretar la Tabla 1.4 de probabilidades obtenida?","code":"\nsimula.ventas.micro <- function(clientes, semilla)\n{\n# Descripción del proceso de compra o no compra\ncompra <- c(\"Si\", \"No\")\npcompra <- 0.50\n# Descripción del proceso de adquisión del microondas\ntipo <- c(\"Sencillo\", \"Estándar\", \"Lujo\")\nprmicro <- c(0.25, 0.50, 0.25) # fmp X1\nprmicroacum <- cumsum(prmicro) # fon. distribución X1\nbeneficio <- c(30, 60, 75)\n# Inicialización de variables para las simulaciones\nindicador <- c()             # proceso de compra\nmicro <- c()                 # tipo microondas adquirido\nbind <- rep(0, clientes)     # beneficio individual\nbacum <- rep(0, clientes)    # beneficio acumulado\n\n## Simulación del proceso\n##########################\ni <- 1\n# Generamos uniformes para describir el proceso de compra y \n# el tipo de microondas adquirido\nset.seed(semilla)\nucompra <- runif(clientes) # uniformes para el indicador\numicro <- runif(clientes)  # uniformes para la compra\n\n# Bucle de simulación\nwhile (i <= clientes)\n{\n  # Proceso de compra\n  indicador[i] <- ifelse(ucompra[i] <= 0.5, compra[1], compra[2])\n  # Tipo de microndas\n  if(indicador[i] == compra[1])\n  {\n    pos <- min(which(umicro[i] <= prmicroacum))\n    micro[i] <- tipo[pos]\n    bind[i] <- beneficio[pos]\n  }\n  else\n  {\n    micro[i] <- \"Sin venta\"\n    bind[i] <- 0\n  }\n  bacum[i] <- sum(bind[1:i])  # se acumulan todos los beneficios\n  # nueva simulación\n  i <- i+1\n}\n# Resultado\nreturn(data.frame(Compra = indicador, Tipo = micro, \n                  Bind = bind, Bacum = bacum))\n}\nsimulacion <- simula.ventas.micro(30, 123)\nhead(simulacion)##   Compra      Tipo Bind Bacum\n## 1     Si      Lujo   75    75\n## 2     No Sin venta    0    75\n## 3     Si  Estándar   60   135\n## 4     No Sin venta    0   135\n## 5     No Sin venta    0   135\n## 6     Si  Estándar   60   195\n# el beneficio acumulado tras el paso de 30 clientes\ntail(simulacion,n=1)##    Compra     Tipo Bind Bacum\n## 30     Si Estándar   60   600\ng1=simulacion %>%\n  group_by(Tipo) %>%\n  summarise(n=n()) %>%\n  mutate(prop=n/nrow(simulacion)) %>%\n  ggplot(aes(x = Tipo, y = prop)) +\n    geom_col(aes(fill = Tipo), position = \"dodge\") +\n    geom_text(aes(label = scales::percent(prop), \n                  y = prop, group = Tipo),\n              position = position_dodge(width = 0.9),\n              vjust = 1.5)+\n  labs(x=\"Tipo de cliente\",y=\"Proporción\")+\n  theme(legend.position=\"none\")\n\ng2 <- ggplot(simulacion, aes(1:30, Bacum)) + \n  geom_line() +\n  labs(x = \"Cliente\", y = \"Beneficio acumulado\")\ngrid.arrange(g1, g2, nrow = 1)\nmean(simulacion$Bind)## [1] 20\nnsim <- 1000 # número de clientes simulados\nsimulacion <- simula.ventas.micro(nsim,123)\n# aproximación MC del beneficio medio de un cliente cualquiera\nmean(simulacion$Bind)## [1] 29.025\n# beneficio medio de un cliente de compra\nmean(simulacion$Bind[simulacion$Compra==\"Si\"])## [1] 57.24852\n# Parámetros iniciales\nnsim <- 5000\nsemilla <- 12\n# Descripción variable indicadora\nexito <- c(\"Fracaso\", \"Moderado\", \"Éxito\")\npexito <- c(0.6, 0.3, 0.1)\npexitoacum <- cumsum(pexito)\n# Descripción del proceso de adquisión del microondas\nclasifi <- c(\"Malo\", \"Regular\", \"Bueno\")\np1 <- c(0.5, 0.3, 0.2)\np2 <- c(0.2, 0.4, 0.4)\np3 <- c(0.1, 0.3, 0.6)\np1acum <- cumsum(p1)\np2acum <- cumsum(p2)\np3acum <- cumsum(p3)\n\n# Inicialización de variables para las simulaciones\nproducto <- c()             # éxito producto\njurado <- c()               # clasificación jurado\n\n## Simulación del proceso\n##########################\ni <- 1\n# Generamos uniformes para describir el proceso de indicadores de éxito\n# y también el de evaluación o clasificación por el jurado\nset.seed(semilla)\nuexito <- runif(nsim)  \nuclasi <- runif(nsim)\n\n# Bucle de simulación\nwhile (i <= nsim)\n{\n  # Éxito del producto\n  producto[i] <- exito[min(which(uexito[i] <= pexitoacum))]\n  # Tipo de microndas\n  if(producto[i] == exito[1])\n  {\n    jurado[i] <- clasifi[min(which(uclasi[i] <= p1acum))]\n  }\n  else if (producto[i] == exito[2])\n  {\n    jurado[i] <- clasifi[min(which(uclasi[i] <= p2acum))]\n  }\n  else\n  {\n    jurado[i] <- clasifi[min(which(uclasi[i] <= p3acum))]    \n  }\n  # nueva simulación\n  i <- i+1\n}\n# Resultado\nsimulacion <- data.frame(producto = producto, jurado = jurado)\ndistri.conjunta.frec <- table(simulacion)\nkbl(distri.conjunta.frec,caption=\"Frecuencias observadas en las simulaciones.\") %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"),full_width = F)\ndistri.conjunta=as.data.frame(table(simulacion)/nsim)\nkbl(distri.conjunta,caption=\"Frecuencias relativas observadas en las simulaciones. Aproximación de la distribución conjunta.\") %>%\n    kable_styling(bootstrap_options = c(\"striped\", \"hover\"),full_width = F)\ndistri.conjunta.frec[2,1]/sum(distri.conjunta.frec[,1])## [1] 0.4080352\ndistri.conjunta %>% \n  filter(jurado == \"Bueno\") %>%\n  mutate(pr.bueno = sum(Freq), resultado = round(Freq/pr.bueno,4)) %>%\n  kbl(caption=\"Distribución condicionada a que el producto fue evaluado como Bueno por el jurado.\")%>%\n      kable_styling(bootstrap_options =c(\"striped\",\"hoover\"),full_width = F)\ndistri.conjunta %>% \n  filter(jurado == \"Malo\") %>%\n  mutate(pr.malo = sum(Freq), resultado = round(Freq/pr.malo,4)) %>%\n  kbl(caption=\"Distribución condicionada a que el producto fue evaluado como Malo por el jurado.\") %>%\n  kable_styling(bootstrap_options =c(\"striped\",\"hoover\"),full_width = F)"},{"path":"intro.html","id":"otras-distribuciones-continuas","chapter":"Unidad 1 Conceptos básicos","heading":"1.7 Otras distribuciones continuas","text":"En el caso de variables de tipo continuo de las que disponemos de un generador de valores aleatorios pero sí disponemos de su función de densidad o distribución, podemos utilizar el algoritmo de la transformada inversa, dado en la definición 1.18, para obtener una muestra aleatoria de tamaño \\(n\\) de su distribución.En primer lugar estudiamos situaciones con una variable y posteriormente vemos ejemplos de sistemas de variables continuas o mixturas de discretas y continuas.","code":""},{"path":"intro.html","id":"una-variable-continua","chapter":"Unidad 1 Conceptos básicos","heading":"1.7.1 Una variable continua","text":"Estudiamos aquí, través de ejemplos, la simulación de variables aleatorias de tipo continua para las que conocemos la función de densidad o distribución, y se quiere revolver algún problema inferencial.Ejemplo 1.16  Sea \\(X\\) una variable aleatoria de tipo continuo cuya función de densidad viene dada por:\\[\\begin{equation*}\nf(x) = 2e^{-2x}  \\text{ para } x \\geq 0\n\\end{equation*}\\]Estamos interesados en conocer:¿Cuál es la probabilidad de que la variable de interés tome valores en el intervalo [1, 2]?¿Cuál es la probabilidad de que la variable de interés tome valores mayores o iguales 1.5?¿Cuál es el valor esperado de la variable? ¿y la desviación típica?Para poder responder las preguntas planteadas debemos obtener en primer lugar la función de distribución asociada \\(X\\), que viene dada por:\\[\\begin{equation}\nF(x) = \\int_0^x 2e^{-2s} ds=1 - e^{-2x} \\text{ para } x \\geq 0\n\\tag{1.22}\n\\end{equation}\\]Podemos aplicar ahora el método de la transformada inversa para obtener una muestra de \\(X\\).El algoritmo de simulación basado en la transformada inversa, en la Definición 1.18 viene dado por:Si \\(F(X)\\) es la función de distribución para \\(X\\) dada en la Ecuación (1.22)Paso 1. Establecer el tamaño de muestra simular \\(nsim\\).Repetir los pasos 2 y 3 para cada iteración \\(\\) de \\(1, 2,..., nsim\\):Paso 2. Generar \\(u_i\\) partir de una \\(U(0,1)\\).Paso 2. Generar \\(u_i\\) partir de una \\(U(0,1)\\).Paso 3. Aplicar el método de la transformada inversa para obtener \\(x_i = F^{-1}(u_i)\\) con \\(F^{1}(u_i) = -log(1-u_i)/2.\\)Paso 3. Aplicar el método de la transformada inversa para obtener \\(x_i = F^{-1}(u_i)\\) con \\(F^{1}(u_i) = -log(1-u_i)/2.\\)Paso 4. Devolver el conjunto de simulaciones \\(\\{x_i\\}_{=1}^{nsim}\\).Paso 4. Devolver el conjunto de simulaciones \\(\\{x_i\\}_{=1}^{nsim}\\).Apliquemos pues el algoritmo anterior, y generemos una muestra de tamaño \\(nsim=5000\\) para \\(X\\). Aprovechamos el calculo vectorial de R para tener que hacer un bucle.Y con las simulaciones obtenidas, respondamos cada una de las preguntas planteadas:","code":"\n# Parámetros iniciales\nnsim <- 5000\nset.seed(12)\n# Generamos uniformes \nuniforme <- runif(nsim)\n# Calculamos x con F^-1\nxs <- -log(1-uniforme)/2\n# Pr(1 <= X <= 2)\ncat(\"Pr(1 <= X <= 2)=\",round(mean(xs >= 1 & xs <= 2), 4))## Pr(1 <= X <= 2)= 0.121\n# Pr(X >= 1.5)\ncat(\"Pr(X >= 1.5)=\",round(mean(xs >= 1.5), 4))## Pr(X >= 1.5)= 0.053\n# Valor esperado y varianza\ncat(\"E(X)=\",round(mean(xs), 4))## E(X)= 0.5046\ncat(\"V(X)=\",round(sd(xs), 4))## V(X)= 0.5078"},{"path":"intro.html","id":"composicionsec","chapter":"Unidad 1 Conceptos básicos","heading":"1.7.2 Transformaciones y Método de Composición","text":"En ocasiones, se nos plantea el problema de inferir, través de simulación, sobre una variable aleatoria \\(Y\\) que se obtiene como una transformación continua de otra variable \\(X\\) cuya distribución conocemos, esto es, \\[Y=h(X), \\quad \\text{ con } X \\sim F(x).\\]En particular, \\[E(Y)=\\int_S h(x) f(x)dx.\\]Se propone un algoritmo sencillo para simular muestras aleatorias de la variable \\(Y\\), denominado método de composición y que se presenta continuación.Definición 1.21  Método de composiciónSi \\(X\\) es una variable aleatoria continua con función de distribución \\(F(X)\\), e \\(Y\\) otra variable aleatoria que se obtiene como \\(Y = h(X)\\), donde \\(h()\\) es una función continua, podemos obtener una muestra de \\(Y\\) partir del siguiente proceso:Paso 1. Fijar el número de simulaciones (\\(nsim\\)).Repetir los pasos 2 y 3 hasta alcanzar el número de simulaciones del paso 1.Paso 2. Generar un valor de la variable \\(X\\), \\(\\{x_i \\sim F(x)\\}\\).Paso 3. Calcular el valor de la variable \\(Y\\) para esa simulación mediante \\(y_i = h(x_i)\\).Paso 4. Devolver el conjunto de valores simulados \\(\\{y_i\\}_{=1}^{nsim}.\\)Ejemplo 1.17  Sea \\(X\\) una variable aleatoria de tipo continuo cuya función de densidad viene dada por:\\[\\begin{equation*}\nf(x) = 3x^2  \\text{ para } 0 < x < 1\n\\end{equation*}\\]y consideramos la variable aleatoria \\(Y = 1 - X^2\\). Estamos interesados en conocer:¿Cuál es el valor esperado de la variable \\(Y\\)? ¿Y su desviación típica?\\(Pr(Y \\[0,1])\\)\\(Pr(Y \\geq 0.5)\\)Puesto que la distribución de \\(X\\) es de las estándar, para simular de ella hemos de utilizar el método de la transformada inversa (Definición 1.18), para lo que hemos de obtener necesariamente su función de distribución, que viene dada por:\\[\\begin{equation}\nF(x) = \n\\begin{cases}\n0 & \\text{ para } x <= 0\\\\\nx^3 & \\text{ para } 0 < x < 1\\\\\n1 & \\text{ para } x \\geq 1\n\\end{cases}\n\\tag{1.23}\n\\end{equation}\\]La función de distribución inversa es pues: \\[F^{-1}(u)=u^{1/3}\\]El algoritmo para obtener una muestra de \\(Y\\) viene dado por:Si \\(F(X)\\) es la función de distribución para \\(X\\) dada en (1.23)Paso 1. Establecer tamaño de muestra simular \\(nsim\\).Repetir los pasos 2 4 para cada iteración \\(\\) de \\(1, 2,..., nsim\\):Paso 2. Generar \\(u_i\\) partir de una \\(U(0,1)\\).Paso 3. Aplicar el método de la transformada inversa para obtener \\(x_i = F^{-1}(u_i)=u^{1/3}\\).Paso 4. Actuar por composición y calcular \\(y_i = 1 - x_i^2\\).Paso 5. Devolver el conjunto \\(\\{y_i\\}_{=1}^{nsim}.\\)Procedemos con el algoritmo de simulación.Podemos calcular ahora las cantidades de interés:Representamos gráficamente las simulaciones obtenidas tanto para la variable \\(X\\) como la \\(Y\\).\nFigura 1.12: Función de densidad empírica e histogramas para X e Y.\n","code":"\n# Parámetros iniciales\nnsim <- 5000\nset.seed(12)\n# Generamos uniformes \nuniforme <- runif(nsim)\n# Calculamos x con F^-1\nxs <- uniforme^(1/3)\n# Calculamos y = h(x)\nys <- 1 - xs\n# Devolvemos los valores de x e y\nsimulacion <- data.frame(sim = 1:nsim, x = xs, y = ys)\n# Valor esperado y desviación típica de Y \ndatos <- simulacion$y\ncat(\"E(Y)=\", round(mean(datos), 4))## E(Y)= 0.2478\ncat(\"sd(Y)=\", round(sd(datos), 4))## sd(Y)= 0.1915\n# Pr(0 <= Y <= 1) \ncat(\"Pr(0 <= Y <= 1)=\", round(sum(datos >= 0 & datos <= 1)/nsim, 4))## Pr(0 <= Y <= 1)= 1\n# Pr(Y >= 1) \ncat(\"Pr(Y >= 0.5)=\", round(sum(datos >= 0.5)/nsim, 4))## Pr(Y >= 0.5)= 0.121\ng1 <- ggplot(simulacion, aes(x, ..density..)) + \n  geom_histogram(fill = \"steelblue\") +\n  geom_density()+\n  labs(x = \"X\", y = \"Densidad\")\ng2 <- ggplot(simulacion, aes(y, ..density..)) + \n  geom_histogram(fill = \"steelblue\") +\n  geom_density()+\n  labs(x = \"Y\", y = \"Densidad\")\ngrid.arrange(g1, g2, nrow = 1)## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"intro.html","id":"combinaciones-de-variables","chapter":"Unidad 1 Conceptos básicos","heading":"1.7.3 Combinaciones de variables","text":"Continuamos este bloque con un tipo de problema que nos encontraremos en muchas ocasiones en el análisis de sistemas, como es la definición de nuevas variables al operar (combinar aritméticamente) otras cuya distribución es conocida. Un ejemplo típico es la suma o resta de variables aleatorias. Imaginemos que tenemos dos variables \\(X_1\\) y \\(X_2\\) con funciones de densidad \\(f_1(x_1)\\) y \\(f_2(x_2)\\) respectivamente, y estamos interesados en estudiar las variables:\\[Y = X_1 + X_2 \\quad\\text{ y } \\quad Z = X_1 - X_2\\] Para el estudio de \\(Y\\) y \\(Z\\) podemos proceder teóricamente mediante los correspondientes cambios de variable, pero en situaciones má complejas o con más variables ese procedimiento es poco práctico. En dichas situaciones, podemos utilizar el método de composición para obtener una muestra de las nuevas variables.Definición 1.22  Método de composición para combinaciones de variablesSi \\(X_1,..., X_n\\) es un conjunto de variables aleatorias continuas con funciones de distribución \\(F_1,..., F_n\\) y se define la variable aleatoria \\(Y\\) mediante una transformación \\(h(X_1,...,X_n)\\), donde \\(h()\\) es una función continua, podemos obtener una muestra de \\(Y\\) mediante el siguiente procedimiento:Paso 1. Fijar el número de simulaciones (\\(nsim\\)).Repetir pasos 2 y 3 hasta alcanzar el número de simulaciones fijado en el paso 1Paso 2. Generar un valor de cada variable \\(X_i\\), \\(x_{ji} \\sim F(x_j), \\quad j=1,\\ldots,n\\).Paso 3. Calcular el valor de la variable \\(Y\\) mediante \\(y_i = h(x_{1i},...,x_{ni})\\).Paso 4. Devolver el conjunto de valores simulados \\(\\{y_i\\}_{=1}^{nsim}.\\)Estudiamos continuación algunos ejemplos donde se aplica el algoritmo expuesto.Ejemplo 1.18  Supongamos que tenemos un conjunto de 10 variables \\(X_1,...,X_{10}\\), tales que cada una de ellas se distribuye de forma independiente como: \\[X_i \\sim U(0,1), \\quad =1,...,10\\] y consideramos además las variables aleatorias\\[\\begin{eqnarray*}\nY_{min} &=& min\\{X_1,...,X_{10}\\},\\\\\nY_{max} &=& max\\{X_1,...,X_{10}\\}.\n\\end{eqnarray*}\\]Estamos interesados en conocer:¿Cuál es el valor de \\(Pr[(Y_{min} \\leq 0.1) \\cap (Y_{max} \\geq 0.8)]\\).¿Cuál es el valor esperado del rango, definido como \\(R = Y_{max} - Y_{min}\\)?¿Cuál es el valor de \\(Pr(R \\geq 0.5)\\)?Auque el problema teórico se puede resolver fácilmente, vamos plantear un algoritmo de simulación para responder las cuestiones de interés.Algoritmo para obtener una muestra de \\(Y_{min}, Y_{max}\\) y \\(R\\).Paso 1. Fijar el número de simulaciones (\\(nsim\\)).Repetir los pasos 2 4 hasta alcanzar el número de simulaciones fijado en el paso 1.Paso 2. Generar valores \\(x_{1,},...,x_{10,} \\sim U(0,1)\\).Paso 3. Aplicando composición calcular \\(y_{min,} = min\\{x_{1,},...,x_{10,}\\}\\) e \\(y_{max,} = max\\{x_{1,},...,x_{10,}\\}\\).Paso 4. Aplicando composición calcular \\(r_{} = y_{max,} - y_{min,}.\\)Paso 5. Devolver el conjunto de valores simulados \\(\\{y_{min,}, y_{max,}, r_{}\\}_{=1}^{nsim}.\\)Procedemos con el algoritmo de simulación. Aprovechamos las ventajas de R para el cálculo vectorial y evitar los bucles.Podemos evaluar ahora las cuestiones de interés partir de la muestra obtenida para las tres variables.Representamos en la Figura 1.13 la distribución obtenida partir de las simulaciones para las tres variables consideradas.\nFigura 1.13: Simulaciones del mímimo, máximo y rango de X1,…,X10 v.. U(9,1).\nEjemplo 1.19  En un estudio de calidad se está analizando el ajuste entre las pernos y las tuercas de cierto proceso de fabricación. Los pernos y las tuercas se fabrican de forma independiente y se colocan en dos cajas. Posteriormente se elige un perno y una tuerca y se prueba si encajan entre sí. Un perno y una tuerca ajustarán si el diámetro del agujero de la tuerca es mayor que el diámetro del perno y la diferencia entre estos diámetros es mayor que 0.06 centímetros. Cuando se cumplen estas especificaciones, tanto la tuerca como el perno se desechan. Las especificaciones de fabricación de los pernos indican que su diámetro se puede considerar que es una variable Normal con media 2 centimetros y desviación típica de 0.01 centímetros, mientras que el diámetro de las tuercas es una variable Normal con media 2.03 centímetros y desviación típica de 0.02 centímetros.¿Cuál es la probabilidad de que encajen un perno y una tuerca elegidos al azar en una caja cualquiera?Si se fabrican 10000 pernos y tuercas en un día, ¿cuántas desecharemos?Si el porcentaje de desechos es inferior al 15% en un día se modificarán las especificaciones de fabricación ¿Consideras que deberían modificarse las especificaciones de fabricación?Partimos pues, para resolver el problema, de las variables \\(T\\sim N(2.03, 0.02)\\), que representa el diámetro de una tuerca, y \\(P \\sim N(2, 0.01)\\) que representa el diámetro de un perno. Las especificaciones de calidad exigen que \\(T>P\\) y que \\(Dif=T-P\\leq 0.6\\), o lo que es lo mismo, \\(0<Dif\\leq 0.6\\).Veamos cómo podríamos simular para responder las preguntas planteadas.Algoritmo para obtener la diferencia entre los diámetros de las tuercas y los pernos.Paso 1. Fijar el número de simulaciones (\\(nsim\\)).Repetir los pasos 2 4 hasta alacanzar el número de simulaciones fijado en el paso 1.Paso 2. Generar valores \\(t_i\\sim F(T)\\) y \\(p_i \\sim F(P)\\) de sus respectivas distribuciones.Paso 3. Aplicando composición, calcular \\(dif_i = t_i - p_i.\\)Paso 4. Verificar el requisito de calidad: \\(0 < dif_i \\leq 0.06\\) y asignar \\(valid_i = 1\\) si se cumple con el criterio y \\(valid_i = 0\\) en otro caso.Paso 5. Devolver el conjunto de valores simulados \\(\\{t_i, p_i, dif_i, valid_i\\}_{=1}^{nsim}.\\)Pongamos en práctica el algoritmo diseñado.Representamos los datos simulados en la Figura 1.14, con la que podemos ya responder la primera pregunta:¿Cuál es la probabilidad de que encajen un perno y una tuerca elegidos al azar en una caja cualquiera? Como vemos en la gráfica superior izquierda, la respuesta es 0.82, la vista de que el 82% de las cajas inspeccionadas son válidas.\nFigura 1.14: Simulaciones del proceso de calidad para tuercas y pernos.\nRespondemos las siguientes preguntas:Si se fabrican 10000 pernos y tuercas en un día, ¿cuántas desecharemos? Si nuestra producción es de 10000 parejas, el número de parejas desechadas será igual :Si el porcentaje de desechos es inferior al 15% en un día se modificarán las especificaciones de fabricación ¿Consideras que deberían modificarse las especificaciones de fabricación? Realmente el porcentaje de piezas desechadas es del 18% (gráfico superior izquierdo en la Figura 1.14), por lo que la recomendación sería abordar un proceso de mejora en la fabricación para reducir los defectos.Ejemplo 1.20  Una empresa de fabricación de componentes para aviones tiene entre sus productos una barra que se coloca como sujeción en las alas, y que se construye mediante la unión consecutiva de tres secciones , B, y C. Las especificaciones de fabricación establecen que la longitud (en pulgadas) de cada barra es una distribución Normal. Más concretamente la sección tiene una media de 20 pulgadas y una varianza de 0.04. la longitud de la sección B tiene una media de 14 y varianza de 0.01, mientras que la sección C tiene una media de 26 y varianza 0.04. Las tres piezas se unen consecutivamente (con B y B con C) de forma que se encajan superponiendo 2 pulgadas en cada unión. La barra sólo puede ser utilizada si su longitud total está entre 55.5 y 56.5 pulgadas.¿Cuál es la probabilidad de que la barra sea utilizable?Si en un mes se fabrican 25000 barras ¿cuál es el número de barras desechadas?Por cada barra dentro de especificaciones se obtiene un beneficio de 300 euros, pero si se desecha, se genera una pérdida de 100 euros. ¿Cuál será el beneficio estimado en un mes?Si denominamos \\(LA\\), \\(LB\\), y \\(LC\\) las variables aleatorias correspondientes las longitudes de las secciones , B, y C respectivamente, las distribuciones asociadas vienen dadas por:\\[LA \\sim N(20, \\sqrt{0.04}); \\quad LB \\sim N(14, \\sqrt{0.01}); \\quad  LC \\sim N(26, \\sqrt{0.04})\\]La otra variable involucrada es la suma de barra al unir las piezas, que se obtiene como \\(L=LA+LB+LC-4\\), dado que en cada junta se pierden 2 pulgadas. Las especificaciones de calidad sobre ella son \\(55.5 \\leq L \\leq y 56.5\\).Proponemos pues, un algoritmo de simulación que nos permita simular la longitud total de la barra partir de cada una de las secciones, y verificar si está dentro de las especificaciones de calidad establecidas.Paso 1. Fijar el número de simulaciones (\\(nsim\\)).Repetir los pasos 2 4 hasta alcanzar el número de simulaciones fijado en el paso 1.Paso 2. Generar valores \\(LA_i\\), \\(LB_i\\), y \\(LC_i\\) partir de sus distribuciones correspondientes.Paso 2. Generar valores \\(LA_i\\), \\(LB_i\\), y \\(LC_i\\) partir de sus distribuciones correspondientes.Paso 3. Aplicando composición, calcular \\(L_i = LA_i + LB_i + LC_i - 4.\\)Paso 3. Aplicando composición, calcular \\(L_i = LA_i + LB_i + LC_i - 4.\\)Paso 4. Verificar el requisito de calidad: \\(55.5 \\leq L_i \\leq 56.5\\) y asignar \\(valid_i = 1\\) si lo cumple, y \\(valid_i = 0\\) si lo cumple.Paso 4. Verificar el requisito de calidad: \\(55.5 \\leq L_i \\leq 56.5\\) y asignar \\(valid_i = 1\\) si lo cumple, y \\(valid_i = 0\\) si lo cumple.Paso 5. Devolver el conjunto de valores simulados \\(\\{LA_i, LB_i, LC_i, L_i, valid_i\\}_{=1}^{nsim}.\\)Paso 5. Devolver el conjunto de valores simulados \\(\\{LA_i, LB_i, LC_i, L_i, valid_i\\}_{=1}^{nsim}.\\)Programemos el algoritmo.Respondamos las preguntas partir de las simulaciones obtenidas.¿Cuál es la probabilidad de que la barra sea utilizable? La respuesta viene aproximada por la proporción de piezas válidas. Calculamos también un intervalo de confianza utilizando la ecuación (1.5).Dado el error tan pequeño que genera el proceso de simulación, la estimación proporcionada es claramente precisa.Si en un mes se fabrican 25000 barras ¿cuál es el número de barras desechadas?Por cada barra dentro de especificaciones se obtiene un beneficio de 300 euros, pero si se desecha, se genera una pérdida de 100 euros. ¿Cuál será el beneficio estimado en un mes?","code":"\n# Parámetros iniciales\nnsim <- 5000\nnvar <- 10  # número de variables\nset.seed(12)\n# Generamos matriz de datos uniformes de dimensiones nsim*nvar \nuniforme <- matrix(runif(nsim*nvar), nrow = nsim)\n# Calculamos y_min e y_max\nymin <- apply(uniforme, 1, min)\nymax <- apply(uniforme, 1, max)\n# Calculamos rango\nrango <- ymax - ymin\n# Devolvemos los valores \nsimulacion <- data.frame(sim = 1:nsim, \n                         ymin = ymin, ymax = ymax, \n                         rango = rango)\n#  Pr(Y_{min} <= 0.1, Y_{max} >= 0.8)$\np1 = mean((simulacion$ymin <= 0.1) & (simulacion$ymax >= 0.8))\ncat(\"Pr(Y_{min} <= 0.1, Y_{max} >= 0.8)=\", round(p1, 4))## Pr(Y_{min} <= 0.1, Y_{max} >= 0.8)= 0.5732\n# Valor esperado del rango \ncat(\"E(R)=\",round(mean(simulacion$rango), 4))## E(R)= 0.8183\n# Pr(R >= 0.5)\ncat(\"Pr(R >= 0.5)=\",round(mean(simulacion$rango >= 0.5), 4))## Pr(R >= 0.5)= 0.9874\norden <- c(\"ymin\", \"ymax\", \"rango\")\n# Construimos matriz de datos para el gráfico\ndatos <- pivot_longer(simulacion, cols = 2:4, \n                      names_to = \"Medida\", values_to = \"Valor\")\n# gráfico\nggplot(datos, aes(Valor,fill = Medida))+\n  geom_histogram(aes(y = ..density..), position = \"identity\", alpha = 0.3, bins = 50)+\n  labs(y = \"Densidad\",x = \"\",fill = \"Variables\")\n# Parámetros iniciales\nnsim <- 5000\nset.seed(12)\n# Generamos diámetros para tuercas y pernos\ntuercas <- rnorm(nsim, 2.03, 0.02)\npernos <- rnorm(nsim, 2.00, 0.01)\n# Calculamos la diferencia y creamos filtro de calidad\ndiferencia <- tuercas - pernos\nvalid<- 1*(diferencia >0 & diferencia <= 0.06)\n# Devolvemos los valores \nsimulacion <- data.frame(sim = 1:nsim, \n                         tuercas = tuercas, \n                         pernos = pernos, \n                         diferencia= diferencia, \n                         valid = valid)\n# Calidad del proceso\ng1 <- simulacion %>%\n  count(valid)%>%\n  mutate(prop = prop.table(n)) %>%\n  ggplot(aes(x = as.factor(valid), y = prop, label = scales::percent(prop))) + \n  geom_col(fill = \"steelblue\", position = \"dodge\") +\n  scale_x_discrete(labels = c(\"No\", \"Sí\")) +\n  scale_y_continuous(labels = scales::percent)+\n  geom_text(position = position_dodge(width = 0.9), vjust = 1.5,size = 3)+\n  labs(x = \"Resultado del proceso: validez\", y = \"Porcentaje\")\n# Diferencia\ng2 <- ggplot(simulacion, aes(diferencia)) + \n  geom_histogram(fill = \"steelblue\",color=\"grey\") +\n  geom_vline(xintercept = c(0, 0.06), col = \"red\") +\n  labs(x = \"Diferencia Tuerca-Perno\", y = \"Frecuencia\")\n# Diámetros\norden <- c(\"tuercas\", \"pernos\")\ndatos <- pivot_longer(simulacion, cols = 2:3, names_to = \"Medida\", values_to = \"Valor\")\n# gráfico\ng3 <- ggplot(datos, aes(Medida, Valor)) + \n  geom_boxplot(fill = \"steelblue\") +\n  scale_x_discrete(limits = orden, labels = orden) +\n  labs(x = \"\", y = \"Diámetro\")\n# Combinación\ngrid.arrange(g1, g2, g3, nrow = 2)## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n10000*(1 - mean(simulacion$valid == 1))## [1] 1794\n# Parámetros iniciales\nnsim <- 5000\nset.seed(12)\n# Generamos longitudes de las secciones\nLA <- rnorm(nsim, 20, sqrt(0.04))\nLB <- rnorm(nsim, 14, sqrt(0.01))\nLC <- rnorm(nsim, 26, sqrt(0.04))\n# Calculamos longitud total y verificamos requisitos\nL <- LA + LB + LC - 4\nvalid <- 1*(L >= 55.5 & L <= 56.5)\n# Devolvemos los valores \nsimulacion <- data.frame(sim = 1:nsim, LA = LA, LB = LB, \n                         LC = LC, L = L,valid=valid)\n#  Pr proceso cumpla criterios calidad\np = mean(simulacion$valid == 1)\nerror = sqrt((sum(simulacion$valid-p)^2)/(nsim^2))\nalpha = 0.05 # 1-alpha=nivel de confianza para el IC\nic.low = p - qnorm(1-alpha/2)*error\nic.up = p + qnorm(1-alpha/2)*error\ncat(\"Pr(barra utilizable)=\", p)## Pr(barra utilizable)= 0.9016\ncat(\"Error de la aproximación=\", error)## Error de la aproximación= 4.298784e-17\ncat(\"IC(\", 1-alpha,\"%)= [\", ic.low,\",\", ic.up,\"]\")## IC( 0.95 %)= [ 0.9016 , 0.9016 ]\ndesechos=25000*(1-p)\ncat(\"Barras desechadas en un mes:\", desechos)## Barras desechadas en un mes: 2460\nbenef=(25000-desechos)*300-desechos*100\ncat(\"Beneficio obtenido en un mes:\", benef, \"€\")## Beneficio obtenido en un mes: 6516000 €"},{"path":"intro.html","id":"modelos-secuenciales","chapter":"Unidad 1 Conceptos básicos","heading":"1.7.4 Modelos secuenciales","text":"En la última sección para variables de tipo continuo presentamos los primeros modelos de simulación para variables aleatorias que actúan de forma consecutiva lo largo del tiempo. Será pues, una introducción los modelos estocásticos que estudiaremos en el resto de unidades. En estas situaciones todas las variables involucradas en el sistema hacen referencia al tiempo de ocurrencia de los eventos de interés. Trabajemos con ejemplos, para entender los conceptos y problemas involucrados.Ejemplo 1.21  El equipo de mantenimiento de una empresa debe programar las visitas cierta instalación para establecer una calendario eficiente de revisiones. El sistema que debe analizar está compuesto por tres procesos (, B, y C) que funcionan de forma independiente, pero que están conectados en serie, de forma que todo el sistema se detiene si un proceso falla. El tiempo de vida o tiempo hasta un fallo o avería, medido en horas, para cada uno de los procesos se puede considerar aleatorio y responde distribuciones exponenciales con medias 1000, 333, y 167 respectivamente.El proceso de fabricación completo, que involucra los tres procesos , B y C, funciona 24 horas al día y completa un ciclo cada siete días, tras el cual realiza un parón para tareas de mantenimiento. En ese ciclo, los procesos , B y C operan consecutivamente durante un día: \\(\\) trabaja durante 15.6 horas, luego entra en funcionamiento el proceso \\(B\\) durante 5.52 horas, y finalmente el \\(C\\) durante 2.88 horas.En la actualidad el equipo de manteniento está interesado en reajustar el ciclo para realizar las labores de mantenimiento, si fuera necesario, y reducir el tiempo muerto en que el sistema está parado, pues en estos momentos se dedican 24 horas tras cada ciclo, para las tareas de mantenimiento.¿Cuál es la probabilidad de que el sistema falle antes de finalizar un ciclo de trabajo?¿Cuál de los procesos está generando más parones en el ciclo debidos una avería?¿Cuál es el tiempo medio de funcionamiento del sistema sin ningún fallo? Interesa además, un rango o intervalo de confianza para dicha estimación. ¿Cuál sería el tiempo óptimo del ciclo para abordar las tareas de mantenimiento?En primer lugar modelicemos el sistema en base la información proporcionada. Definamos las variables aleatorias \\(TA\\), \\(TB\\), y \\(TC\\) que representan, respectivamente, el tiempo de funcionamiento -o tiempo fallo- (en horas) de cada proceso , B y C. Sus distribuciones son: \\[TA \\sim Exp(1/1000); \\quad TB \\sim Exp(1/333); \\quad TC \\sim Exp(1/167).\\] También son importantes las siguientes cantidades: - El tiempo de funcionamiento requerido cada día para cada uno de los procesos \\(ta=15.6, tb=5.52, tc=2.88\\) y el número de días que conforma cada ciclo, \\(nciclo=7\\).El tiempo de vida potencial del sistema completo, esto es, el tiempo \\(T\\) que funciona el sistema de fabricación hasta un fallo, y que se calcula partir del mínimo número de días que funciona cada proceso, \\(min \\{TA/ta,TB/tb,TC/tb\\}\\).Propongamos pues, un algoritmo de simulación que reproduzca el proceso de fabricación para un número \\(nsim\\) de ciclos simulados, cuyas simulaciones permitan responder las preguntas planteadas.Algoritmo para el estudio de fallo del sistemaPaso 1. Fijar el número de simulaciones o ciclos simular (\\(nsim\\)).Repetir los pasos 2 4 tantas veces como simulaciones generar (nsim).Paso 2. Generar valores \\(TA_i\\), \\(TB_i\\), y \\(TC_i\\) de los tiempos fallo de cada proceso según su distribución.Paso 2. Generar valores \\(TA_i\\), \\(TB_i\\), y \\(TC_i\\) de los tiempos fallo de cada proceso según su distribución.Paso 3. Calcular el número de días que dura sin fallos cada proceso, con los ratios \\(rt_i=\\{TA_i/ta, TB_i/tb, TC_i/tc\\}\\). Identificar cuál falla primero (\\(min(rt_i)\\)).Paso 3. Calcular el número de días que dura sin fallos cada proceso, con los ratios \\(rt_i=\\{TA_i/ta, TB_i/tb, TC_i/tc\\}\\). Identificar cuál falla primero (\\(min(rt_i)\\)).Paso 4. Verificar si el primero en fallar lo hace antes de terminar el ciclo, \\(min(rt_i)<=7\\). Si es que sí, guardar cuál es el proceso responsable del fallo y calcular la duración del ciclo mediante \\(24*rt_i\\) horas. Si es que , indicarlo y especificar como duración del ciclo \\(24*7\\) horas.Paso 4. Verificar si el primero en fallar lo hace antes de terminar el ciclo, \\(min(rt_i)<=7\\). Si es que sí, guardar cuál es el proceso responsable del fallo y calcular la duración del ciclo mediante \\(24*rt_i\\) horas. Si es que , indicarlo y especificar como duración del ciclo \\(24*7\\) horas.Paso 5. Devolver los valores de las simulaciones de los tiempos fallo de cada proceso, de la duración del ciclo, el indicador de fallo y el proceso responsable en cada ciclo (simulación).Paso 5. Devolver los valores de las simulaciones de los tiempos fallo de cada proceso, de la duración del ciclo, el indicador de fallo y el proceso responsable en cada ciclo (simulación).Lanzamos el proceso para los valores del ejemplo, y visualizamos los resultados en la Tabla 1.5\nTabla 1.5: Simulaciones para el proceso de fabricación con tres subprocesos encadenados , B y C. Tipo de fallo, tiempos de funcionamiento del sistema (Tciclo en horas, Dciclo en días) y tiempo de funcionamiento potencial (Tpotencial en horas). Días de vida DA, DB, DC de los procesos.\n¿Cuál es la probabilidad de que el sistema falle antes de finalizar un ciclo de trabajo?¿Cuál de los procesos está generando más parones en el ciclo debidos una avería?En la Figura 1.15 representamos (la izquierda) el porcentaje que se detiene el proceso de fabricación antes de finalizar el ciclo, para cada uno de los tipos de fallo posible (debido un parón en , B o C), y difieren muy poco entre sí. El más frecuente, dentro de la similaridad es el fallo en el proceso C, con una probabilidad de 0.0986. la derecha de la gráfica vemos cómo los tres tipos de fallo están dando tiempos de fabricación muy similares en media y variabilidad.\nFigura 1.15: Gráfico del ciclo de vida y de la probabilidad del tiempo de fabricación sin fallos.\n¿Cuál es el tiempo medio de funcionamiento del sistema sin ningún fallo? Interesa además, un rango o intervalo de confianza para dicha estimación. ¿Cuál sería el tiempo óptimo del ciclo para abordar las tareas de mantenimiento?Respondemos esta pregunta utilizando el tiempo de ciclo impuesto como cota superior, sino el tiempo de funcionamiento que el sistema es capaz de aguantar sin fallos, recogido en la variable Tpotencial(en horas). Damos una estimación y construimos un intervalo de confianza al 95% para responder la pregunta.Resulta pues, que el sistema de fabricación tiene capacidad para funcionar sin fallos una media de 20.5 días, y el intervalo de confianza da un límite inferior de 19.98, lo que da justificaría, con unas garantías del 97.5%, reajustar el ciclo y darle un tamaño de 20 días, reduciendo así considerablemente los parones de un día completo de mantenimiento cada 7 en funcionamiento.Ejemplo 1.22  El gerente de una empresa que se dedica la extracción y venta de piedra natural está preocupado porque piensa que hay un problema con la máquina que se dedica cortar, en bloques más manejables, los bloques de piedra que vienen desde la cantera. La máquina trabaja durante 24 horas al día los 365 días del año, y las especificaciones de calidad establecen que la media y varianza del tiempo hasta que la máquina se detiene por un fallo, \\(TF\\), han de ser de 80 y 50 horas respectivamente.En el histórico de mantenimiento de la empresa se han detectado tres tipos de fallos que se han catalogado como leves, moderados y graves. Además, la información del equipo de mantenimiento indica que el tipo de fallo que se produce está muy relacionado con el tiempo de funcionamiento de la máquina, de forma que la probabilidad de que se produzca un fallo u otro varía de acuerdo la tabla siguiente:Los tiempos de reparación (medidos en minutos), \\(TR\\), tienen medias y varianzas dadas por:Además se sabe que si el fallo es leve, es necesario detener la producción por completo, ya que esta se puede reducir al 60% y seguir trabajando mientras se realiza la reparación. En los otros dos casos la máquina debe detenerse por completo.El gerente está interesado en conocer el funcionamiento de la máquina en los próximos seis meses asumiendo que las variables de tiempo de funcionamiento y tiempo de reparación son de tipo Weibull. En concreto desea saber qué porcentaje del tiempo la máquina estará trabajando pleno rendimiento, rendimiento reducido y parada.Antes de plantear un algoritmo de simulación, tratemos de entender y modelizar bien la secuenciación de variables involucradas, según las especificaciones dadas. Las variables descritas son:\\(TF\\): Tiempo de funcionamiento de la máquina hasta fallo.\\(averia\\): Tipo de avería cuando el sistema falla: leve, moderado, grave. Su distribución depende de \\(tf\\).\\(TR.xx\\): Tiempo de reparación para una avería “xx={leve, moderado, grave},” que depende del tipo de avería.El tiempo de funcionamiento pleno rendimiento vendrá dado por el tiempo acumulado en el que el sistema funciona sin ningún fallo, obtenido de todos los \\(TF\\) simulados. El funcionamiento rendimiento reducido se dará mientras se está reparando alguna avería de tipo leve. El tiempo de parada del sistema corresponde los periodos en los que se está reparando alguna avería de tipo moderada o grave. Puesto que el funcionamiento del sistema depende del tipo de avería, nos interesará guardar información sobre el tipo de avería que se está reparando, información que recopilaremos en la variable \\(averia\\). El tiempo dedicado reparaciones lo guardaremos en una variable global denominada \\(TREPARA\\), que nos permitirá calcular cuándo el sistema funciona pleno rendimiento.\\(TREPARA\\): Tiempo total dedicado reparaciones.En cada simulación nos interesará contabilizar el tiempo transcurrido, en una variable\\(ciclo\\): Tiempo de funcionamiento hasta fallo + tiempo de reparación.Interesa simular el funcionamiento del sistema en los próximos seis meses, de modo que dicho periodo expresado en minutos es de 2.592^{5}, y la simulación parará cuando \\(ttotal<259200\\) minutos, siendo\\(ttotal\\): tiempo total acumulado de funcionamiento y reparaciones.Puesto que nos piden modelizar con distribuciones Weibull y sólo nos han dado su media y su varianza, hemos de calcular los parámetros utilizar, para lo que acudimos la función que ya propusimos en la Ecuación (1.19).Así, tendremos las siguientes distribuciones para el tiempo de funcionamiento \\(tf\\) y los tiempos de reparación \\(tr\\):\\[\\begin{eqnarray*}\nTF &\\sim& Weib(1.64,5365.22) \\\\\nTR.leve &\\sim& Weib(2.10, 33.87)  \\\\\nTR.moderado &\\sim& Weib(2.10, 67.74)  \\\\\nTR.grave &\\sim& Weib(2.90, 134.58).  \n\\end{eqnarray*}\\]Veamos ahora el algoritmo de simulación para este problema.Algoritmo secuencial para el estudio de fallo de la máquinaPaso 1. Inicializar todos las variables temporales 0.Repetir los pasos 2 5 hasta que \\(tiempo > 6*30*24*60 = 259200\\) minutos.Paso 2. Generar \\(tf\\).Paso 2. Generar \\(tf\\).Paso 3. Generar el tipo de averia \\(averia\\) en función de \\(tf\\).Paso 3. Generar el tipo de averia \\(averia\\) en función de \\(tf\\).Paso 4. Generar el tiempo de reparación \\(trepara\\) en función del tipo de avería.Paso 4. Generar el tiempo de reparación \\(trepara\\) en función del tipo de avería.Paso 5. Actualizar el tiempo total acumulado \\(ttotal\\) con el tiempo de funcionamiento y reparación.Paso 5. Actualizar el tiempo total acumulado \\(ttotal\\) con el tiempo de funcionamiento y reparación.Paso 6. Devolver el conjunto de valores simulados.Paso 6. Devolver el conjunto de valores simulados.Mostramos en la Tabla 1.6 las simulaciones obtenidas y damos continuación una breve descripción.\nTabla 1.6: Simulaciones para el sistema de corte de piedra.\nRespondamos ya diversas preguntas de interés.¿Cuál es tiempo total de funcionamiento del sistema, incluidas reparaciones?¿Qué porcentaje del tiempo total el sistema ha estado pleno rendimiento, reducido y en parada?Se concluye que el 99.08% del tiempo durante los seis meses simulados, el sistema ha estado pleno rendimiento, operando sin averías.","code":"\n# Función para simular el proceso de fabricación con tres subprocesos ABC encadenados.\nsimula.proceso=function(nsim, nciclo, alpha, beta, delta, ta, tb, tc){\n# semilla=Semilla aleatoria y nsim=nº simulaciones o ciclos a simular\n#nciclo es el número de días del ciclo\n# alpha, beta y delta son los parámetros de las exponenciales TA,TB,TC\n# ta,tb y tc son los tiempos de funcionamiento diarios para los procesos A, B y C.\nTciclo=Dciclo = rep(0, nsim)   # tiempo de ciclo (en horas T y días D)\nTpotencial = rep(0, nsim)      # tiempo(en horas) que funcionaría sin fallos\nfallo = c()                   # qué proceso ha fallado en cada ciclo\nprocesos = c(\"A\", \"B\", \"C\")\n\n# simulamos las duraciones para todos los ciclos\nTA = rexp(nsim, alpha)  \nTB = rexp(nsim, beta)\nTC = rexp(nsim, delta)\nt = c(ta, tb, tc) # funcionamiento diario de cada proceso\n\nfor(j in 1:nsim){\n  T = c(TA[j], TB[j], TC[j])      # tiempos de vida para el ciclo j\n  nfallo = T/t                  # número días que funcionará cada proceso\n  falla = which.min(nfallo)     # qué proceso falla primero\n  if(nfallo[falla] <= nciclo){  # si falla antes de cerrar el ciclo\n   fallo[j] = procesos[falla]   #identificamos el proceso que falla\n   Dciclo[j] = T[falla]/t[falla]   # y lo pasamos a días\n   Tciclo[j] = Tpotencial[j]=24*Dciclo[j]   # duración del ciclo (en horas)\n  }\n  else{                       #si no falla ninguno antes de cerrar el ciclo\n    Tciclo[j] = 24*7            #cerramos el ciclo sin fallos\n    Dciclo[j] = 7\n    fallo[j] = \"No\"\n    Tpotencial[j] = T[falla]/t[falla]*24    # y guardamos la duración potencial \n  }\n} # fin del for (j)\nresultado = data.frame(ciclo = 1:nsim, fallo,\n                     Tciclo = round(Tciclo, 2),Dciclo = round(Dciclo, 2),\n                     Tpotencial = round(Tpotencial, 2),\n                     DA = round(TA/ta, 2), DB = round(TB/tb, 2), DC = round(TC/tc, 2))\n\nreturn(resultado)\n}\nnciclo = 7; alpha = 1/1000; beta = 1/333; delta = 1/167\nta = 15.6;tb = 5.52; tc = 2.88\nsemilla = 12\n\nset.seed(semilla)\nnsim=5000                  \nsimulacion=simula.proceso(nsim,nciclo,alpha,beta,delta,ta,tb,tc)\nkbl(head(simulacion),caption=\"Simulaciones para el proceso de fabricación con tres subprocesos encadenados A, B y C. Tipo de fallo, tiempos de funcionamiento del sistema (Tciclo en horas, Dciclo en días) y tiempo de funcionamiento potencial (Tpotencial en horas). Días de vida DA, DB, DC de los procesos.\") %>%\n kable_styling(bootstrap_options = \"striped\", full_width = F, position = \"left\")\nm = mean(simulacion$fallo != \"No\")\nerror = sqrt(sum(((simulacion$fallo != \"No\")*1-m)^2) / (nsim^2))\nic.low = m - qnorm(0.975)*error\nic.up = m + qnorm(0.975)*error\ncat(\"Pr(fallo antes del ciclo=\",m)## Pr(fallo antes del ciclo= 0.2876\ncat(\"IC(Probabilidad)=[\",round(ic.low, 4),\",\",round(ic.up, 4),\"]\")## IC(Probabilidad)=[ 0.2751 , 0.3001 ]\n#  Representación gráfica del ciclo de vida: tabla de probabilidades\ng1 = simulacion %>%\n  group_by(fallo) %>%\n  summarise(n = n(), prop = n/nrow(simulacion)) %>%\n  ggplot(aes(x = fallo, y = prop)) +\n    geom_col(aes(fill = fallo), position = \"dodge\") +\n    geom_text(aes(label = scales::percent(prop), \n                  y = prop, group = fallo),\n              position = position_dodge(width = 0.9),\n              vjust = 1.5)+\n  labs(x = \"Tipo de fallo\",y = \"Proporción\")+\n  theme(legend.position = \"none\")\n\n\n# Tiempo de vida en función del ciclo\ng2 <- ggplot(simulacion, aes(fallo, Tciclo)) + \n  geom_boxplot(fill = \"steelblue\") +\n  labs(x = \"Tipo de fallo\", y = \"Tiempo de funcionamiento (horas)\")\ngrid.arrange(g1, g2, nrow = 1)\nm = mean(simulacion$Tpotencial)\nerror = sqrt(sum((simulacion$Tpotencial-m)^2) / (nsim^2))\nic.low = m - qnorm(0.975)*error\nic.up = m + qnorm(0.975)*error\ncat(\"E(Tpotencial)=\",round(m/24, 2))## E(Tpotencial)= 20.54\ncat(\"IC(estimación)=[\",round(ic.low/24, 2),\",\",round(ic.up/24, 2),\"]\")## IC(estimación)=[ 19.98 , 21.11 ]\n# Parámetros tiempo funcionamiento (en minutos)\ntf.params <- estima.weibull(80*60, 50*60); tf.params## [1]    1.64 5365.22\n# Tiempo de reparación para avería leve\ntr.leve <- estima.weibull(30, 15); tr.leve## [1]  2.10 33.87\n# Tiempo de reparación para avería moderada\ntr.moderado <- estima.weibull(60, 30); tr.moderado## [1]  2.10 67.74\n# Tiempo de reparación para avería moderada\ntr.grave <- estima.weibull(120, 45); tr.grave## [1]   2.90 134.58\n# Fijamos semilla y límite de tiempo para la simulación\nsemilla <- 12\nset.seed(semilla)\nTsim <- 259200\n# Incicializamos variables\ntf <- c()\ntrepara <- c()\naveria <- c()\nttotal <- 0\nciclo <- c(0)\n# Creamos variables necesarias para la simulación del tipo de avería:\n# probabilidades de avería leve, moderada y grave\neti <- c(\"leve\", \"moderada\", \"grave\")\npr1 <- c(0.85, 0.10, 0.05)  # si tf<=1500\npr1acu <- cumsum(pr1)\npr2 <- c(0.75, 0.15, 0.10)  # si 1500<tf<=3000\npr2acu <- cumsum(pr2)\npr3 <- c(0.65, 0.20, 0.15)  # si tf>3000\npr3acu <- cumsum(pr3)\n\n#############################\n## Simulación del proceso\n#############################\ni <- 1\nwhile (ttotal<= Tsim)\n{\n  # Tiempo de funcionamiento\n  tf[i] <- rweibull(1, tf.params[1], tf.params[2])\n  # Tipo Averia\n  if(tf[i] <= 1500)\n      averia[i] <-eti[min(which(runif(1) <= pr1acu))]\n  else if(tf[i] > 1500 & tf[i] <= 3000)\n      averia[i] <-eti[min(which(runif(1) <= pr2acu))] \n  else if(tf[i] > 3000)\n       averia[i] <-eti[min(which(runif(1) <= pr3acu))]\n # tiempo de reparación\n  if(averia[i] == \"leve\")\n      trepara[i] <- rweibull(1, tr.leve[1], tr.leve[2])\n  else if(averia[i] == \"moderada\" )\n      trepara[i] <- rweibull(1, tr.moderado[1], tr.moderado[2])\n  else if(averia[i] == \"grave\")\n      trepara[i] <- rweibull(1, tr.grave[1], tr.grave[2]) \n  # actualizamos tiempo total\n  ciclo[i]=tf[i]+trepara[i]\n  ttotal=ttotal+ciclo[i]\n  i <- i + 1\n}\nsimulacion <- data.frame(tf, averia = as.factor(averia), \n                         trepara,tiempo = cumsum(ciclo))\nkbl(head(simulacion),caption = \"Simulaciones para el sistema de corte de piedra.\") %>%\n  kable_classic_2(full_width = F)\n# Descriptivo del sistema\nsummary(simulacion)##        tf               averia      trepara            tiempo      \n##  Min.   :  532.4   grave   : 5   Min.   :  5.171   Min.   :  9779  \n##  1st Qu.: 2460.9   leve    :41   1st Qu.: 21.329   1st Qu.: 84710  \n##  Median : 3878.1   moderada: 9   Median : 33.343   Median :146116  \n##  Mean   : 4687.1                 Mean   : 43.292   Mean   :142494  \n##  3rd Qu.: 6600.7                 3rd Qu.: 59.206   3rd Qu.:204825  \n##  Max.   :13942.6                 Max.   :159.389   Max.   :260174\n# Tiempo total de funcionamiento del sistema (con reparaciones)\nttotal <- last(simulacion$tiempo)\n# Tiempo a pleno rendimiento\ntpleno <- sum(simulacion$tf)\n# Tiempo a rendimiento reducido\ntparcial <-sum((simulacion$averia == \"leve\")*trepara*0.6)\n# Tiempo parado (reparaciones moderadas y graves)\ntdetenido <- sum((simulacion$averia != \"leve\")*trepara)\n# Juntamos los tiempos y calculamos porcentajes sobre el tiempo de funcionamiento total\nkbl(round(100*cbind(ttotal, tpleno, tparcial, tdetenido)/ttotal,2),\n    col.names=c(\"%Tiempo total\",\"%Pleno rendimiento\",\"%Rendimiento reducido\",\"%Parado\")) %>%\n  kable_classic_2(full_width = F)"},{"path":"intro.html","id":"ProEstoc","chapter":"Unidad 1 Conceptos básicos","heading":"1.8 Procesos estocásticos","text":"Una vez hemos recordado cuestiones básicas y distribuciones comunes de probabilidad, la vez que hemos aprendido algunos algoritmos como el de la Transformada Inversa (Sección 1.5 o el de Composición Sección 1.7.2), damos un paso más y presentamos el concepto de procesos estocásticos, que es el objeto de esta asignatura.Definición 1.23  Un proceso estocástico es una secuencia de variables aleatorias \\(\\{X(t), t \\T\\}\\) y que dependen del parámetro \\(t\\), que toma valores en el conjunto índice \\(T\\) o de instantes de tiempo.Se denomina espacio de estados del proceso, \\(S\\), al conjunto de todos los posibles valores de las variables aleatorias que componen el proceso.Si \\(T\\) es un conjunto de tiempos discretos, \\(t = 0, 1, 2, 3,...\\), definidos por ejemplo al finalizar cada día o cada hora, obtenemos un proceso estocástico de tiempo discreto (PETD), \\(\\{X(0), X(1), X(2),...\\}\\).En cambio, si observamos el sistema continuamente lo largo del tiempo \\(t>\\geq 0\\), obtenemos un proceso estocástico de tiempo continuo (PETC), \\(\\{X(t), t \\geq 0\\}\\).El espacio de estados de un proceso puede ser de tipo discreto o continuo, en función de los posibles valores que pueden tomar las variables aleatorias \\(X(t)\\) que lo componen.","code":""},{"path":"intro.html","id":"ejemplos-de-procesos-estocásticos","chapter":"Unidad 1 Conceptos básicos","heading":"1.8.1 Ejemplos de procesos estocásticos","text":"continuación veamos algunos ejemplos de procesos PETD y PETC. Te proponemos identificar en cada uno de ellos cuáles pueden ser las cuestiones de interés investigar.En primer lugar, presentamos algunos ejemplos de procesos estocásticos de tiempo discreto (PETD).Ejemplo 1.23  Sea \\(X_t\\) la temperatura (en grados centígrados) registrada en el aeropuerto de Alicante-Elche las 12:00 horas del día \\(t\\). El espacio de estados del proceso estocástico \\(S\\) viene dado por \\((-20, 50).\\) Esto implica que la temperatura nunca baja de veinte bajo cero ni supera los cincuenta grados; da lugar un espacio de estados continuo.Ejemplo 1.24  Consideramos como \\(X_t\\) la variable aleatoria que registra el número ganador de la en el sorteo diario. Puesto que los números tienen 5 dígitos, el espacio de estados es discreto y viene dado por el conjunto de enteros entre 00000 y 99999.Ejemplo 1.25  Sea \\(X_t\\) la variable aleatoria que registra el valor del IPC al final del mes \\(t\\) para España. En tería el IPC puede tomar cualquier valor ente \\((-\\infty, +\\infty)\\), por lo que el espacio de estados es continuo.Ejemplo 1.26  Sea \\(X_t\\) el número de reclamaciones que recibe una compañía de seguros una semana cualquiera \\(t\\). El espacio de estados es discreto y viene dado por \\(\\{0, 1, 2, 3, 4,...\\}\\).Ejemplo 1.27  Sea \\(X_t\\) el número de accidentes que ocurren en la carretera que une las poblaciones de Elche y Santa Pola en la semana \\(t\\). El espacio de estados es discreto y viene dado por \\(\\{0, 1, 2, 3, 4,...\\}\\).Ejemplo 1.28  Sea \\(X_t\\) el número de productos defectuosos que genera una cadena de producción en cada uno de los lotes fabricados lo largo de un día. El espacio de estados es discreto, \\(\\{0, 1, 2, 3, 4,...\\}\\) y también \\(t\\), que identifica el número de lote producido.Y continuación veamos otros ejemplos de procesos estocásticos de tiempo continuo (PETC).Ejemplo 1.29  Supongamos que una máquina puede estar en dos estados, encendido o apagado. Sea \\(X(t)\\) la variable aleatoria que refleja el estado de la máquina en el instante de tiempo \\(t\\). Entonces \\(\\{X(t), t \\geq 0\\}\\) es un proceso estocástico de tiempo continuo con el espacio de estados discreto, con valores posibles {encendido, apagado}.Ejemplo 1.30  Un ordenador personal (PC) puede ejecutar muchos procesos simultáneamente. Si \\(X(t)\\) es el número de procesos que se ejecutan en dicho PC en el momento \\(t\\). Entonces \\(X(t), t \\geq 0\\) es un proceso estocástico de tiempo continuo con espacio de estados discreto \\(0, 1, 2,...,K\\) ,donde \\(K\\) es el número máximo de trabajos que puede manejar el PC simultáneamente.Ejemplo 1.31  Sea \\(X(t)\\) es el número de clientes que entran una tienda de libros en una franja de tiempo de duración \\(t\\). Entonces \\(X(t), t \\geq 0\\) es un proceso estocástico de tiempo continuo con espacio de estados discreto \\(0, 1, 2,...\\).Ejemplo 1.32  Sea \\(X(t)\\) una variable que recopila información sobre si se produce o un fallo en el sistema de alimentación eléctrico de un circuito lo largo del tiempo. El espacio de estados es discreto, con valores \\(\\{0,1\\}\\).Ejemplo 1.33  Sea \\(X(t)\\) la temperatura en grados centígrados registrada en una localización dada en cualquier instante de tiempo \\(t\\). Entonces \\(X(t), t \\geq 0\\) es un proceso estocástico de tiempo continuo con espacio de estados continuo.","code":""},{"path":"intro.html","id":"función-de-distribución-del-proceso","chapter":"Unidad 1 Conceptos básicos","heading":"1.8.2 Función de distribución del proceso","text":"Los ejemplos anteriores muestran una variedad de problemas que pueden ser modelados y estudiados como procesos estocásticos, y para hacerlo será preciso analizar el comportamiento aleatorio del proceso, sea cual sea la naturaleza de los tiempos, discretos o continuos.Puesto un proceso estocástico es una colección de variables aleatorias, la forma de inferir sobre él es través de la función de distribución conjunta que se construye partir de las variables \\(X(t_1), X(t_2),...,X(t_n)\\):\\[\\begin{equation}\nF(x_1, x_2,...,x_n) = Pr(X(t_1) \\leq x_1, X(t_2) \\leq x_2,..., X(t_n) \\leq x_n) \n\\tag{1.24}\n\\end{equation}\\]donde \\(x_1, x_2,..., x_n \\\\mathbb{R}^n.\\)Si el proceso estocástico tiene una estructura simple, entonces los cálculos son excesivamente complicados, pero suele ser la tónica de procesos útiles para representar sistemas reales. lo largo de los años los investigadores han modelizado y estudiado clases especiales de procesos estocásticos que pueden utilizarse para describir una gran variedad de sistemas reales, resolviendo y posibilitando así los cálculos probabilísticos necesarios, aunque su complejidad en ocasiones haya sido evitable. Las dos clases más importantes de procesos estocásticos ya modelizados son las cadenas de Markov de tiempo discreto (CMTD) y las cadenas de Markov de tiempo continuo (CMTC). Sin embargo, en los últimos años el desarrollo de la computación ha posibilitado el uso intensivo de la simulación para resolver de un modo sencillo cálculos probabilísticos complejos y así analizar fácilmente el comportamiento de los sistemas reales, sin necesidad de extraer analíticamente la distribución de probabilidad conjunta del proceso.En los temas siguientes iremos describiendo este tipo de procesos, mostrando los resultados teórico, pero centrándonos en cómo utilizar las herramientas de simulación disponibles para reproducir el comportamiento del sistemas reales sin necesidad de registrar datos ni de realizar complejos desarrollos probabilísticos.Por analogía con el análisis de variables aleatorias serán relevantes en el estudio de procesos estocásticos, su valor esperado, \\(E[X(t)]\\), su varianza, \\(V[X(t)] = E[X(t)^2] - E[X(t)]^2\\) y la covarianza \\(Cov[X(t), X(s)] = E[X(t)X(s)] - E[X(t)]E[X(s)]\\), que vendrán dadas en función de tiempos \\(t\\) y \\(s\\).","code":""},{"path":"intro.html","id":"ejer-u1","chapter":"Unidad 1 Conceptos básicos","heading":"1.9 Ejercicios","text":"","code":""},{"path":"intro.html","id":"básicos","chapter":"Unidad 1 Conceptos básicos","heading":"1.9.1 Básicos","text":"Ejercicio B1.1. Un proceso de fabricación tiene una tasa de defectos del 20% y los artículos se colocan en cajas de cinco. Un inspector toma muestras de dos artículos de cada caja. Si uno o los dos artículos seleccionados son defectuosos, la caja se rechaza. Si un cliente pide 10 cajas, ¿cuál es el número esperado de artículos defectuosos que recibirá el cliente? Da una aproximación del error y una banda de confianza.Ejercicio B1.2. Un vendedor domicilio vende ollas y sartenes. Sólo entra en el 50% de las casas que visita. De las casas en las que entra, 1/6 de los propietarios están interesados en comprar nada, 1/2 de ellos acaban haciendo un pedido de 60 dólares, y 1/3 de ellos acaban haciendo un pedido de 100 dólares. Estima el promedio de ventas (en dólares) conseguidas para 25 visitas (junto con una medida del error). Estima el promedio de ventas por visita.Ejercicio B1.3. Un contratista de techos independiente ha determinado que el número de trabajos que se solicitan para el mes de septiembre es bastante variable. partir de la experiencia anterior, las probabilidades de obtener 0, 1, 2 o 3 trabajos se han determinado como 0.1, 0.35, 0.30 y 0.25, respectivamente. El beneficio obtenido por cada trabajo es de 300 dólares. ¿Cuál es el beneficio esperado para el mes de septiembre?Ejercicio B1.4. Un sistema de visión está diseñado para medir el ángulo en el que el brazo de un robot se desvía de la vertical. Sin embargo, el sistema de visión es totalmente preciso, y el resultado de las observaciones es una variable aleatoria con una distribución uniforme. Si la medición indica que el rango del ángulo está entre 9.7 y 10.5 grados, aproxima por simulación la probabilidad de que el ángulo real esté entre 9.9 y 10.1 grados y da una medida del error de dicha aproximación.Ejercicio B1.5. En una operación de soldadura automatizada, la posición en la que se coloca la soldadura es muy importante. La desviación del centro de la placa es una variable aleatoria normal con una media de 0 pulgadas y una desviación estándar de 0.01 pulgadas. Una desviación positiva indica una desviación la derecha del centro y una desviación negativa indica una desviación la izquierda del centro.¿Cuál es la probabilidad de que en una placa dada, la ubicación real de la soldadura se desvíe menos de 0.005 pulgadas (en valor absoluto) del centro?¿Cuál es la probabilidad de que en una placa dada, la ubicación real de la soldadura se desvíe más de 0.02 pulgadas (en valor absoluto) del centro?Da aproximaciones del error cometido al aproximar por simulación.Ejercicio B1.6. Un departamento de compras percibe que el 75% de sus pedidos especiales se reciben tiempo. De los pedidos que se reciben tiempo, el 80% cumple totalmente las especificaciones; de los pedidos que llegan con retraso, el 60% cumple con las especificaciones. Responde las siguientes preguntas utilizando simulación, dando también una medida del error.¿Cuál es la probabilidad de que un pedido llegue tiempo y cumpla con las especificaciones?¿Cuál es la probabilidad de que un pedido cumpla con las especificaciones?Si se han recibido cuatro pedidos, ¿cuál es la probabilidad de que los cuatro pedidos cumplan con las especificaciones?Ejercicio B1.7. Una empresa manufacturera tiene tres operarios para una máquina que produce cierto tipo de componentes. El operario tiene una tasa de defectos del 5%, el operario B del 3%, y el operario C del 2%. Los tres operarios producen el mismo número de componentes. Si un componente elegido al azar resulta defectuoso, ¿cuál es la probabilidad de que el componente haya sido producido por , B, o C? Responde la pregunta con simulación y da una medida del error de la aproximación.Ejercicio B1.8. El 1% de los préstamos que hace cierta empresa financiera son saldados (es decir, la cantidad prestada le es devuelta en su totalidad). La compañía efectúa un estudio rutinario de las posibilidades crediticias de los solicitantes. Encuentra que el 30% de los préstamos saldados se hicieron clientes de alto riesgo, el 40% clientes de riesgo moderado y el restante 30% clientes de bajo riesgo. De los préstamos que fueron saldados, el 10% se hicieron clientes de alto riesgo, el 40% clientes de riesgo moderado y el 50% clientes de bajo riesgo. Responde las siguientes preguntas utilizando simulación, dando también una medida del error.¿Cuál es la probabilidad de que un préstamo de alto riesgo sea saldado?¿Cuál es la probabilidad de que una deuda saldada, dado que el riesgo es moderado?Ejercicio B1.9. Se hacen dos inversiones de 10000€ cada una en dos proyectos. Se supone que el proyecto va producir un rendimiento neto de 800, 1000 y 1200 euros con probabilidades respectivas de 0.2, 0.6, 0.2. Se supone que el proyecto B va producir una ganancia neta de 800, 1000, y 1200 euros, con probabilidades respectivas 0.3, 0.4, 0.3. Si asumimos que lo que se gana con un proyecto es independiente de lo que se gana con el otro, responde las siguientes preguntas utilizando simulación, dando también una medida del error.¿Cuál es la probabilidad de que la ganancia total sea de 2000 euros exactamente?¿Cuál es la probabilidad de que la ganancia total sea igual o superior 2000 euros?¿Cuál es la probabilidad de que la ganancia sea inferior 2000 euros?Ejercicio B1.10. Sea \\(X\\) una variable aleatoria de tipo continuo cuya función de densidad viene dada por:\\[\\begin{equation*}\nf(x) = \\frac{5}{3}(1-x^3)x  \\text{ para } 0 \\leq x \\leq 1\n\\end{equation*}\\]Utilizando simulación:Determina la \\(Pr(X \\leq 0.5).\\)Determina la \\(Pr(0.25 \\leq X \\leq 0.75).\\)Determina la \\(Pr(X > 1/3).\\)Ejercicio B1.11. Sea \\(X\\) una variable aleatoria de tipo continuo cuya función de densidad viene dada por:\\[\\begin{equation*}\nf(x) = \\frac{1}{8}x \\text{ para } 0 \\leq x \\leq 4\n\\end{equation*}\\]Utilizando simulación:Determina el valor de \\(t\\) tal que \\(Pr(X \\leq t) = 0.25\\)Determina el valor de \\(t\\) tal que \\(Pr(X \\leq t) = 0.5\\)Ejercicio B1.12. Sea \\(X\\) una variable aleatoria de tipo continuo cuya función de densidad viene dada por:\\[\\begin{equation*}\nf(x) = e^{-x} \\text{ para } x > 0\n\\end{equation*}\\]Utilizando simulación:Determina el valor esperado y la desviación típica de la variable \\(Y = X^{1/2}.\\)Determina \\(Pr(Y \\geq 1).\\)Ejercicio B1.13. Los administradores de cierta industria han probado, por pruebas técnicas, que su producto tiene una vida media de 5 años, y la han descrito con una distribución exponencial. Si el tiempo de garantía asignado por los administradores es de 1 año, ¿qué porcentaje de sus productos será devuelto para reparar durante el periodo de garantía? Aproxima por simulación y da una medida del error.","code":""},{"path":"intro.html","id":"avanzados","chapter":"Unidad 1 Conceptos básicos","heading":"1.9.2 Avanzados","text":"Ejercicio A1.1.Los problemas de inventario tratan de dar respuesta las necesidades de almacenamiento de las empresas para satisfacer la demanda de los consumidores. En concreto, en este caso se plantea el problema de un distribuidor del mercado central especializado en la venta de fresas. Dicho comerciante compra cajas al precio de 20€, y las vende por 50€, y tiene dos problemas relacionados directamente con lo que denominamos “inventario”:Si los clientes solicitan más cajas de las disponibles el comerciante pierde 30€ por cada caja de menos disponible.Si el comerciante almacena más cajas de las solicitadas por los clientes, el producto se debe tirar y pierde 20€ por cada caja que vende.Para tratar de determinar el número de cajas que debe comprar y almacenar, recoge información sobre la demanda realizada por los clientes en la campaña anterior, cuyos datos vienen dados en la tabla siguiente:La empresa proporciona en la tabla siguiente las ganancias esperadas diarias (en euros) asociadas al número de cajas vendidas y las cajas que debería almacenar:En base esta información se debe obtener la ganancia esperada para cada acción de inventario, y determinar aquella que proporcione mayores beneficios, es decir, las mayores ganancias diarias. ¿Qué recomendación se debería hacer al distribuidor?Por otro lado, los asesores convencen al distribuidor de que para tener mayor certeza de sus ganancias debería realizar un estudio marginal, que se basa en el hecho de que cuando se compra una unidad adicional de un artículo (en este caso una caja) pueden ocurrir dos cosas: la unidad se vende o se vende. De esta forma:¿Cuál es la probabilidad de que la demanda sea al menos de 11 cajas? ¿Y de al menos 12? ¿Y de al menos 13?¿Cuál resulta la ganancia y pérdida marginal esperada por la venta o de una caja más con cada una de las probabilidades anteriores?¿Qué opción recomiendas al distribuidor?","code":""},{"path":"cmtd.html","id":"cmtd","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"Unidad 2 Cadenas de Markov de Tiempo Discreto","text":"En esta unidad trabajamos con un tipo especial de proceso estocástico de tiempo discreto: las Cadenas de Markov de Tiempo Discreto, las que aludiremos en adelante como CMTD. Analizamos teóricamente este tipo de procesos y presentamos las herramientas de cálculo y simulación necesarias para poder resolver problemas asociados sistemas reales modelizables con una CMTD. Utilizaremos en R la librería markovchain.29","code":""},{"path":"cmtd.html","id":"definiciones","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.1 Definiciones","text":"Definición 2.1  Un proceso estocástico \\(\\{X(t), t \\\\mathbb{N}^*\\}\\), con \\(\\mathbb{N}^*\\) el conjunto de todos los números naturales incluido el cero, y con espacio de estados de tipo discreto, \\(S\\), se denomina Cadena de Markov de Tiempo Discreto, si para cualquier par de estados \\(\\) y \\(j\\) de \\(S\\) se verifica la propiedad de Markov, esto es, que la probabilidad de que el proceso en un instante \\(t+1\\) se encuentre en un estado \\(j\\), dado su comportamiento previo, sólo depende del estado en el que el sistema se encontraba justamente en el instante anterior \\(t\\), esto es, \\(X(t)=\\), y del estado del proceso en los instantes anteriores \\(t-1, t-2,...,0\\):Utilizaremos indistintamente la siguiente notación:\\[\\{X(n), n \\\\mathbb{N}^*\\}\\equiv \\{X_n,  n \\geq 0\\}\\]La probabilidad condicionada dada en (2.1) se denomina probabilidad de transición de un paso y se denota por \\(p_{ij}(t,t+1)\\), y es la probabilidad de que, dado que el proceso en el instante \\(t\\) está en el estado \\(\\), un instante más tarde, \\(t+1\\) haya cambiado al estado \\(j\\):\\[p_{ij}(t,t+1)=Pr(X(t+1) = j | X(t) = ).\\]De forma similar podemos definir la probabilidad de transición de \\(n\\) pasos, \\(p_{ij}(t,t+n)\\) como la probabilidad de que, dado que el proceso en el instante \\(t\\) está en el estado \\(\\), \\(n\\) instantes más tarde, \\(t+n\\), esté en el estado \\(j\\) :Las probabilidades de transición así definidas cumplen que:Definición 2.2  Una \\(CMTD\\) dada por \\(\\{X(t), t \\\\mathbb{N}\\}\\) es homogénea cuando tiene probabilidades de transición estacionarias, es decir, cuando \\(p_{ij}(t, t+n)\\) depende de \\(t\\), es decir, la probabilidad de cambiar del estado \\(\\) al estado \\(j\\) en \\(n\\) pasos es independiente del instante temporal en que se encuentre el proceso:En este curso sólo estudiaremos \\(CMTD\\) homogéneas, por lo que para simplificar la notación, partir de ahora las denotaremos como \\(p_{ij}(n)\\) las probabilidades de transición de \\(n\\) pasos y \\(p_{ij}\\) las probabilidades de transición de un paso: \\[\\begin{eqnarray*}\np_{ij} &=& Pr[X(t+1) = j | X(t) = ] \\\\\np_{ij}(n) &=& Pr[X(t+n) = j | X(t) = ].\n\\end{eqnarray*}\\]Definición 2.3  El comportamiento aleatorio de una \\(CMTD\\) está completamente determinado por las probabilidades de transición de la cadena y la distribución del estado inicial, de forma que la función de distribución del proceso en un instante de tiempo \\(t\\) se calcula, mediante el teorema de la probabilidad total, según la Ecuación (2.3).con \\(p_i(0) = Pr(X(0) = )\\) la probabilidad de que en el instante inicial el proceso se encuentre en el estado \\(\\). De hecho, el vector\\[p(0) = \\{p_i(0)= Pr[X(0) = ], \\ \\S\\}\\]\nse denomina distribución inicial de la cadena e identifica la distribución de probabilidad del proceso en el instante inicial o punto de partida del proceso.En formato matricial, cuando el espacio de estados es finito, \\(S=\\{1,...,N\\}\\), la distribución marginal transcurridas \\(n\\) transiciones en el proceso, se obtendrá partir del vector de probabilidades iniciales \\(p(0) =(p_1(0),p_2(0),\\ldots,p_N(0))\\) y la matriz de transición \\(p=(p_{ij})_{,j =1,...,N}\\),\\[\\begin{equation}\np(n)=p(0) %*% p\n\\end{equation}\\]De forma habitual se suelen expresar las probabilidades de transición de un paso para \\(N\\) estados en una \\(CMTD\\) mediante la denominada matriz de transición de un paso \\(P\\), que es una matriz estocástica con todos sus elementos constituidos por probabilidades, dada por:\\[P = \n\\begin{pmatrix}\np_{11} & p_{12} & ... & p_{1N}\\\\\np_{21} & p_{22} & ... & p_{2N}\\\\\n... & ... & ... & ...\\\\\np_{N1} & p_{N2} & ... & p_{NN}\n\\end{pmatrix}\\]La información sobre las probabilidades de transición también puede representarse de forma gráfica construyendo un diagrama de transición del \\(CMTD\\). Un diagrama de transición es un grafo dirigido con \\(N\\) nodos, un nodo por cada estado del \\(CMTD\\). Hay un arco dirigido que va del nodo \\(\\) al nodo \\(j\\) en el grafo si la transición del estado \\(\\) al estado \\(j\\) es viable, esto es, \\(p_{ij} \\neq 0\\). Los diagramas de transición se pueden utilizar como herramienta para visualizar la dinámica de la \\(CMTD\\).De forma similar podemos definir la matriz de transición de n pasos con la matriz estocástica \\(P(n)\\):\\[P(n) = \n\\begin{pmatrix}\np_{11}(n) & p_{12}(n) & ... & p_{1N}(n)\\\\\np_{21}(n) & p_{22}(n) & ... & p_{2N}(n)\\\\\n... & ... & ... & ...\\\\\np_{N1}(n) & p_{N2}(n) & ... & p_{NN}(n)\n\\end{pmatrix}\\]con \\[\\begin{eqnarray*}\n0 \\leq p_{ij}(n) &\\leq& 1 \\\\\n\\sum_{j \\S} p_{ij}(n) &=& 1.\n\\end{eqnarray*}\\]De forma genérica denotamos por \\(p(n)\\) la distribución del proceso en la n-ésima transición:\\[p(n) = \\{p_i(n)=Pr[X(n)=], \\ \\S\\}\\]Cualquier \\(CMTD\\) homogénea verifica la denominada Ecuación de Chapman-Kolmogorov que permite calcular la probabilidad de transición de un estado \\(\\) un estado \\(j\\) en \\(n\\) pasos través de todas las probabilidades de transición de \\(s\\) y \\(n-s\\) pasos, para cualquier \\(s<n\\) y cualquier \\(\\) y \\(j\\) en \\(S\\):Definición 2.4  Haciendo uso de la ecuación (2.4) se puede demostrar que la matriz de transición de \\(n\\) pasos \\(P(n)\\) se puede obtener como la potencia \\(n\\) de la matriz de transición de un paso \\(P\\), esto es,de modo que conociendo la distribución inicial del proceso \\(p(0)\\) y la matriz de transición de un paso \\(P\\), tenemos perfectamente identificada la distribución del proceso en cualquier momento:Para calcular la matriz de transición de \\(n\\) pasos en R habrá que utilizar el producto matricial para obtener estas matrices. Definimos entonces una función que nos permitirá calcularla partir de la matriz de transición de un paso.","code":"\n# Matriz de probs. transición de n pasos\nptran.n=function(ptran,n){\n  # ptran es la matriz de transición de 1 paso\n  # n son los pasos a dar\n  i=1\n  p=ptran\n  while(i<n){\n    p=p%*%ptran\n    i=i+1\n  }\nreturn(p)  \n}"},{"path":"cmtd.html","id":"libMC","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.2 Librería markovchain","text":"Para trabajar con procesos \\(CMTD\\) con R es útil la librería markovchain.30 Trabajamos continuación sobre un problema sencillo, para crear la matriz y el diagrama de transición de la cadena de Markov.Ejemplo 2.1  Tenemos una \\(CMTD\\) \\(\\{X(t), t \\\\mathbb{N}\\}\\) con espacio de estados \\(S = \\{, b, c\\}\\) y distribución inicial de la cadena dada por \\(p_a(0)=0.4, p_b(0)=0.2\\) y \\(p_c(0)=0.4\\). La matriz de transición de un paso viene dada por:\\[P = \n\\begin{pmatrix}\n0.20 & 0.30 & 0.50\\\\\n0.10 & 0.00 & 0.90\\\\\n0.55 & 0.00 & 0.45\n\\end{pmatrix}\\]Planteamos resolver las cuestiones siguientes:(1). Queremos representar el proceso través de un grafo.Para representar el proceso con markovchain, hemos de crear un vector con los estados y la matriz de transición con las probabilidades de transición. Definimos entonces el proceso con la función genérica new() para generar un objeto del tipo markovchain:\\[new(\"markovchain\",states,byrow=TRUE,transitionMatrix)\\]introduciendo el vector de estados en states, la matriz de transición en transitionMatrix, y especificando si dicha matriz se ha de leer por filas.continuación lo pintamos con la función plot().Procedemos con el ejemplo que nos atañe. El grafo en la Figura 2.1 muestra los tres estados como nodos y las probabilidades de transición para pasar de un estado otro en un único paso.\nFigura 2.1: Grafo del proceso.\n(2). Si la \\(CMTD\\) está en el estado \\(c\\) en el momento 17, ¿cuál es la probabilidad de que esté en el estado \\(\\) en el momento 18?RESPUESTA: Nos preguntan por la probabilidad de transición para pasar, en un solo paso, del estado \\(c\\) (3) al estado \\(\\) (1), por lo que viene dada por la componente \\(p_{31}\\) de la matriz de transición, es decir, 0.55.Para resolver el cálculo con el ordenador basta utilizar la función transitionProbability(), con los argumentos: object (la cadena de markov), t0 (el estado en el instante inicial), t1 (el estado en el instante final).Así la pregunta (2) se responde con:(3). Si la \\(CMTD\\) está en el estado \\(c\\) en un momento dado, ¿cuál es la probabilidad de que esté en el estado \\(\\) transcurridos tres unidades de tiempo? ¿y después de 10?RESPUESTA: Para resolver esta cuestión definimos el estado inicial y lo multiplicamos por la matriz de transición que corresponda, que en este caso, aplicando la Ecuación (2.5), será \\(P^n\\), para \\(n=3\\) y \\(n=10\\). Obtendremos así la distribución de probabilidad en \\(n\\) transiciones, con la probabilidad de llegar cada uno de los eventos posibles, \\(\\{,b,c\\}\\) en \\(n\\), partiendo de un estado inicial dado.(4). ¿Cuál es la distribución de probabilidad del proceso transcurridos \\(10\\) instantes de tiempo desde el momento inicial del proceso, sea cual sea su estado?RESPUESTA: Si conocemos la distribución de probabilidad en el estado inicial, \\(p(0)\\), podemos obtener la distribución de probabilidad en \\(n\\) transiciones con la Ecuación :En base la distribución del proceso tras \\(n=10\\) pasos, apreciamos que lo más probable es que el sistema se ecuentre en el estado “c” (prob=0.52), y lo menos probable es que se encuentre en el estado “b” (prob=0.11).(5). Corroborar los resultados analíticos obtenidos en (4) con simulaciones.RESPUESTA: Para ver el comportamiento de un proceso después de que transcurran \\(n\\) pasos habrá que simularlo durante \\(n\\) instantes de tiempo. Puesto que buscamos una estimación de lo que va ocurrir en ese momento, simularemos \\(nsim=100\\) veces el proceso hasta el instante \\(n=10\\), nos quedaremos con el estado en que se encuentra el proceso en ese instante \\(n\\) y evaluaremos las probabilidades obtenidas para los tres estados \\(\\{,b,c\\}\\). Los resultados serán más próximos la solución analítica, cuanto mayor sea el número de simulaciones (prueba modificar \\(nsim\\)).Para simular una CMTD hasta una transición \\(n\\) con la librería markovchain\nbasta utilizar la función rmarkovchain(n, proceso), donde proceso ha sido definido previamente con la función new().","code":"\nrequire(markovchain)\n# Definimos estados\nestados <- c(\"a\", \"b\", \"c\")\n# Creamos la matriz de transición \npmat <- matrix(data = c(0.20, 0.30, 0.50, 0.10, 0.00, 0.90,0.55, 0.00, 0.45), \n               byrow = TRUE, nrow = 3, \n               dimnames = list(estados, estados))\n# Creamos la CMTD\nproceso <- new(\"markovchain\", states = estados, \n               byrow = TRUE, transitionMatrix = pmat)\n# Verificamos los datos introducidos\nproceso## Unnamed Markov chain \n##  A  3 - dimensional discrete Markov Chain defined by the following states: \n##  a, b, c \n##  The transition matrix  (by rows)  is defined as follows: \n##      a   b    c\n## a 0.20 0.3 0.50\n## b 0.10 0.0 0.90\n## c 0.55 0.0 0.45\n# y obtenemos el diagrama del proceso\nplot(proceso)\ntransitionProbability(object = proceso, t0 = \"c\", t1 = \"a\")## [1] 0.55\n# Estado inicial en c\nsini <- c(0, 0, 1)\n# matriz de transición de 3 pasos\nmt3 <- ptran.n(pmat,3);mt3##          a       b        c\n## a 0.402250 0.10350 0.494250\n## b 0.356250 0.15450 0.489250\n## c 0.350625 0.10725 0.542125\n# o bien extrayendo la matriz de transición del proceso\nptran.n(proceso[1:3,1:3],3)##          a       b        c\n## a 0.402250 0.10350 0.494250\n## b 0.356250 0.15450 0.489250\n## c 0.350625 0.10725 0.542125\n# Situación del proceso dentro de 3 instantes\nsini%*%mt3##             a       b        c\n## [1,] 0.350625 0.10725 0.542125\n# matriz de transición de 10 pasos\nmt10 <-ptran.n(pmat,10)\n# Situación del proceso dentro de 10 instantes\nsini%*%mt10##              a         b         c\n## [1,] 0.3703899 0.1110948 0.5185153\n### Distribución de probabilidad del proceso dentro de 10 instantes\n# Distribución de  probabilidad inicial\ndini <- c(0.4, 0.2, 0.4)\n# matriz de transición de 10 pasos\nmt10 <- ptran.n(pmat,10)\n# distribución de probabilidad marginal en 10 pasos: inicial x condicional\ndini%*%mt10##             a         b         c\n## [1,] 0.370364 0.1111134 0.5185226\n### Simulación del proceso para n=10 instantes \nres=vector()\nnsim=100\nn=10\nfor(i in 1:nsim){\n  res[i]=rmarkovchain(n, proceso)[n]}\nprop.table(table(res))## res\n##    a    b    c \n## 0.31 0.12 0.57"},{"path":"cmtd.html","id":"ExCMTD","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3 Aplicaciones","text":"Las aplicaciones de las CMTD son muy numerosas. continuación presentamos una colección de ejemplos basados en aplicaciones prácticas de estos procesos, con algunos de los cuales trabajaremos lo largo de la unidad.","code":""},{"path":"cmtd.html","id":"CM01","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.1 Colas de espera","text":"Supongamos una consulta médica en un centro de salud, en el que los pacientes que llegan se colocan en una única cola de espera, son atendidos consecutivamente y sólo se atiende un paciente en cada periodo de 5 minutos. Consideramos las variables aleatorias:\\(Y_n:\\) Número de clientes que acuden la consulta durante el n-ésimo periodo de servicio, con posibles valores \\(\\{0, 1, 2,...\\}\\) donde\\[Pr(Y_n = k) = a_k, \\quad k=0, 1, 2,...; \\quad 0 \\leq a_k \\leq 1; \\quad \\sum_{k=0}^{\\infty} a_k =1\\]\\(X_n:\\) Número de pacientes que hay esperando en la cola en el momento que empieza el n-ésimo periodo de servicio, con posibles valores \\(\\{0, 1, 2,...\\}\\), que conforman un proceso estocástico discreto con:de forma que cada \\(X_n\\) sólo dependerá de lo que haya ocurrido en el periodo inmediatamente anterior, luego \\(\\{X_n, n \\\\mathbb{N}\\}\\) es una \\(CMTD\\), con probabilidades de transición dadas por:La matriz de transición viene dada por:\\[P = \n\\begin{pmatrix}\na_0 & a_1 & a_2 & a_3 &...& a_j & ...\\\\\na_0 & a_1 & a_2 & a_3 &...& a_j & ...\\\\\n0 & a_0 & a_1 & a_2 &...& a_{j-1} & ...\\\\\n0 & 0 & a_0 & a_1 &...& a_{j-2} & ...\\\\\n... & ... & ... & ... &...& ... & ...\n\\end{pmatrix}\\]","code":""},{"path":"cmtd.html","id":"fiabilidad","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.2 Fiabilidad de máquinas","text":"La empresa Depend--Us fabrica una máquina que está encendida o apagada (“”/“”). Si está “” al principio de un día, entonces está “” al principio del día siguiente con una probabilidad de 0.98 (independientemente del historial de la máquina), o falla con una probabilidad de 0.02. Una vez que la máquina falla, la empresa envía una persona para que la repare. Si la máquina está averiada al principio de un día, está “” al principio del día siguiente con una probabilidad de 0.03 (independientemente del historial de la máquina), o la reparación se completa y la máquina está “” con probabilidad de 0.97. Una máquina reparada está como nueva.Podemos modelar este sistema mediante una \\(CMTD\\) si consideramos la variable aleatoria \\(X_n\\) que refleja el estado de la máquina en el día \\(n\\) definida como:de forma que la matriz de transicción viene dada por:\\[P = \n\\begin{pmatrix}\n0.03 & 0.97\\\\\n0.02 & 0.98\n\\end{pmatrix}\\]Supongamos ahora que la empresa mantiene dos máquinas de este tipo que son idénticas, se comportan de forma independiente y cada una tiene su propio reparador.Sea \\(Y_n\\) el número de máquinas en estado “” al principio del día \\(n\\), que constituye una CMTD cuyo espacio de estados es \\(\\{0, 1, 2\\}\\), puesto que la situación de las máquinas un día cualquiera sólo depende de cómo estaban el día anterior (cumplen la Ecuación (2.1).Calculemos la probabilidad de transición para un caso concreto: \\(Y_n = = 1\\) e \\(Y_{n+1} = j = 0\\), que identifica una situación en la que una máquina está en funcionamiento y otra en paro el día \\(n\\), pero al día siguiente ambas están paradas. Así, la máquina que está “” el día \\(n\\) debe permanecer “” al día siguiente, y la máquina que está “” debe cambiar “” el día siguiente. Como las máquinas son independientes, la probabilidad de cambio de estado es:\\[p_{10}=Pr[Y_{n+1} = 0 | Y_n = 1] = 0.03 * 0.02 = 0.0006\\] Procediendo de la misma forma obtenemos la matriz completa de transición de un paso del proceso como:\\[P = \n\\begin{pmatrix}\n0.0009 & 0.0582 & 0.9409\\\\\n0.0006 & 0.0488 & 0.9506\\\\\n0.0004 & 0.0392 & 0.9604\n\\end{pmatrix}\\]Representamos continuación este sistema en forma de grafo en la Figura 2.2. Para ello acudimos la librería markovchain.\nFigura 2.2: Diagrama del sistema de fiabilidad\n","code":"\n# Definimos estados\nestados <- c(\"0\", \"1\", \"2\")\n# Matriz de transición \npmat <- matrix(data = c(0.0009, 0.0582, 0.9409, \n                        0.0006, 0.0488, 0.9506, \n                        0.0004, 0.0392, 0.9604), \n               byrow = TRUE, nrow = 3, \n               dimnames = list(estados, estados))\n# CMTD\nfiabilidad <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, \n                 name = \"Fiabilidad\")\n# Verificamos los datos introducidos\nfiabilidad## Fiabilidad \n##  A  3 - dimensional discrete Markov Chain defined by the following states: \n##  0, 1, 2 \n##  The transition matrix  (by rows)  is defined as follows: \n##       0      1      2\n## 0 9e-04 0.0582 0.9409\n## 1 6e-04 0.0488 0.9506\n## 2 4e-04 0.0392 0.9604\n# Diagrama\nplot(fiabilidad, vertex.color=\"steelblue\", \n     vertex.label.font = 2, \n     edge.label.size = 0.1,\n     edge.arrow.size=0.5, \n     vertex.shape = \"rectangle\", \n     vertex.size = 20)"},{"path":"cmtd.html","id":"meteo","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.3 Meteorología","text":"El tiempo en la ciudad de Heavenly se clasifica como soleado, nublado o lluvioso. Supongamos que el tiempo de mañana depende sólo del tiempo de hoy de la siguiente manera: si hoy hace sol, mañana estará nublado con una probabilidad de 0.3 y lluvioso con probabilidad 0.2; si hoy está nublado, mañana estará soleado con probabilidad 0.5 y lluvioso con probabilidad 0.3; y finalmente, si hoy está lluvioso, mañana estará soleado con probabilidad 0.4 y nublado con probabilidad 0.5.Consideramos la variable aleatoria \\(X_n\\) que registra las condiciones meteorológicas del día \\(n\\) como:de forma que el proceso \\(\\{X_n, n \\\\mathbb{N}\\}\\) con espacio de estados \\(S = \\{1, 2, 3\\}\\) se puede considerar como una \\(CMTD\\), cuya matriz de transición se puede obtener de forma muy rápida como:\\[P = \n\\begin{pmatrix}\n0.50 & 0.30 & 0.20\\\\\n0.50 & 0.20 & 0.30\\\\\n0.40 & 0.50 & 0.10\n\\end{pmatrix}\\]Representamos continuación este sistema en forma de grafo en la Figura 2.3.\nFigura 2.3: Diagrama del sistema de metereología\n","code":"\n# Definimos estados\nestados <- c(\"Soleado\", \"Nublado\", \"LLuvioso\")\n# Matriz de transición \npmat <- matrix(data = c(0.50, 0.30, 0.20, \n                        0.50, 0.20, 0.30, \n                        0.40, 0.50, 0.10), \n               byrow = TRUE, nrow = 3, \n               dimnames = list(estados, estados))\n# CMTD\nmeteo <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, \n             name = \"Meteorología\")\n# Verificamos los datos introducidos\nmeteo## Meteorología \n##  A  3 - dimensional discrete Markov Chain defined by the following states: \n##  Soleado, Nublado, LLuvioso \n##  The transition matrix  (by rows)  is defined as follows: \n##          Soleado Nublado LLuvioso\n## Soleado      0.5     0.3      0.2\n## Nublado      0.5     0.2      0.3\n## LLuvioso     0.4     0.5      0.1\n# Diagrama\nplot(meteo, vertex.color=\"steelblue\", \n     vertex.label.font = 2, \n     edge.label.size = 0.1,\n     edge.arrow.size=0.5, \n     vertex.shape = \"rectangle\", \n     vertex.size = 60)"},{"path":"cmtd.html","id":"inventario","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.4 Problema de inventario","text":"Computers-R-Us almacena una amplia variedad de PCs para la venta al por menor. La tienda abre de lunes viernes de 8:00 .m. 5:00 p.m., y utiliza la siguiente política operativa para controlar el inventario al inicio de semana, en función del número de PCs que quedan en stock el viernes de la semana anterior las 5:00 p.m:Si el stock al finalizar una semana es inferior dos, se piden suficientes ordenadores para disponer de un stock total de cinco al inicio la semana siguiente.Si el stock al finalizar una semana es inferior dos, se piden suficientes ordenadores para disponer de un stock total de cinco al inicio la semana siguiente.Si el stock al final de la semana es de dos o más, se realiza ningún pedido.Si el stock al final de la semana es de dos o más, se realiza ningún pedido.La demanda de ordenadores durante la semana es una variable aleatoria de Poisson con media 3. Cualquier demanda que pueda ser satisfecha inmediatamente se pierde.Se consideran las variables aleatorias:\\(X_n:\\) número de PCs en stock las 8:00 .m del lunes de la semana \\(n\\).\\(D_n:\\) número de PCs demandados durante la semana \\(n\\).De esta forma el número de Pcs que hay en la tienda al inicio de la semana \\(n+1\\) viene dado por los que habían en stock al inicio de la semana anterior menos los que se han vendido, siempre que dicho balance sea al menos de 2 unidades, y será de 5 en otro caso:Necesariamente entonces, \\(X_{n+1} \\geq X_n\\) dado que \\(D_n \\geq 0\\).Se trata de una CMTD con espacio de estados \\(\\{2, 3, 4, 5\\}\\), puesto que el estado del sistema en la semana \\(n+1\\) sólo depende de su estado en la semana anterior \\(n\\). Calculemos las probabilidades de transición.Para \\(j= 2, 3, 4\\)\\[\\begin{array}{ll}\nPr[X_{n+1}  = j | X_n = ] & = Pr[X_n - D_n = j | X_n = ]\\\\\n& = Pr[D_n=X_n-j | X_n = ]\\\\\n& = Pr[D_n = - j] \\\\\n&=\\begin{cases}\nPr[D_n = - j] \\quad \\text{ si } \\geq j \\\\\n0 \\qquad \\qquad \\qquad \\quad \\text{ si } < j\n\\end{cases}\n\\end{array}\\]Para \\(j=5\\) e \\(5>\\geq 2\\)\\[\\begin{array}{ll}\nPr[X_{n+1}  = 5 | X_n = ] & = Pr[X_n - D_n \\leq 1 | X_n = ]\\\\\n&=Pr[D_n \\geq X_n-1|X_n=] \\\\\n& = Pr(D_n \\geq - 1).\n\\end{array}\\]Para \\(j=5\\) e \\(=5\\), podría ocurrir que durante la semana anterior se hubiera vendido nada \\(D_n=0\\) o se hubieran vendido al menos cuatro ordenadores, \\(D_n \\geq 4\\) (para dejar un stock inferior 2),\\[\\begin{array}{ll}\nPr[X_{n+1}  = 5 | X_n = 5] & = Pr[X_n - D_n =5 | X_n = 5]\\\\\n&=Pr[D_n =0] + Pr(D_n \\geq 4).\n\\end{array}\\]Usando el hecho de que la variable \\(D_n \\sim Po(3)\\) podemos obtener la tabla de probabilidades siguientes:Usando los datos de esta tabla calculamos fácilmente la matriz de transición asociada la \\(CMTD\\) como:\\[P = \n\\begin{pmatrix}\n0.0498 & 0 & 0 & 0.9502\\\\\n0.1494 & 0.0498 & 0 & 0.8008\\\\\n0.2240 & 0.1494 & 0.0498 & 0.5768\\\\\n0.2240 & 0.2240 & 0.1494 & 0.4026\n\\end{pmatrix}\\]Representamos continuación este sistema en forma de grafo en la Figura 2.4.\nFigura 2.4: Diagrama del sistema de inventario\n","code":"\n# Definimos estados\nestados <- c(\"2 PCs\", \"3 PCs\", \"4 PCs\", \"5 PCs\")\n# Matriz de transición \npmat <- matrix(data = c(0.0498, 0, 0, 0.9502, \n                        0.1494, 0.0498, 0, 0.8008,  \n                        0.2240, 0.1494, 0.0498, 0.5768,\n                        0.2240, 0.2240, 0.1494, 0.4026), \n               byrow = TRUE, nrow = 4, \n               dimnames = list(estados, estados))\n# CMTD\ninventario <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, \n                 name = \"inventario\")\n# Verificamos los datos introducidos\ninventario## inventario \n##  A  4 - dimensional discrete Markov Chain defined by the following states: \n##  2 PCs, 3 PCs, 4 PCs, 5 PCs \n##  The transition matrix  (by rows)  is defined as follows: \n##        2 PCs  3 PCs  4 PCs  5 PCs\n## 2 PCs 0.0498 0.0000 0.0000 0.9502\n## 3 PCs 0.1494 0.0498 0.0000 0.8008\n## 4 PCs 0.2240 0.1494 0.0498 0.5768\n## 5 PCs 0.2240 0.2240 0.1494 0.4026\n# Diagrama\nplot(inventario, vertex.color=\"steelblue\", \n     vertex.label.font = 2, \n     edge.label.size = 0.1,\n     edge.arrow.size=0.5, \n     vertex.shape = \"rectangle\", \n     vertex.size = 40)"},{"path":"cmtd.html","id":"planificacion","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.5 Planificación de mano de obra","text":"Paper Pushers, Inc. es una empresa de seguros que emplea 100 trabajadores organizados en cuatro grados, etiquetados como \\(1\\), \\(2\\), \\(3\\) y \\(4\\). Por razones de simplicidad, supondremos que los trabajadores pueden ser promovidos de un grado otro, o dejar la empresa, sólo al principio de la semana. Un trabajador en el grado 1 al principio de la semana asciende al grado 2 con probabilidad 0.03, deja la empresa con una probabilidad de 0.02, o continúa en el mismo grado al principio de la semana siguiente. Un trabajador que se encuentra en el grado 2 al principio de la semana asciende al grado 3 con probabilidad 0.01, abandona la empresa con probabilidad 0.008 o continúa en el mismo grado al principio de la semana siguiente. Un trabajador de grado 3 al principio de la semana asciende al grado 4 con una probabilidad de 0.005, abandona la empresa con una probabilidad de 0.02, o continúa en el mismo grado al principio de la semana siguiente. Un trabajador que se encuentra en el grado 4 al principio de la semana deja la empresa con una probabilidad de 0.01 o continúa en el mismo grado al principio de la semana siguiente. Si un trabajador abandona la empresa, es sustituido instantáneamente por otro de grado 1. El movimiento de los trabajadores dentro de la empresa puede modelizarse utilizando una \\(CMTD\\).Supondremos que todos los ascensos de los trabajadores se deciden de manera independiente. Esto simplifica considerablemente nuestro modelo. En lugar de hacer un seguimiento de los 100 trabajadores, tenemos en cuenta un único trabajador, digamos el trabajador \\(k\\), donde \\(k = 1, 2,...,100\\). Pensamos en \\(k\\) como un ID de trabajador, y cuando este trabajador deja la empresa, se le asigna al nuevo sustituto. Sea \\(X_n^k\\) el grado en el que se encuentra el trabajador \\(k\\) al principio de la n-ésima semana. Ahora, si suponemos que los ascensos de los trabajadores se determinan independientemente del historial del trabajador (es decir, que el tiempo transcurrido en un grado determinado afecta las posibilidades de promoción), vemos que para \\(k = 1, 2,...,100\\) el conjunto \\(\\{X_n^k, n \\\\mathbb{N}\\}\\) es una \\(CMTD\\) con espacio de estados \\(S =\\{1, 2, 3, 4\\}\\).Para obtener la matriz de transiciones procedemos con un ejemplo. Supongamos que \\(X_n^k = 3\\) entonces:Si es promocionado (\\(X_{n+1}^k = 4\\)), tenemos que \\(Pr[X_{n+1}^k = 4 | X_n^k = 3] = 0.005.\\)Si deja la empresa, es reemplazado por un nuevo empleado de grado 1 (\\(X_{n+1}^k = 1\\)) de forma que \\(Pr[X_{n+1}^k = 1 | X_n^k = 3] = 0.02.\\)Si se mantiene en el mismo puesto, tenemos que \\(Pr[X_{n+1}^k = 3 | X_n^k = 3] = 0.975.\\)Procediendo de forma similar en el resto de situaciones tenemos la matriz de transición para cualquiera de los trabajadores como:\\[P = \n\\begin{pmatrix}\n0.970 & 0.030 & 0 & 0\\\\\n0.008 & 0.982 & 0.010 & 0\\\\\n0.020 & 0 & 0.975 & 0.005\\\\\n0.010 & 0 & 0 & 0.990\n\\end{pmatrix}\\]Representamos continuación este sistema en forma de grafo en la Figura 2.5.\nFigura 2.5: Diagrama del sistema de planificación\n","code":"\n# Definimos estados\nestados <- c(\"1\", \"2\", \"3\", \"4\")\n# Matriz de transición \npmat <- matrix(data = c(0.9700, 0.0300, 0, 0, \n                        0.0080, 0.9820, 0.0100, 0,   \n                        0.0200, 0, 0.9750, 0.0050,\n                        0.0100, 0, 0, 0.9900), \n               byrow = TRUE, nrow = 4, \n               dimnames = list(estados, estados))\n# CMTD\nplanificacion <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, \n                 name = \"planificacion\")\n# Verificamos los datos introducidos\nplanificacion## planificacion \n##  A  4 - dimensional discrete Markov Chain defined by the following states: \n##  1, 2, 3, 4 \n##  The transition matrix  (by rows)  is defined as follows: \n##       1     2     3     4\n## 1 0.970 0.030 0.000 0.000\n## 2 0.008 0.982 0.010 0.000\n## 3 0.020 0.000 0.975 0.005\n## 4 0.010 0.000 0.000 0.990\n# Diagrama\nplot(planificacion, vertex.color=\"steelblue\", \n     vertex.label.font = 2, \n     vertex.label.color = \"white\",\n     edge.label.size = 0.2,\n     edge.arrow.size=0.5, \n     vertex.shape = \"rectangle\",\n     vertex.size = 20)"},{"path":"cmtd.html","id":"mercadovalores","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.6 Mercado de valores","text":"Las acciones ordinarias de la empresa Gadgets-R-Us se cotizan en el mercado de valores. El director financiero de Gadgets-R-Us compra y vende las acciones de su propia empresa para que el precio nunca baje de 2 dólares y nunca supere los 10 dólares (cuando esto ocurre, vende). Para simplificar, suponemos que \\(X_n\\), es el precio de cada acción al final del día \\(n\\), y sólo toma valores enteros; es decir, el espacio de estados del proceso \\(\\{X_n, n \\\\mathbb{N}\\}\\) es \\(S = 2, 3,...,10\\). Si denominamos \\(I_{n+1}\\) al movimiento potencial del precio de las acciones en el día \\(n+1\\) en ausencia de cualquier intervención del director financiero, entonces tenemos que:Un análisis continuado de los datos del pasado sugiere que los movimientos potenciales \\(\\{I_n, n \\geq 1\\}\\) son una secuencia de variables iid con función de masa de probabilidad dada por:\\[Pr(I_n = k) = 0.2, \\quad k = -2, -1, 0, 1, 2.\\]Esto implica que \\(\\{X_n, n \\\\mathbb{N}\\}\\) es una \\(CMTD\\) con espacio de estados \\(S = \\{2, 3,...,10\\}\\), donde las probabilidades de transición se pueden obtener de forma sencilla. modo de ejemplo presentamos los tres casos siguientes:\\[\\begin{array}{ll}\nPr[X_{n+1} = 2 | X_n = 3] & = Pr[X_n + I_{n+1} \\leq 2 | X_n = 3]\\\\\n& = Pr[I_{n+1} \\leq -1]= 0.4\n\\end{array}\\]\\[\\begin{array}{ll}\nPr[X_{n+1} = 6 | X_n = 5] & = Pr[X_n + I_{n+1} = 6 | X_n = 5]\\\\\n& = Pr[I_{n+1} = 1]  = 0.2\n\\end{array}\\]\\[\\begin{array}{ll}\nPr[X_{n+1} = 10 | X_n = 10] & = Pr[X_n + I_{n+1} \\geq 10 | X_n = 10]\\\\\n& = Pr[I_{n+1} \\geq 0] = 0.6\n\\end{array}\\]de forma que la matriz de transición del sistema viene dada por:\\[P = \n\\begin{pmatrix}\n0.6 & 0.2 & 0.2 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n0.4 & 0.2 & 0.2 & 0.2 & 0 & 0 & 0 & 0 & 0\\\\\n0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0 & 0 & 0 & 0\\\\\n0 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0 & 0 & 0\\\\\n0 & 0 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0 & 0\\\\\n0 & 0 & 0 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0\\\\\n0 & 0 & 0 & 0 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2\\\\\n0 & 0 & 0 & 0 & 0 & 0.2 & 0.2 & 0.2 & 0.4\\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0.2 & 0.2 & 0.6\n\\end{pmatrix}\\]Representamos continuación este sistema en forma de grafo en la Figura 2.6.\nFigura 2.6: Diagrama del sistema del Mercado de valores\n","code":"\n# Definimos estados\nestados <- c(\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\")\n# Matriz de transición \npmat <- matrix(data = c(0.6 , 0.2 , 0.2 , 0 , 0 , 0 , 0 , 0 , 0,\n                        0.4 , 0.2 , 0.2 , 0.2 , 0 , 0 , 0 , 0 , 0,\n                        0.2 , 0.2 , 0.2 , 0.2 , 0.2 , 0 , 0 , 0 , 0,\n                        0 , 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , 0 , 0 , 0,\n                        0 , 0 , 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , 0 , 0,\n                        0 , 0 , 0 , 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , 0,\n                        0 , 0 , 0 , 0 , 0.2 , 0.2 , 0.2 , 0.2 , 0.2,\n                        0 , 0 , 0 , 0 , 0 , 0.2 , 0.2 , 0.2 , 0.4,\n                        0 , 0 , 0 , 0 , 0 , 0 , 0.2 , 0.2 , 0.6), \n               byrow = TRUE, nrow = 9, \n               dimnames = list(estados, estados))\n# CMTD\nmercado.valores <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, \n                 name = \"Mercado de valores\")\n# Verificamos los datos introducidos\nmercado.valores## Mercado de valores \n##  A  9 - dimensional discrete Markov Chain defined by the following states: \n##  2, 3, 4, 5, 6, 7, 8, 9, 10 \n##  The transition matrix  (by rows)  is defined as follows: \n##      2   3   4   5   6   7   8   9  10\n## 2  0.6 0.2 0.2 0.0 0.0 0.0 0.0 0.0 0.0\n## 3  0.4 0.2 0.2 0.2 0.0 0.0 0.0 0.0 0.0\n## 4  0.2 0.2 0.2 0.2 0.2 0.0 0.0 0.0 0.0\n## 5  0.0 0.2 0.2 0.2 0.2 0.2 0.0 0.0 0.0\n## 6  0.0 0.0 0.2 0.2 0.2 0.2 0.2 0.0 0.0\n## 7  0.0 0.0 0.0 0.2 0.2 0.2 0.2 0.2 0.0\n## 8  0.0 0.0 0.0 0.0 0.2 0.2 0.2 0.2 0.2\n## 9  0.0 0.0 0.0 0.0 0.0 0.2 0.2 0.2 0.4\n## 10 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.2 0.6\n# Diagrama\nplot(mercado.valores, vertex.color=\"steelblue\", \n     vertex.label.font = 2, \n     vertex.label.color = \"white\",\n     edge.label.size = 0.2,\n     edge.arrow.size=0.5, \n     vertex.shape = \"rectangle\",\n     vertex.size = 20)"},{"path":"cmtd.html","id":"telecomunicaciones","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.7 Telecomunicaciones","text":"La empresa Tel-Switch Corporation fabrica equipos de conmutación para redes de comunicación. Las redes de comunicación mueven los datos de un conmutador otro la velocidad del rayo en forma de paquetes, es decir, mediante cadenas de ceros y unos (llamadas bits). Los conmutadores Tel-manejan paquetes de datos de longitud constante, es decir, el mismo número de bits en cada paquete. nivel conceptual podemos pensar en el conmutador como un dispositivo de almacenamiento donde los paquetes llegan desde la red de usuarios según un proceso aleatorio, se almacenan en un buffer con capacidad para almacenar \\(K\\) paquetes y se eliminan del buffer uno uno según un protocolo preestablecido. Uno de los protocolos utilizados considera el tiempo dividido en intervalos de duración fija llamados “ranuras” (por ejemplo, un microsegundo), y consiste en que: si hay algún paquete en el buffer al principio de un intervalo o ranura, se elimina uno instantáneamente; si hay ningún paquete al principio de un intervalo, se elimina ningún paquete durante el intervalo, aunque lleguen más paquetes durante el mismo; por último, si un paquete llega durante una ranura y hay espacio para él, se descarta. Este proceso se puede modelar como una \\(CMTD\\).Sean:\\(A_n\\) el número de paquetes que llegan al conmutador durante la enésima ranura (algunos pueden ser descartados)\\(X_n\\) el número de paquetes en el buffer al final de la enésima ranura.Ahora, si \\(X_n = 0\\), entonces hay paquetes disponibles para la transmisión al principio de la ranura \\(n+1\\). Por lo tanto, todos los paquetes que llegan durante esa ranura, es decir, \\(A_{n+1}\\), están en el buffer al final de esa ranura mientras tenga capacidad, esto es, \\(A_{n+1} \\leq K\\); si \\(A_{n+1}>K\\), entonces la memoria intermedia está llena al final de la ranura \\(n+1\\), \\(X_{n+1}=K\\). Por lo tanto, en general \\(X_{n+1} = min(A_{n+1}, K)\\), cuando \\(X_n=0\\).Por otro lado, si hay algún paquete al final del instante \\(n\\), \\(X_n > 0\\), pasan al conmutador en la siguiente ranura \\(n+1\\), se elimina un paquete al principio de la misma y se añaden los paquetes que lleguen durante esa ranura, \\(A_{n+1}\\), con sujeción las limitaciones de capacidad.Combinando estos casos, obtenemos:Asumimos que \\(\\{A_n, n \\geq 1\\}\\) es una secuencia de variables iid con función de masa de probabilidad dada por:\\[Pr(A_n = k) = a_k, \\quad k \\geq 0.\\]Bajo esta condición \\(\\{X_n, n \\\\mathbb{N}\\}\\) es una \\(CMTD\\) con espacio de estados \\(S = \\{0, 1, 2,..., K\\}\\), cuyas probabilidades de transición vienen dadas continuación para todos los estados \\(0 \\leq j \\leq K\\):Para \\(X_n=0 \\ (=0)\\):\\[\\begin{array}{ll}\nPr[X_{n+1} = j | X_n = 0] & = Pr[min(A_{n+1}, K) = j]\\\\\n& = \\begin{cases}\nPr[A_{n+1} \\geq K], \\quad \\text{ si } j=K\\\\\nPr[A_{n+1}=j], \\quad \\text{ si } j<K\n\\end{cases} \\\\\n&= \\begin{cases}\n\\sum_{r=K}^{\\infty} a_r \\quad \\text{ si } j=K\\\\\na_j, \\qquad \\quad \\text{ si } j<K\n\\end{cases}\n\\end{array}\\]Para \\(0< X_n=\\leq K\\):\\[\\begin{array}{ll}\nPr[X_{n+1} = j | X_n = ] & = Pr[min(A_{n+1}+X_n-1, K) = j]\\\\\n& = \\begin{cases}\nPr[A_{n+1} +-1 \\geq K], \\quad \\text{ si } j=K\\\\\nPr[A_{n+1}+-1=j], \\quad \\text{ si } j<K\n\\end{cases} \\\\\n& = \\begin{cases}\n\\sum_{K-+1}^{\\infty} a_r, \\qquad \\text{ si } j=K\\\\\na_{j-+1}, \\qquad \\qquad \\text{ si } -1 \\leq j<K\\\\\n0, \\qquad \\qquad \\qquad  \\text{ si } j<-1\n\\end{cases}\n\\end{array}\\]Si consideramos:\\[b_j = \\sum_{r=j}^{\\infty} a_r=1-\\sum_{r=0}^{j-1} a_r, \\quad j=1,2,...,K\\]la matriz de transiciones de un paso (de dimensión \\((K+1) \\times (K+1)\\) la podemos escribir como:\\[P = \n\\begin{pmatrix}\na_0 & a_1 & ... & a_{K-1} & b_K\\\\\na_0 & a_1 & ... & a_{K-1} & b_K\\\\\n0 & a_0 & ... & a_{K-2} & b_{K-1}\\\\\n...&...&...&...&...\\\\\n0 & 0 & ... & a_0 & b_1\n\\end{pmatrix}\\]","code":""},{"path":"cmtd.html","id":"inventario2","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.3.8 Inventario con desabastecimiento","text":"El gestor de un almacén desea analizar el comportamiento de uno de sus productos en función de la demanda del producto y de la capacidad del almacén.Consideramos como \\(Y_n\\) la variable aleatoria que describe la demanda del producto durante el n-ésimo periodo de tiempo, de forma que:\\[Pr[Y_n = k] = a_k, \\quad k=0, 1, 2,...  \\text{ con } \\sum_{k=0}^{\\infty} a_k =1\\]Denotamos por \\(X_n\\) la variable aleatoria que registra la cantidad de producto almacenado al finalizar el n-ésimo periodo de tiempo, \\(\\) el nivel mínimo de almacenaje del producto, y \\(B\\) el nivel máximo. La política de reposición es la siguiente:Si al finalizar un periodo el almacén tiene una cantidad de producto \\(X_n\\) menor o igual que \\(\\), entonces se reabastece hasta \\(B\\).Si al finalizar un periodo el almacén tiene una cantidad de producto mayor que \\(\\) y menor o igual \\(B\\), entonces se reabastece y espera hasta el instante de tiempo siguiente.En esta situación el proceso \\(\\{X_n, n \\\\mathbb{N}\\}\\) es un proceso estocástico de tiempo discreto\\[\\begin{array}{ll}\n\\text{ si } X_n \\leq & \\rightarrow X_{n+1} = B - Y_{n+1} \\\\\n\\text{ si } < X_n \\leq B & \\rightarrow X_{n+1} = X_n - Y_{n+1} \n\\end{array}\\]con espacio de estados \\(S = \\{B, B-1,..., 1, 0, -1, -2,...\\}\\), donde los valores negativos indican que la demanda supera la cantidad almacenada y será servida en instantes posteriores (demanda insatisfecha).Las probabilidades de transición vienen dadas por:si \\(\\leq \\)\\[\\begin{array}{ll}\nPr[X_{n+1} = j | X_{n} =]&= Pr[B - Y_{n+1} = j] \\\\\n&=Pr[Y_{n+1} = B-j]   \\\\\n& = \\begin{cases} \na_{B-j}, \\quad \\text{si } B \\geq j\\\\\n0,  \\qquad \\text{ si } B < j\n\\end{cases}\n\\end{array}\\]si \\(< \\leq B\\)\\[\\begin{array}{ll}\nPr[X_{n+1} = j | X_{n}=] & = Pr[- Y_{n+1} = j] \\\\\n&=Pr[Y_{n+1} = -j]   \\\\\n& =  \\begin{cases}\na_{-j}, \\quad \\text{ si } \\geq j\\\\\n 0, \\qquad \\text{ si } < j\n \\end{cases}\n\\end{array}\\]modo de ejemplo consideramos \\(= 0\\), \\(B = 2\\), con probabilidades para \\(Y_n\\) dadas por:\\[Pr[Y_n = 0] = 0.5; \\quad Pr[Y_n = 1] = 0.4; \\quad Pr[Y_n = 2] = 0.1,\\]entonces la matriz de transición, para el espacio de estados \\(S = \\{-1, 0, 1, 2\\}\\), viene dada por:\\[P = \n\\begin{pmatrix}\n0 & 0.1 & 0.4 & 0.5\\\\\n0 & 0.1 & 0.4 & 0.5\\\\\n0.1 & 0.4 & 0.5 & 0\\\\\n0 & 0.1 & 0.4 & 0.5\n\\end{pmatrix}\\]Representamos continuación este sistema en forma de grafo en la Figura 2.7.\nFigura 2.7: Diagrama del sistema del problema de inventario.\n","code":"\n# Definimos estados\nestados <- c(\"-1\", \"0\", \"1\", \"2\")\n# Matriz de transición \npmat <- matrix(data = c(0 , 0.1 , 0.4 , 0.5,\n                        0 , 0.1 , 0.4 , 0.5,\n                        0.1 , 0.4 , 0.5 , 0,\n                        0 , 0.1 , 0.4 , 0.5), \n               byrow = TRUE, nrow = 4, \n               dimnames = list(estados, estados))\n# CMTD\ninventario2 <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, \n                 name = \"Inventario 2\")\n# Verificamos los datos introducidos\ninventario2## Inventario 2 \n##  A  4 - dimensional discrete Markov Chain defined by the following states: \n##  -1, 0, 1, 2 \n##  The transition matrix  (by rows)  is defined as follows: \n##     -1   0   1   2\n## -1 0.0 0.1 0.4 0.5\n## 0  0.0 0.1 0.4 0.5\n## 1  0.1 0.4 0.5 0.0\n## 2  0.0 0.1 0.4 0.5\n# Diagrama\nplot(inventario2, vertex.color=\"steelblue\", \n     vertex.label.font = 2, \n     vertex.label.color = \"white\",\n     edge.label.size = 0.2,\n     edge.arrow.size=0.5, \n     vertex.shape = \"rectangle\",\n     vertex.size = 20)"},{"path":"cmtd.html","id":"CaracCMTD","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.4 Caracterización de una CMTD","text":"En esta sección estudiamos las principales características de una \\(CMTD\\) través de la comunicación entre los diferentes estados de proceso, el número de visitas y los tiempos de ocupación de cada estado, los tiempos la primera visita, partiendo de un estado, e introducimos la utilización de costes para la evaluación de los sistemas.En todas las definiciones que presentamos continuación asumimos que tenemos una \\(CMTD\\) \\(\\{X_n, n \\\\mathbb{N}\\}\\) con espacio de estados \\(S\\) y matriz de transición de un paso \\(P\\).","code":""},{"path":"cmtd.html","id":"comunicación-entre-estados","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.4.1 Comunicación entre estados","text":"Comenzamos caracterizando los estados de una cadena en función de sus probabilidades de transición.Definición 2.5  Dados dos estados \\(, j\\) de \\(S\\), se dice que el estado \\(j\\) es accesible desde el estado \\(\\) si existe una transición \\(n\\) tal que \\(p_{ij}(n) > 0\\).Que el estado \\(j\\) sea accesible desde \\(\\) se denota habitualmente como \\(\\rightarrow j\\).Definición 2.6  Dados dos estados \\(, j\\) de \\(S\\), se dice que son comunicantes si \\(\\) es accesible desde \\(j\\), y \\(j\\) es accesible desde \\(\\), es decir, existen \\(n_1\\) y \\(n_2\\) tal que \\(p_{ij}(n_1) > 0\\) y \\(p_{ji}(n_2) > 0.\\)Que los estados \\(, j\\) sean comunicantes se denota habitualmente como \\(\\leftrightarrow j\\).Definición 2.7  Un subconjunto de estados \\(S_j \\subset S\\) se denomina clase comunicante del estado \\(j\\) si todos los estados de ese subconjunto son comunicantes con \\(j\\).\\[S_j \\subset S \\text{ es clase comunicante de } j \\text{ si } \\quad \\leftrightarrow j, \\qquad \\forall \\S_j.\\]Definición 2.8  Un estado \\(\\S\\) se denomina estado sin retorno cuando es viable volver dicho estado tras partir de él, esto es, para \\(n \\geq 1\\), \\(p_{ii}(n) = 0.\\)Definición 2.9  Un conjunto de estados \\(C \\subset S\\) se denomina cerrado cuando es posible pasar de un estado de \\(C\\) otro que esté en \\(C\\), esto es,\\[\\forall \\C, \\quad \\forall j \\notin C \\quad \\Rightarrow \\quad p_{ij}(n) = 0, \\quad n\\geq 1\\]\no lo que es lo mismo,\\[ \\sum_{j \\C} p_{ij}=1, \\quad \\forall \\C.\\]Esto implica que cuando accedamos un conjunto cerrado, será imposible salir de él y sólo será factible moverse dentro de él.Si el conjunto cerrado está compuesto por un único estado \\(\\) diremos que ese estado \\(\\) es absorbente. Eso implica que si se llega dicho estado, el proceso se queda estancado en él y ya es posible moverse otro estado.Definición 2.10  Una \\(CMTD\\) es irreducible cuando todos sus estados están comunicados entre sí, esto es, para cualquier \\(,j \\S\\) existe algún instante de tiempo \\(n \\geq 0\\) tal que \\(Pr(X_n=j|X_0=)>0\\). Un conjunto de estados en S se dice irreducible cuando contiene ningún subconjunto cerrado. Si la \\(CMTD\\) es irreducible, se llama reducible.Todos los estados dentro de un conjunto irreducible son del mismo tipo.Para caracterizar una CMTD mediante la librería markovchain es útil usar la función summary(object) donde ‘object’ identifica el proceso estudiar.Ejemplo 2.2  Queremos caracterizar el proceso presentado en el Ejemplo 2.1. Cargamos los datos y ejecutamos la sintaxis continuación.la vista del resultado, concluimos que este proceso es cerrado (todo su espacio de estados es cerrado). Todos sus estados son recurrentes y tiene estados transitorios (estos conceptos los veremos más adelante). tiene estados absorbentes y la cadena de Markov es irreducible (todos sus estados están comunicados).PRACTICA Caracterizar los procesos: Fiabilidad de máquinas,Metereología, Problema de inventario, Planificación de mano de obra, Mercado de valores e Inventario con desabastecimiento.Ejemplo 2.3  Veamos ahora cómo utilizar la simulación para responder diferentes preguntas de interés. En concreto, para el ejemplo en la sección Inventario con desabastecimiento (recordemos que se trataba de un almacén que se reabastecía cuando el inventario quedaba por debajo o igual un nivel mínimo de almacenaje, \\(=0\\), y con una política de reabastecimiento que dependía del nivel de almacenaje máximo \\(B=2\\)), planteamos estas preguntas:Durante las próximas 20 semanas, ¿en cuántas de ellas será preciso reabastecerse?Durante las próximas 20 semanas, ¿en cuántas de ellas será preciso reabastecerse?Durante las próximas 20 semanas, ¿cuál es la proporción de semanas en que la demanda ha sido satisfecha (por rebasar el stock)?Durante las próximas 20 semanas, ¿cuál es la proporción de semanas en que la demanda ha sido satisfecha (por rebasar el stock)?Para responder estas preguntas hay que considerar el proceso \\(\\{X_n, n \\geq 0\\}\\) y la variable \\(Y_n\\) que identifica la demanda en la semana \\(n\\). Planteamos el siguiente algoritmo de simulación.Algoritmo para simulación de inventarioPaso 1. Fijar el número de transiciones del proceso, \\(n\\), e inicializar \\(X_0 = 2\\) (máximo almacenaje).Repetir pasos 2 y 3 hasta alcanzar el número de transiciones deseadas.Paso 2. Generar \\(Y_i\\) con el método de la transformada inversa.Paso 2. Generar \\(Y_i\\) con el método de la transformada inversa.Paso 3. Actualizar el valor \\(X_i\\) y reabastecer si fuera necesario.Paso 3. Actualizar el valor \\(X_i\\) y reabastecer si fuera necesario.Paso 4. Devolver la secuencia \\(\\{X_i, Y_i; =1,\\ldots,n\\}\\) para estudiar la evolución del sistema y la demanda.Paso 4. Devolver la secuencia \\(\\{X_i, Y_i; =1,\\ldots,n\\}\\) para estudiar la evolución del sistema y la demanda.Desarrollemos pues, el algoritmo.La estimación del número de semanas que hay que reabastecerse viene dada por el número de simulaciones en las que el nivel de inventario es menor o igual al nivel mínimo de almacenamiento, \\(invent=X\\leq 0\\), es decirLa proporción de semanas en que la demanda ha sido satisfecha (por rebasar el stock) corresponde aquellas en las que la demanda ha superado al inventario,","code":"\n# Caracterización\nsummary(proceso)## Unnamed Markov chain  Markov chain that is composed by: \n## Closed classes: \n## a b c \n## Recurrent classes: \n## {a,b,c}\n## Transient classes: \n## NONE \n## The Markov chain is irreducible \n## The absorbing states are: NONE\n# Inicialización\nset.seed(12)\ntiempo <- 21 # valor inicial y 20 transiciones\ninvent <- c()  # vector con los valores de inventario\ndemanda <- c() # vector con los valores de demanda\nA <- 0\nB <- 2\n##### Configuración metodo transformada inversa ######\n# datos uniformes\nunif <- runif(tiempo-1)\n# Valores posibles para la demanda\nvalores <- c(0, 1, 2)\n# Probabilidades para la demanda\nprob <- c(0.5, 0.4, 0.1)\nprobacum <- cumsum(prob)  # probabilidades acumuladas\n# valor inicial del proceso\ninvent[1] <- 2\ndemanda[1] <- 0\ni<-2\nwhile (i <= tiempo)\n{\n  # simulamos demanda\n  demanda[i] <- valores[min(which(unif[i-1] <= probacum))] \n  # Actualizamos inventario\n  ifelse(invent[i-1] <= A, \n         invent[i] <- B - demanda[i], \n         invent[i] <- invent[i-1]-demanda[i])\n  # iteración siguiente\n  i<-i+1\n}\n# Devolvemos la secuencia de estados \ninventario2.sim=data.frame(invent,demanda)\nhead(inventario2.sim)##   invent demanda\n## 1      2       0\n## 2      2       0\n## 3      1       1\n## 4     -1       2\n## 5      2       0\n## 6      2       0\nsum(inventario2.sim$invent <= A)## [1] 3\nmean(inventario2.sim$invent <inventario2.sim$demanda)## [1] 0.1428571"},{"path":"cmtd.html","id":"tiemposocupa-sec","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.4.2 Tiempos de ocupación","text":"Definición 2.11  Sea \\(\\{X_n, n \\geq 0\\}\\) una \\(CMTD\\) homogénea con espacio de estados \\(S = \\{1, 2,...,N\\}\\), matriz de probabilidades de transición de una paso \\(P\\), y distribución inicial \\(p(0)\\). Consideramos la variable aleatoria \\(N_j(n)\\) como el número de visitas al estado \\(j\\) en \\(n\\) transiciones y definimos\\[m_{ij}(n) = E[N_j(n)|X_0 = ]\\]\ncomo el número esperado de visitas o tiempo de ocupación del estado \\(j\\) hasta el instante \\(n\\), partiendo del estado \\(\\).partir de las cantidades \\(m_{ij}(n)\\) se puede definir la matriz de tiempos de ocupación hasta un instante \\(n\\), \\(M(n)=(m_{ij}(n))_{ij}\\), que se puede calcular partir de la matriz de transición \\(P\\) como:Definición 2.12  Un estado \\(\\) se dice que es recurrente si es continuamente revisitado lo largo de la vida de la cadena, esto es, el número esperado de visitas al estado \\(\\) lo largo de la vida del proceso es infinito, \\(m_{ii}=E(N_i|X_0=)=\\infty\\). En otro caso, cuando sólo se accede un número finito de veces, se dice que es transitorio. Un estado transitorio sólo será accesible durante un cierto periodo de tiempo, tras el cual dicho estado ya será revisitado nunca más.Ejemplo 2.4  Volvemos sobre el Ejemplo 2.1 para calcular los tiempos de ocupación durante un periodo continuado de 10 transiciones. Para ello utilizamos la Ecuación (2.7) con \\(n=10\\).Podemos ver cómo el número esperado de visitas al estado \\(c\\) partiendo del estado \\(b\\) en las próximas 10 transiciones es casi de 7 (6.86). Sin embargo, si partimos del estado \\(b\\), en 10 transiciones sólo esperamos volver dicho estado 1 vez.Definamos una función para obtener la matriz de tiempos de ocupación (o número esperado de visitas) durante un periodo de duración de \\(n\\) unidades de tiempo.PRACTICA Obtener y caracterizar la matriz del número esperado de visitas en 20 transiciones para los procesos: Fiabilidad de máquinas,Metereología, Problema de inventario, Planificación de mano de obra y Mercado de valores.","code":"\n## Simulación de los tiempos de ocupación (número de visitas a un estado)\n# Número de estados del proceso\nnestat <- dim(proceso)\n# Estados\nnombres<- names(proceso)\n# Generamos la matriz de ocupaciones\n# el primer elemento es la matriz identidad: p^0\nmocupa <- diag(nestat)\n  dimnames(mocupa) <- list(nombres, nombres)\n# Bucle de cálculo de los tiempos de ocupación\nP=proceso[1:nestat,1:nestat] # matriz de transición\nfor (i in 1:10)\n{\n   mocupa <- mocupa + ptran.n(P,i)\n}\nmocupa##          a        b        c\n## a 4.531739 1.248415 5.219845\n## b 3.555292 1.955489 5.489220\n## c 3.858338 1.046384 6.095278\n# Función para calcular los tiempos de ocupación en un periodo [0,n]\nmocupa.proceso <- function(proceso, n)\n{\n  # Número de estados del proceso\n  nestat <- dim(proceso)\n  # Estados\n  nombres<- names(proceso)\n  # Generamos la matriz de ocupaciones\n  mocupa <- diag(nestat)\n  dimnames(mocupa) <- list(nombres, nombres)\n#  mocupa <- matrix(rep(0, nestat*nestat),\n#                 nrow = nestat, dimnames = list(nombres, nombres))\n  # Bucle de cálculo de los tiempos de ocupación\n  P=proceso[1:nestat,1:nestat]\n  for (i in 1:n)\n   mocupa <- mocupa + ptran.n(P,i)\n  \n  return(mocupa)\n}"},{"path":"cmtd.html","id":"análisis-de-costes","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.4.3 Análisis de costes","text":"Una aplicación muy habitual de los tiempos de ocupación es directa en los denominados modelos de costes, que describimos brevemente, y que pueden estar vinculados en situaciones específicas costes, pero también beneficios, pérdidas, etc..Sea \\(X_n\\) el estado del sistema en el tiempo \\(n\\). Asumimos que \\(\\{X_n, n \\geq 0 \\}\\) es una \\(CMTD\\) con espacio de estados \\(S =\\{1, 2,...,N\\}\\), matriz de transición \\(P\\), y matriz de tiempos de ocupación \\(M(n)\\).En esta situación, hablamos de que cada visita cierto estado \\(\\) tiene un coste aleatorio asociado \\(C()\\), y el coste esperado por cada visita al estado \\(\\) viene dado por \\(c() = E[C()]\\). Definimos la matriz de costes esperados asociados los estados, como \\(\\mathbf{c}\\), de dimensión \\(N\\times 1\\), como:\\[\\mathbf{c}' = (c(1),c(2),\\ldots,c(N))\\]Así mismo, hablamos del coste \\(C(X_r)\\) en el que incurre el sistema en un instante concreto \\(r\\), y \\(\\sum_{r=0}^n C(X_r)\\) el coste acumulado desde el inicio del proceso hasta llegar al instante \\(n\\). Entonces el coste esperado total (CET) asociado al funcionamiento del sistema hasta llegar al instante \\(n\\) se calculará como\\[CET=E\\left[\\sum_{r=0}^n C(X_r)\\right]\\]Definimos el coste esperado total hasta el instante \\(n\\) partiendo del estado \\(\\), \\(g(,n)\\), como:\\[g(,n) = E\\left[\\sum_{r=0}^n C(X_r)| X_0 = \\right]\\]y construimos la matriz de costes totales sobre un horizonte finito (CTHF) hasta el instante \\(n\\), \\(\\mathbf{g}(n)\\), de dimensión \\(N \\times 1\\), través de estos costes esperados partiendo de cualesquier estado \\(\\S\\), como\\[\\mathbf{g}(n)' = (g(1,n),g(2,n),\\ldots,g(N,n))\\]Definición 2.13  Si vinculado al funcionamiento de un sistema CMTD queremos calcular el coste esperado total sobre un horizonte finito hasta un instante \\(n\\), (CTHF), basta multiplicar la matriz de tiempos de ocupación hasta el instante \\(n\\), \\(M(n)\\), por la matriz de costes esperados asociados los estados del sistema, \\(\\mathbf{c}\\), esto es, resolver la Ecuación (2.8).Ejemplo 2.5  Volvamos al proceso de inventario presentado en el Problema de inventario con espacio de estados \\(\\{2,3,4,5\\}\\). Supongamos que la empresa compra PCs por 1500 euros y los vende por 1750 euros. Además el coste de almacenamiento semanal es de 50 euros por cada unidad que está en la tienda al inicio de una semana. Queremos calcular los ingresos netos que la tienda espera obtener durante las próximas 10 semanas, suponiendo que comienza con cinco PCs en stock al inicio del periodo.En esta situación, estamos interesados en los ingresos, por lo que definimos \\(c()\\) como los ingresos netos que se obtienen en una semana cualquiera en la que hay \\(\\) PCs al principio de la semana. Sabemos que los costes de almacenamiento de \\(\\) PCs es \\(50i\\). Las ganancias provendrán de los PCs que se hayan vendido. Si \\(D_n\\) es la demanda durante una semana cualquiera \\(n\\), el número esperado de PCs vendidos durante esa semana será \\(E[min(, D_n)]\\). Así, los ingresos netos previstos para una semana cualquiera \\(n\\) en la que se tienen \\(\\) PCs almacenados al inicio, \\(c()\\), provendrán de los ingresos por ventas menos los gastos de almacenaje, esto es,\\[c() = (1750-1500)E[min(, D_n)] -50i, \\quad 2 \\leq \\leq 5\\]Necesitamos pues, obtener el valor de \\(E[min(, D_n)]\\), para cada valor de \\(\\). Veamos cómo hacerlo, tanto de forma teórica como mediante simulación. Denotemos por \\(Z_{,n} = min(, D_n),\\) para \\(=2, 3, 4, 5\\) de forma que:de esta forma tenemos que su valor esperado vendrá dado por:\\[E[Z_{,n}] = \\cdot Pr[< D_n] + \\sum_{d=0}^{} d \\cdot Pr(D_n=d).\\]Recordando que \\(D_n\\sim Pois(3)\\) en el ejemplo original, para \\(=2\\) la expresión anterior da lugar :\\[\\begin{eqnarray*}\nE[Z_{2,n}] &= 2 \\cdot Pr[D_n > 2] + 0 \\cdot Pr[D_n = 0] + 1 \\cdot Pr[D_n =1] +2 \\cdot Pr(D_n=2) \\\\\n&= 2 \\cdot (1-Pr(D_n \\leq 2)) + 1 \\cdot Pr[D_n =1] + 2 \\cdot Pr(D_n=2) \\\\\n&= 2 \\cdot 0.5768 +0.1494 +2 \\cdot 0.2240 = 1.751\n\\end{eqnarray*}\\]de donde calculamos los ingresos \\(c(2)\\) con la ecuación anterior.\n\\[c(2) =  250 \\cdot 1.751 -50 \\cdot 2 = 337.75\\]\nHacemos fácilmente los cálculos para todos los estados:Y obtenemos\\[\\mathbf{c} = \n\\begin{pmatrix}\n337.75 \\\\\n431.95 \\\\\n470.15 \\\\\n466.23 \n\\end{pmatrix}\\]Con esta matriz y la matriz de ocupación hasta el instante \\(n=10\\) podemos calcular los ingresos netos totales esperados durante las próximas \\(n=10\\) semanas, sea cual sea el estado inicial del sistema:\\[g(10)=M(10) \\cdot c\\]\nque calculamos continuación:y que nos permite extraer los ingresos netos totales esperados asumiendo que el periodo inicia con \\(=5\\) PCs en tienda, esto es, como $g(5,10)=$4842.59 euros.Los valores de \\(c\\) se pueden aproximar mediante simulación sin necesidad de calcularlos de forma teórica. continuación se presenta el código necesario para realizar la simulación. Concretamente definimos una función que depende del valor del estado inicial \\(\\).Aproximamos pues por simulación, los valores de la matriz \\(c\\) con \\(nsim=1.000.000\\) simulacionesComo se puede ver, la simulación funciona bastante bien para aproximar el vector \\(c\\); resolvamos pues los cálculos de \\(g(5,10)\\) con estos valores, que de nuevo aproximarán las cantidades que buscamos.Mientras que teóricamente obteníamos unos ingresos esperados de 4842.59€, con la simulación obtenemos una aproximación de 4844.27€.","code":"\nestados=2:5\nlambda=3   # Poisson para la demanda\n# número esperado de ventas\nez=c()\nfor(i in estados){\nez[i-1]=i*(1-ppois(i,lambda))+sum((0:i)*dpois(0:i,lambda))\n}\ningresos=250*ez-50*estados;ingresos## [1] 337.7662 431.9686 470.1607 466.3449\nc=matrix(round(ingresos,2), ncol=1)\nM10=mocupa.proceso(inventario,10)\ng=M10 %*% c\ng##           [,1]\n## 2 PCs 4736.876\n## 3 PCs 4819.392\n## 4 PCs 4847.637\n## 5 PCs 4842.589\n# simulador del valor esperado del número esperado de ventas\nc.sim <- function(estado, nsim)\n{\n  # estado: estado inicial del sistema\n  # nsim: nº simulaciones para la aproximación\n  \n  # Simulamos valores del mínimo entre i y D_n\n  datos <- data.frame(rsim = rpois(nsim, 3), rdos <- rep(estado, nsim))\n  minimo <-apply(datos, 1 ,min) # Mínimo por filas\n  # Valor esperado min(i,D_n)\n  esperanza <- mean(minimo)\n  # coste\n  coste <- round(-50*estado+250*esperanza, 2)\n  return(coste)\n}\nnsim <- 1000000\nset.seed(12)\nc.s=matrix(c(c.sim(2, nsim),c.sim(3, nsim),\n      c.sim(4, nsim),c.sim(5, nsim)),ncol=1)\nc.s##        [,1]\n## [1,] 337.66\n## [2,] 431.61\n## [3,] 470.28\n## [4,] 466.69\n# matriz M\nMmat <- mocupa.proceso(inventario, 10)\n# vector g\nbeneficio <- Mmat%*%c.s\nbeneficio##           [,1]\n## 2 PCs 4738.291\n## 3 PCs 4820.502\n## 4 PCs 4849.143\n## 5 PCs 4844.266"},{"path":"cmtd.html","id":"tiempos-de-primer-paso","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.4.4 Tiempos de primer paso","text":"Definición 2.14  Sea \\(\\{X_n, n \\geq 0\\}\\) una \\(CMTD\\) homogénea con espacio de estados \\(S = \\{1, 2,...,N\\}\\). Se define el tiempo de primer paso o tiempo de primera visita al estado \\(j\\) partiendo del estado \\(\\), \\(T_{ij}\\), como el mínimo número de transiciones necesarias para alcanzar el estado \\(j\\) partiendo del estado inicial \\(\\), es decir:\\[T_{ij} = \\underset{n}{min}\\{n > 0, X_n = j | X_0 = \\}\\]En ocasiones interesará sin embargo el tiempo de primer paso de un estado un conjunto de estados \\(\\):\\[T_{iA} = \\underset{n}{min}\\{n > 0, X_n \\| X_0 = \\}.\\]Para obtener los tiempos esperados de recurrencia \\(f=(f_{11},...,f_{NN})\\) para el espacio de estados \\(S=\\{1,...,N\\}\\), utilizamos la función meanRecurrenceTime(proceso) de la librería markovchain.Para obtener los tiempos esperados de primer paso por un estado \\(j\\) desde cualquier estado de \\(S\\), podemos utilizar la función meanFirstPassageTime(proceso,destination=j) de la librería markovchain.\nSi queremos calcular la matriz de tiempos esperados para llegar cualquier estado desde cualquier estado, basta utilizar meanFirstPassageTime(proceso).En caso de que podamos utilizar la función meanFirstPassageTime para el cálculo del tiempo esperado de primer paso, podemos utilizar la propiedad que pasamos describir.Definición 2.15  Sea \\(\\{X_n, n \\geq 0\\}\\) una \\(CMTD\\) con espacio de estados \\(S = \\{1, 2,...,N\\}\\). Si estamos interesados en obtener el tiempo esperado de primer paso para el estado \\(j\\) desde cualquier estado \\(\\), dado por:\\[v_{ij} = E(T_{ij}), \\quad \\text{ con } T_{ij} = \\underset{n}{min}\\{n > 0, X_n = j | X_0 = \\}\\]y construimos la matriz de dimensión \\((N-1) \\times 1\\) \\(\\mathbf{v_j'}=(v_{1j},...,v_{j-1,j},v_{j+1,j},...,v_{Nj})\\)\nbasta con resolver el sistema:donde\\(P_{-j}\\) es la matriz de transición eliminando la fila y columna del estado \\(j\\),\\(\\mathbf{1}\\) es un vector de unos, de dimensión \\(N-1\\),\\(\\mathbf{}\\) es una matriz diagonal de las mismas dimensiones que \\(P_{-N}\\).Esta ecuación se puede generalizar para obtener los tiempos esperados de primer paso desde un estado \\(\\) hasta cualquier subconjunto de estados \\(S_c \\subset S\\).Función para obtener los tiempos esperados de primer pasoComo alternativa la función definida en markovchain, programamos continuación una función genérica para poder obtener los tiempos esperados de primer paso, dependiente de dos parámetros:proceso: \\(CMTD\\) que describe el sistema estudioestado: estado o conjunto de estados que se desean alcanzar, partiendo desde cualquier estado inicial que está en este conjunto.Definición 2.16  Sea \\(\\{X_n, n \\geq 0\\}\\) una \\(CMTD\\) homogénea con espacio de estados \\(S = \\{1, 2,...,N\\}\\). Se definen las probabilidades de primera visita o primer paso del estado \\(\\) al \\(j\\) en \\(n\\) transiciones, con \\(f_{ij}(n)\\),\\[\\begin{eqnarray*}\nf_{ij}(n) &=& Pr[X_n = j, X_{n-1} \\neq j,\\ldots, X_1 \\neq j | \\quad X_0 = ] \\\\ \n&=& Pr(T_{ij}=n), \\quad n \\geq 0\n\\end{eqnarray*}\\]donde por convenio \\(f_{ij}(0) = 0.\\)Podemos obtener la distribución de probabilidad asociada al tiempo de primer paso del estado \\(j\\) desde el estado \\(\\) en \\(n\\) transiciones, \\(f_{ij}(n)\\), con la función firstPassageMultiple(proceso,state=,set=j,n=n).Definición 2.17  Si \\(T_{ii}\\) denota el tiempo del primer retorno, o tiempo de recurrencia al estado \\(\\), entonces se dice que el estado \\(\\) es recurrente si \\(f_{ii}=Pr(T_{ii}<\\infty)=1\\), es decir, si el sistema se inicia en él, pueda volver él. Es transitorio si \\(f_{ii}<1\\).Ejemplo 2.6  Analizamos los tiempos de primer paso, tiempos de recurrencia y probabilidades de primer paso sobre el proceso presentado en el Ejemplo 2.1. Estamos interesados en saber cuándo alcanzaremos el estado “b” partiendo desde cualquier estado en el momento inicial.Comenzamos calculando los tiempos de primer paso utilizando las dos funciones consideradas, la propia y la de markovchain.Podemos ver que ambas funciones proporcionan el mismo resultado. Si comenzamos en el estado “” tardaremos en promedio seis transiciones para alcanzar por primera vez el estado “b,” mientras que si empezamos en el estado “c” tardaremos 8 transiciones en alcanzar el estado “b.”Si deseamos la matriz del valor esperado del primer paso en cualquier estado basta con ejecutarObtenemos ahora el tiempo de primer paso (utilizando la función programada) y la probabilidad de primer paso de pasar del estado \\(b\\) cualquiera de los estados \\(\\) o \\(c\\) en 10 transiciones (\\(= \\{, c\\}\\))Se espera poder pasar de \\(b\\) \\(\\) en una transición (lógico puesto que es el conjunto complementario \\(b\\) en el conjunto de estados), mientras que la probabilidad de pasar del estado \\(b\\) al conjunto \\(\\) en dos transiciones es de \\(0.55\\) y tan solo de \\(0.0008\\) en 10 transiciones.En cuanto los tiempos de recurrencia, tenemos:Podemos ver que una vez hemos pasado por el estado “b” tardamos 9 transiciones en volver él. Calculamos ahora la probabilidad de recurrencia en 10 transiciones.Si iniciamos el proceso en el estado “b” la probabilidad de volver dicho estado es muy baja en cualquiera de las 10 primeras transiciones. La probabilidad de volver en 3 transiciones es de 0.15, pero de volver en 10 transiciones es de 0.046.¿Qué implicaciones prácticas tienen los análisis realizados en el proceso estudiado?Ejemplo 2.7  Consideramos el proceso que ya vimos sobre Fiabilidad de máquinas. Supongamos que en el instante inicial (dia 0) las dos máquinas están “,” y que deseamos calcular el tiempo esperado hasta que las dos máquinas estén “” por primera vez.Si \\(Y_n\\) es el proceso que representa el número de máquinas que están “,” con espacio de estados \\(S = \\{0, 1, 2\\}\\), estamos interesados en calcular el tiempo esperado para llegar \\(Y_n = 0\\) (dos máquinas “”) partiendo de \\(Y_0 = 2\\) (dos máquinas “”). Utilizamos la función propia estableciendo el estado objetivo.El tiempo esperado para que las dos máquinas estén en estado “” comenzando con ambas en el estado “” es 2451.5, que expresado en años será \\(2451.5/365 = 6.71\\) años.Ejemplo 2.8  Consideramos el proceso ya presentado sobre Planificación de mano de obra. Deseamos el tiempo medio de permanencia en la empresa para un empleado recién reclutado. Recordemos que un nuevo empleado siempre empieza en el nivel “1.” Definamos un proceso \\(Y_n\\) que representa el nivel de un empleado novel en la semana n-ésima, proceso que puede tomar los valores \\(S = \\{0, 1, 2, 3, 4\\}\\), donde \\(Y_n=0\\) significa que deja la empresa en n semanas después de empezar. En esta situación el proceso \\(\\{Y_n, n \\geq 0\\}\\) es una \\(CMTD\\) con espacio de estados \\(S = \\{0, 1, 2, 3, 4\\}\\) y matriz de probabilidades de transición calculadas partir de las probabilidades que se daban en el desarrollo de Planificación de mano de obra y teniendo en cuenta que si está fuera de la empresa, la semana siguiente también lo estará:\\[P = \n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n0.02 & 0.98 & 0.03 & 0 & 0\\\\\n0.008 & 0 & 0.982 & 0.01 & 0\\\\\n0.02 & 0 & 0 & 0.975 & 0.005\\\\\n0.01 & 0 & 0 & 0 & 0.99\n\\end{pmatrix}\\]Creamos la estructura del sistema:En este caso el estado “0” es absorbente (cuando es despedido, ya vuelve), y el resto de estados son transitorios. Al tener un estado absorbente, es irreducible y se puede aplicar la función meanFirstPassageTime() para calcular los tiempos de primer paso esperados. Usamos pues, la función que hemos programado:Puesto que el nuevo empleado comienza siempre en el nivel “1,” el tiempo esperado para que abandone la empresa es de 73.33 semanas (el proceso se mide en semanas), lo que equivale 1.4 años (\\(73.33/52\\)).","code":"\n# Función para obtener el tiempo esperado de primer paso por \"estado\"\n# (equivalente a meanFirstPassageTime de markovchain)\ntiempo.pp <- function(proceso, estado)\n{\n  # estados del proceso\n  estados <- states(proceso)\n  numestados <- length(estados)\n  # posición de los estados deseados\n  lestat <- length(estado)\n  pos <- which(estados %in% estado)\n  # matriz P_N\n  P_N <- proceso[-pos,-pos]\n  # vector de unos\n  vector.1 <- matrix(rep(1, numestados-lestat), ncol=1)\n  # sistema de ecuaciones\n  sistema <- diag(numestados-lestat) - P_N\n  # solución del sistema\n  solucion <- solve(sistema, vector.1)\n  return(solucion)\n}\n# Tiempo de primer paso partiendo del estado \"b\"\n# libreria\nmeanFirstPassageTime(proceso, \"b\")##        a        c \n## 6.363636 8.181818\n# definida por nosotros\ntiempo.pp(proceso, \"b\")##       [,1]\n## a 6.363636\n## c 8.181818\nmeanFirstPassageTime(proceso)##          a        b        c\n## a 0.000000 6.363636 1.688312\n## b 2.636364 0.000000 1.168831\n## c 1.818182 8.181818 0.000000\n# Tiempo esperado e primer paso de \"b\" a \"A\"\ntiempo.pp(proceso,c(\"a\",\"c\"))##      [,1]\n## [1,]    1\n# Probabilidad de primer paso de \"b\" a \"A\"\nfirstPassageMultiple(proceso, \"b\", c(\"a\",\"c\"), 10)##             set\n## 1  1.0000000000\n## 2  0.5450000000\n## 3  0.2597500000\n## 4  0.1091375000\n## 5  0.0479968750\n## 6  0.0211430938\n## 7  0.0093898422\n## 8  0.0041868540\n## 9  0.0018726328\n## 10 0.0008392372\n# Tiempo de recurrencia\nmeanRecurrenceTime(proceso)##        a        b        c \n## 2.700000 9.000000 1.928571\n# Probabilidad de recurrencia en 10 pasos\nfirstPassageMultiple(proceso, \"b\", \"b\", 10)##           set\n## 1  0.00000000\n## 2  0.03000000\n## 3  0.15450000\n## 4  0.10597500\n## 5  0.09746625\n## 6  0.08295844\n## 7  0.07195424\n## 8  0.06211757\n## 9  0.05368795\n## 10 0.04638892\n# Tiempo de primer paso para acabar en el estado \"0\"\ntiempo.pp(fiabilidad, \"0\")##       [,1]\n## 1 2450.990\n## 2 2451.485\n# Definimos estados\nestados <- c(\"0\", \"1\", \"2\", \"3\", \"4\")\n# Matriz de transición \npmat <- matrix(data = c(1, 0, 0, 0, 0,  \n                        0.02, 0.95, 0.03, 0, 0, \n                        0.008, 0, 0.982, 0.01, 0,   \n                        0.02, 0, 0, 0.975, 0.005,\n                        0.01, 0, 0, 0, 0.99), \n               byrow = TRUE, nrow = 5, \n               dimnames = list(estados, estados))\n# CMTD\nplanificacion2 <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, name = \"planificacion\")\n# Verificamos los datos introducidos\nplanificacion2## planificacion \n##  A  5 - dimensional discrete Markov Chain defined by the following states: \n##  0, 1, 2, 3, 4 \n##  The transition matrix  (by rows)  is defined as follows: \n##       0    1     2     3     4\n## 0 1.000 0.00 0.000 0.000 0.000\n## 1 0.020 0.95 0.030 0.000 0.000\n## 2 0.008 0.00 0.982 0.010 0.000\n## 3 0.020 0.00 0.000 0.975 0.005\n## 4 0.010 0.00 0.000 0.000 0.990\n# y describimos el sistema\nsummary(planificacion2)## planificacion  Markov chain that is composed by: \n## Closed classes: \n## 0 \n## Recurrent classes: \n## {0}\n## Transient classes: \n## {1},{2},{3},{4}\n## The Markov chain is not irreducible \n## The absorbing states are: 0\n# Tiempo esperado para llegar a estado 0\ntiempo.pp(planificacion2, \"0\")##        [,1]\n## 1  73.33333\n## 2  88.88889\n## 3  60.00000\n## 4 100.00000"},{"path":"cmtd.html","id":"AsinCMTD","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.5 Comportamiento a largo plazo","text":"En está sección estamos interesados en estudiar el comportamiento largo plazo o asintótico de una \\(CMTD\\), es decir, el comportamiento cuando \\(n \\rightarrow \\infty\\).La distribución estacionaria \\(\\{\\pi_1,..., \\pi_N\\}\\) de una CMTD \\(\\{X_n, n \\geq 0\\}\\), con espacio de estados \\(S =\\{1, 2,..., N\\}\\) verifica que:\\[Pr(X_n=)=\\pi_i, \\forall \\S, \\ n \\geq 0.\\]Si existe la distribución largo plazo de un proceso CMTD \\(\\{X_n, n \\geq 0\\}\\), con espacio de estados \\(S =\\{1, 2,..., N\\}\\) y matriz de probabilidades de transición \\(P\\), la denominamos distribución límite o distribución en estado estacionario, y la denotamos por:\\[\\pi = [\\pi_1, \\pi_2,...,\\pi_N]\\]donde\\[\\pi_j = \\underset{n \\rightarrow \\infty}{lim} Pr[X_n = j], \\quad j \\S\\]\nSi existe la distribución límite o en estado estacionario, dicha distribución es la distribución estacionaria.Si existe la distribución límite de un proceso CMTD \\(\\{X_n, n \\geq 0\\}\\), con espacio de estados \\(S =\\{1, 2,..., N\\}\\) y matriz de probabilidades de transición \\(P\\), entonces las probabilidades \\(\\pi_j\\) satisfacen la siguiente ecuación:\\[\\pi_j = \\sum_{=1}^N \\pi_i p_{ij}, \\quad \\forall j \\S,\\]\ndonde \\(p_{ij}\\) son las probabilidades de transición (en la matriz \\(P\\)). Esta propiedad en formato matricial da lugar la ecuación de balance o del estado estacionario, que viene dada por:junto con la restricción de normalización\\[\\sum_{j=1}^N \\pi_j = 1.\\]Definición 2.18  Sea \\(\\{X_n, n \\geq 0\\}\\) una \\(CMTD\\), con \\(N_j(n)\\) el número de visitas o tiempo de ocupación del estado \\(j\\). La ocupación del estado \\(j\\) se define como la proporción de visitas al estado \\(j\\) (o proporción del tiempo de ocupación que el sistema está en \\(j\\)) en el largo plazo (\\(n \\rightarrow \\infty\\)):\\[\\begin{equation}\n\\pi_j=lim_{n \\rightarrow \\infty} \\frac{E[N_j(n)|X_0=]}{n+1}\n\\tag{2.11}\n\\end{equation}\\]Si existe esta distribución de ocupación, entonces satisface las ecuaciones de balance y de normalización en (2.10).Teorema 2.1  Una CMTD con espacio de estados finitos y que es irreducible tiene una única distribución estacionaria, es decir, sólo hay una solución normalizada de la ecuación de balance.Una CMTD con espacio de estados finitos y que es irreducible tiene una única distribución de ocupación y es igual la distribución estacionaria.Introducimos ahora el concepto de periodicidad, que nos ayudará decidir cuándo existe la distribución estacionaria.Definición 2.19  Sea la \\(CMTD\\) \\(\\{X_n, n \\geq 0\\}\\) con espacio de estados \\(S =\\{1, 2,..., N\\}\\) y \\(d\\) el entero más grande tal que para cualquier estado \\(\\S\\)\\[\\text{si } Pr[X_n = | X_0 = ] >0 \\Rightarrow n \\text{ es  múltiplo de } d,\\]Se dice entonces que dicha \\(CMTD\\) es periódica con periodo \\(d\\) si \\(d>1\\), y aperiódica si \\(d = 1\\).Así, una CMTD con periodo \\(d\\) puede volver su estado inicial sólo en los instantes \\(d, 2d, 3d, ...\\). En consecuencia, en las CMTD irreducibles es suficiente encontrar el periodo \\(d\\) para cualquier estado \\(\\S\\), puesto que será el mismo para todos los estados, con lo que encontrar el periodo en CMTD irreducibles será sencillo.En particular, si \\(p_{ii}>0\\) para cualquier \\(\\S\\) (todos los estados son recurrentes) de una CMTD irreducible, entonces \\(d=1\\) y la CMTD será aperiódica.Teorema 2.2  Una CMTD con espacio de estados finitos, irreducible y aperiódica tiene una única distribución límite o en el estado estacionario, que coincide pues con la distribución estacionaria y también con la de los tiempos de ocupación.La distribución límite o en estado estacionario de una CMTD reducible es única y depende del estado inicial de la cadena.Podemos estudiar la periocidad de un sistema mediante la función period() de la librería markovchain.La función steadyStates() de la librería markovchain nos devuelve la distribución estacionaria de una \\(CMTD\\).Ejemplo 2.9  Analizamos el sistema presentado en el Ejemplo 2.1 para obtener la distribución estacionaria:Obtenemos de esta forma las probabilidades asintóticas de estar en cada uno de los estados. Vemos pues, que la larga lo más probable es que nos encontremos en el estado ‘c,’ y lo menos probable es estar en el estado ‘b.’Definición 2.20  Si \\(\\) es un estado recurrente y existe la distribución estacionaria, entonces el valor esperado del tiempo de recurrencia es el inverso de la probabilidad de \\(\\) según la distribución estacionaria, es decir,Tenemos un resultado adicional sobre el comportamiento de los costes en el estado estacionario.Definición 2.21  Si \\(c()\\) es el coste esperado en el que incurrimos cuando visitamos el estado \\(\\S\\), de una CMTD irreducible con distribución de ocupación \\(\\pi\\), entonces el coste esperado por unidad largo plazo (en el estado estacionario) viene dado por:\\[g= \\sum_{j\\S} \\pi_j \\ c(j).\\]Ejemplo 2.10  Para el proceso descrito en la sección Telecomunicaciones, en el que los paquetes de datos que se generan en el instante (ranura) \\(n\\), \\(A_n \\sim Po(1)\\), se almacenaban en un buffer de capacidad \\(K=7\\), que se van eliminando conforme cierta estrategia. Interesados en el proceso \\(\\{X_n, n\\geq 0\\}\\) que describe el número de paquetes en el buffer al final de la n-ésima ranura, con espacio de estados \\(S=\\{0, 1,..., 7\\}\\) y matriz de probabilidades de transición:\\[P = \n\\begin{pmatrix}\n0.3679 & 0.3679 & 0.1839 & 0.0613 & 0.0153 & 0.0031 & 0.0005 & 0.0001\\\\\n0.3679 & 0.3679 & 0.1839 & 0.0613 & 0.0153 & 0.0031 & 0.0005 & 0.0001\\\\\n0.0 & 0.3679 & 0.3679 & 0.1839 & 0.0613 & 0.0153 & 0.0031 & 0.0006\\\\\n0.0 & 0.0 & 0.3679 & 0.3679 & 0.1839 & 0.0613 & 0.0153 & 0.0037\\\\\n0.0 & 0.0 & 0.0& 0.3679 & 0.3679 & 0.1839 & 0.0613 & 0.0190\\\\\n0.0 & 0.0 & 0.0& 0.0& 0.3679 & 0.3679 & 0.1839 & 0.0803\\\\\n0.0 & 0.0 & 0.0& 0.0& 0.0& 0.3679 & 0.3679 & 0.2642\\\\\n0.0 & 0.0 & 0.0& 0.0& 0.0& 0.0& 0.3679 & 0.6321\\\\\n\\end{pmatrix}\\]En esta situación estamos interesados en analizar las siguientes características del estado estacionario del proceso \\(X_n\\):Periodo del proceso.Fracción de tiempo en que el buffer estará lleno.Número esperado de paquetes que esperan en el buffer.Definamos la estructura del proceso para la librería markovchain, y pidamos la distribución estacionaria.Tenemos que la CMTD es irreducible, luego por los resultados teóricos tiene una única distribución estacionaria, que coincidirá con la distribución límite y con la distribución de los tiempos de ocupación.Que el buffer esté lleno significa que nos encontramos en el estado “7,” y al ser la distribución estacionaria la del tiempo de ocupación, tenemos que la fracción de tiempo en que el buffer está lleno es del 13.64%.El número esperado de paquetes en el buffer en el estado estacionario es un valor esperado calculado con la distribución límite/estacionaria, que al ser discreta se calcula fácilmente partir de las distribución estacionaria obtenida, esto es,Por lo tanto, largo plazo se espera que el buffer esté un poco más de la mitad de su capacidad.Ejemplo 2.11  Consideramos el proceso de Planificación de mano de obra, donde suponemos que la empresa tiene 70 empleados cuyo nivel cambia lo largo del tiempo. Supongamos que los gastos de nómina semanales por persona son de 400 dólares para el grado 1, 600 dólares para el grado 2, 800 dólares para grado 3, y $1000 para el grado 4. Estamos interesados en calcular los gastos semanales promedio por empleado.Aplicando el resultado en la Definición 2.21, comprobemos que el proceso es irreducible y procedamos aplicar la fórmula correspondiente, si es el caso.Por tanto, los gastos semanales promedio por trabajador son de 618.20 dólares, lo que multiplicado por el número de empleados (70) supone 43274 dólares.","code":"\nperiod(proceso)## [1] 1\n# Distribución estacionaria\nsteadyStates(proceso)##              a         b         c\n## [1,] 0.3703704 0.1111111 0.5185185\n# Estructura del proceso\n# Definimos estados\nestados <- as.character(0:7)\n# Matriz de transición \npmat <- matrix(data = c(0.3679, 0.3679, 0.1839, 0.0613, 0.0153, \n                        0.0031, 0.0005, 0.0001,\n0.3679, 0.3679, 0.1839, 0.0613, 0.0153, 0.0031, 0.0005, 0.0001,\n0.0, 0.3679, 0.3679, 0.1839, 0.0613, 0.0153, 0.0031, 0.0006,\n0.0, 0.0, 0.3679, 0.3679, 0.1839, 0.0613, 0.0153, 0.0037,\n0.0, 0.0, 0.0, 0.3679, 0.3679, 0.1839, 0.0613, 0.0190,\n0.0, 0.0, 0.0, 0.0, 0.3679, 0.3679, 0.1839, 0.0803,\n0.0, 0.0, 0.0, 0.0, 0.0, 0.3679, 0.3679, 0.2642,\n0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3679, 0.6321), \n               byrow = TRUE, nrow = 8, \n               dimnames = list(estados, estados))\n# CMTD\nteleco <- new(\"markovchain\", states = estados, \n                 byrow = TRUE, transitionMatrix = pmat, \n              name = \"Telecomunicaciones\")\n# Revisamos si la CMTD es irreducible\nsummary(teleco)## Telecomunicaciones  Markov chain that is composed by: \n## Closed classes: \n## 0 1 2 3 4 5 6 7 \n## Recurrent classes: \n## {0,1,2,3,4,5,6,7}\n## Transient classes: \n## NONE \n## The Markov chain is irreducible \n## The absorbing states are: NONE\n# Periodo del sistema\nperiod(teleco)## [1] 1\n# Distribución estacionaria\nsteadyStates(teleco)##               0         1         2         3         4         5         6         7\n## [1,] 0.06820411 0.1171835 0.1331324 0.1360701 0.1363485 0.1363554 0.1363497 0.1363562\nestados <- 0:7\ndistribucion <- steadyStates(teleco)\n# Valor esperado\nsum(estados*distribucion)## [1] 3.791421\n# ¿el proceso es irreducible?\nsummary(planificacion)## planificacion  Markov chain that is composed by: \n## Closed classes: \n## 1 2 3 4 \n## Recurrent classes: \n## {1,2,3,4}\n## Transient classes: \n## NONE \n## The Markov chain is irreducible \n## The absorbing states are: NONE\n# Vector de costes\ncostes <- c(400, 600, 800, 1000)\n# distribución estado estacionario\ndistribucion <- steadyStates(planificacion)\n# gastos esperados por semana\ncat(\"\\n Gastos semanales:\",sum(distribucion*costes))## \n##  Gastos semanales: 618.1818"},{"path":"cmtd.html","id":"estudio-de-caso","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.6 Estudio de caso","text":"Veamos por último, una aplicación completa del análisis de una CMTD.Sabemos que en cada idioma las frecuencias de transición entre vocales y consonantes son diferentes. partir de análisis recurrentes con textos de dos idiomas hemos identificado las probabilidades de transición entre vocales y consonantes en cada uno, estados=(vocal,consonante), y que vienen dadas continuación.\\[p1=\\left(\\begin{matrix}\n0.51 & 0.49 \\\\\n0.90 & 0.10\n\\end{matrix}\n\\right), \\qquad \np2=\\left(\\begin{matrix}\n0.25 & 0.75 \\\\\n0.30 & 0.70\n\\end{matrix}\n\\right)\\]Definimos primero los procesos para la librería markovchain partir de las probabilidades de transición.Verificamos que todos sus estados son recurrentes y la cadena es irreducible.Planteamos ahora una serie de preguntas responder.En cada idioma, ¿cuál es la probabilidad de que si un texto empieza por vocal, el siguiente carácter sea consonante?Calculamos pues, la distribución de los estados del sistema partiendo de una vocal, manualmente y con la función transitionProbability() o con conditionalDistribution(), que nos da la distribución condicional partiendo de un estado:Resulta que en el idioma1 la probabilidad de que si un texto empieza por vocal el siguiente carácter sea consonante es de 0.49 y en el idioma2 de 0.75.En cada idioma, ¿cuál es la probabilidad de que si un texto empieza por vocal, tras contar 10 caracteres más, encontremos una consonante?Utilizamos el resultado que se mostró en la Ecuación (2.5) para calcular la matriz de transición de \\(n\\) pasos.Si un texto empieza por voca, tras 10 caracteres encontraremos una consonante con probabilidad 0.35 en el idioma1 y con probabilidad 0.71 en el idioma2.En cada idioma, en palabra de 5 caracteres que empieza por vocal, ¿cuántas vocales esperamos encontrar? ¿Y si la palabra empieza por consonante?Nos pregunta por el número de visitas o tiempo de ocupación de cada uno de los estados (vocal/consonante) cuando llegamos 5 caracteres (en 4 transiciones entre caracteres). Calculamos pues la matriz de tiempos de ocupación hasta el instante \\(n=4\\) con la Ecuación (2.7), y para la que utilizamos la función mocupa.proceso() que definimos en la Sección Tiempos de ocupación.Así, en el idioma1, si partimos de un texto que empieza en vocal, esperamos encontrar 3 vocales y si partimos de una consonante, 2.8 vocales. En el idioma2, si el primer carácter es vocal, encontraré 2.1 vocales y 3 vocales si el texto empieza por consonante.¿Cuántos caracteres habremos de leer por término medio en un texto (en cada idioma) hasta encontrar la primera vocal?Nos están preguntando por el tiempo medio de primer paso por una vocal, partiendo de una consonante. Resolvemos con la función meanFirstPassageTime().Tenemos así que el número medio de caracteres que esperamos encontrar en un texto hasta que aparezca por primera vez una vocal en el idioma 1 (partiendo de una consonante) es de 1, y en el idioma2 de 3.En un texto que se inicia con una vocal, ¿con qué probabilidad encontraremos la primera consonante en los siguientes 3 caracteres? Compara los resultados para los dos idiomas.Nos preguntan por la probabilidad de primer paso por el estado “consonante” partiendo de una “vocal” transcurridos tres caracteres. Utilizamos la función firstPassageMultiple() de la librería markovchain.Así, tenemos que en el idioma1 la probabilidad de que la primera consonante que encontremos esté tres caracteres después de la vocal de inicio es de 0.127449, mientras que esta probabilidad en el idioma2 es sólo de 0.127449.partir de una consonante, ¿cuántos caracteres, por término medio, tardamos en encontrar otra consonante en cada idioma?Nos están pidiendo el tiempo medio de recurrencia, esto es, volver encontrar otra consonante si partimos de una consonante, que calculamos con la función meanRecurrenceTime().Así, en el idioma1, desde la última consonante tendremos aproximadamente 3 caracteres hasta encontrar otra consonante, mientras que en el idioma2 sólo 1 por término medio.¿Qué proporción de vocales y consonantes hay en cada idioma? En un texto de 1000 caracteres que empieza por vocal, ¿cuántas vocales esperamos encontrar? ¿Y consonantes?Para contestar la primera pregunta recurrimos la distribución estacionaria, que nos da la probabilidad estacionaria para cada uno de los estados posibles, o lo que es lo mismo, la proporción de vocales y consonantes. Para responder la segunda pregunta, puesto que estamos en un texto muy largo con 1000 caracteres, ya utilizaremos la matriz de ocupación hasta un instante \\(n=1000\\), sino la distribución de ocupación, que coincide con la distribución estacionaria.Sabemos que una CMTD irreducible y aperiódica tiene una única distribución estacionaria, que coincide con la distribución de ocupación. Que es irreducible ya lo comprobamos anteriormente al definir el sistema; verifiquemos pues que es aperiódica, esto es, que su periodo es 1, con la función period().Así pues, calculamos la distribución estacionaria continuación con la función steadyStates().Tenemos que en el idioma1 el 65% de los caracteres en un texto son vocales, que predominan sobre las consonantes, mientras que en el idioma2 sólo un 29%, y la supremacía es de las consonantes, con un 71.4%.Para calcular el número esperado de vocales y consonantes en un texto de 1000 caracteres, basta multiplicar estas probabilidades por 1000.Así, en un texto de 1000 caracteres esperamos 647 vocales en el idioma1 y 286 en el idioma2.Vamos comprobar, además, que la distribución estacionaria verifica la ecuación de balance o del estado estacionario que se muestra en la Ecuación (2.10).Con la distribución estacionaria comprobamos que se verifica la Ecuación (2.12) que nos permite calcular los tiempos medios de recurrencia con el inverso de las probabilidades estacionarias. Lo hacemos sólo con el idioma1.Simula un texto de 1000 caracteres para el idioma1, empezando por una vocal y estima con esas simulaciones las probabilidades de transición. Compara los resultados con la matriz inicial.Para simular una CMTD recurrimos la función rmarkovchain().Para estimar las probabilidades de transición con los textos simulados vamos utilizar la librería markovchain que específicamente nos proporciona las frecuencias de salto, así como una estimación (junto con su error), basada en dichas frecuencias, bajo diversos procedimientos de estimación.La función createSequenceMatrix() nos proporciona una matriz de frecuencias (absolutas o relativas) de las transiciones entre todos los estados posibles del sistemaUtilizamos ahora la función markovchainFit() que, partir de datos simulados en estado estacionario, estima las probabilidades de transición. Podemos usar varios métodos de optimización alternativos, si bien por defecto se usa la estimación máximo-verosímil, method=\"mle\". Las alternativas son EMV con suavizado de Laplace (“laplace”), bootstrap (“bootstrap”) y máximo posteriori (“map”).Esta función nos proporciona, además de la estimación de las probabilidades de transición, una estimación del error e intervalos de confianza.Supón que accedes un texto que transformas en una secuencia de vocales y consonantes (disponible para descarga en Github). Verifica, con dicha secuencia que proviene de una CMTD.Para ello podemos utilizar la función verifyMarkovProperty() que resuelve un test de hipótesis basado en la Chi-cuadrado, sobre el cumplimiento de la propiedad de Markov con los datos proporcionados. Obtener un p-valor significativo significa que rechazaríamos esa propiedad y por lo tanto rechazaríamos que se trata de una CMTD.El p-valor es de 0.84, que permite rechazar la propiedad de Markov.Por último, para testar la estacionariedad, esto es, si \\(p_{ij}(n)=p_{ij}\\) para cualquier \\(n\\), tenemos la función assessStationarity(). Obtener un p-valor significativo significa que rechazaríamos esa propiedad y por lo tanto rechazaríamos que se trata de una CMTD.Con los datos utilizados en el apartado anterior, verifica si alguno de los textos que se proporcionan en las columnas de la base de datos, se podría asimilar como perteneciente alguno de los idiomas presentados, idioma1 o idioma2.Para contrastar la similitud entre una secuencia y un proceso teórico que tenemos definido podemos utilizar la función verifyEmpiricalToTheoretical(). Veamos cómo funciona con los procesos idioma1 e idioma2.El p-valor resultante es 0.29, con lo cual se puede rechazar la hipótesis nula de que la secuencia dada es compatible con el idioma1. Podría ser pues, un texto de dicho idiomaVeamos ahora su compatibilidad con el idioma2:En este caso el p-valor es cero, por lo que rechazamos la compatibilidad y claramente aceptamos que este texto proviene del idioma2.","code":"\nestados=c(\"vocal\",\"consonante\")\n# matriz de transición idioma1\np1=matrix(c(0.51,0.49,0.9,0.1),byrow = TRUE,ncol=2,dimnames=list(estados,estados))\n# proceso 1: idioma1\nidioma1=new(\"markovchain\",states=colnames(p1),byrow=TRUE,transitionMatrix=p1,name=\"idioma1\")\n# matriz de transición idioma2\np2=matrix(c(0.25,0.75,0.3,0.7),byrow = TRUE,ncol=2,dimnames=list(estados,estados))\n# proceso 2: idioma2\nidioma2=new(\"markovchain\",states=colnames(p2),byrow=TRUE,transitionMatrix=p2,name=\"idioma2\")\n\n# y lo mostramos en formato data.frame\nas(idioma1,\"data.frame\")##           t0         t1 prob\n## 1      vocal      vocal 0.51\n## 2      vocal consonante 0.49\n## 3 consonante      vocal 0.90\n## 4 consonante consonante 0.10\nas(idioma2,\"data.frame\")##           t0         t1 prob\n## 1      vocal      vocal 0.25\n## 2      vocal consonante 0.75\n## 3 consonante      vocal 0.30\n## 4 consonante consonante 0.70\ncat(\"Descripción idioma1\\n\")## Descripción idioma1\nsummary(idioma1)## idioma1  Markov chain that is composed by: \n## Closed classes: \n## vocal consonante \n## Recurrent classes: \n## {vocal,consonante}\n## Transient classes: \n## NONE \n## The Markov chain is irreducible \n## The absorbing states are: NONE\ncat(\"\\n Descripción idioma2\\n\")## \n##  Descripción idioma2\nsummary(idioma2)## idioma2  Markov chain that is composed by: \n## Closed classes: \n## vocal consonante \n## Recurrent classes: \n## {vocal,consonante}\n## Transient classes: \n## NONE \n## The Markov chain is irreducible \n## The absorbing states are: NONE\n#determinamos el estado inicial\nini=c(1,0)\n# y manualmente evaluamos los productos\nfinal1=ini %*% p1; final1##      vocal consonante\n## [1,]  0.51       0.49\nfinal2=ini %*% p2; final2##      vocal consonante\n## [1,]  0.25       0.75\n# o extraemos la distribución condicional partiendo del estado inicial \"vocal\":\nconditionalDistribution(idioma1,\"vocal\")##      vocal consonante \n##       0.51       0.49\nconditionalDistribution(idioma2,\"vocal\")##      vocal consonante \n##       0.25       0.75\n# o usamos la función de la librería markovchain\ntransitionProbability(idioma1,t0=\"vocal\",t1=\"consonante\")## [1] 0.49\ntransitionProbability(idioma2,t0=\"vocal\",t1=\"consonante\")## [1] 0.75\nini = c(1,0)\nfinal1.10 = ini %*% ptran.n(p1,10); final1.10##          vocal consonante\n## [1,] 0.6475107  0.3524893\nfinal2.10 = ini %*% ptran.n(p2,10); final2.10##          vocal consonante\n## [1,] 0.2857143  0.7142857\nn=4\nmocupa1=mocupa.proceso(idioma1,n);mocupa1##               vocal consonante\n## vocal      3.493308   1.506692\n## consonante 2.767393   2.232607\nmocupa2=mocupa.proceso(idioma2,n);mocupa2##               vocal consonante\n## vocal      2.108844   2.891156\n## consonante 1.156462   3.843537\n# todos los tiempos de primer paso\nmeanFirstPassageTime(idioma1)##               vocal consonante\n## vocal      0.000000   2.040816\n## consonante 1.111111   0.000000\n# tiempo de primer paso por una vocal\nmfpt1=meanFirstPassageTime(idioma1,\"vocal\");mfpt1## consonante \n##   1.111111\nmeanFirstPassageTime(idioma2)##               vocal consonante\n## vocal      0.000000   1.333333\n## consonante 3.333333   0.000000\nmfpt2=meanFirstPassageTime(idioma2,\"vocal\");mfpt2## consonante \n##   3.333333\nn=3\nfpm1=firstPassageMultiple(idioma1,state=\"vocal\",set=c(\"consonante\"),n=n);fpm1##        set\n## 1 0.490000\n## 2 0.249900\n## 3 0.127449\nfpm2=firstPassageMultiple(idioma2,state=\"vocal\",set=c(\"consonante\"),n=n);fpm2##        set\n## 1 0.750000\n## 2 0.187500\n## 3 0.046875\nmrt1=meanRecurrenceTime(idioma1);mrt1##      vocal consonante \n##   1.544444   2.836735\nmrt2=meanRecurrenceTime(idioma2);mrt2##      vocal consonante \n##        3.5        1.4\nperiod(idioma1)## [1] 1\nperiod(idioma2)## [1] 1\npi1=steadyStates(idioma1); pi1##         vocal consonante\n## [1,] 0.647482   0.352518\npi2=steadyStates(idioma2); pi2##          vocal consonante\n## [1,] 0.2857143  0.7142857\nround(1000*pi1)##      vocal consonante\n## [1,]   647        353\nround(1000*pi2)##      vocal consonante\n## [1,]   286        714\n# ecuación de balance para la d.estacionaria del idioma1\npi1##         vocal consonante\n## [1,] 0.647482   0.352518\n# es igual a su producto por la matriz de transición\npi1%*%p1##         vocal consonante\n## [1,] 0.647482   0.352518\n# y sus probabilidades suman 1\nsum(pi1)## [1] 1\n1/pi1##         vocal consonante\n## [1,] 1.544444   2.836735\nmeanRecurrenceTime(idioma1)##      vocal consonante \n##   1.544444   2.836735\nset.seed(12)\nn=1000\nidioma1.sim=rmarkovchain(n,idioma1,t0=\"vocal\",include.t0=TRUE)\n# frecuencias de transiciones o saltos\ncreateSequenceMatrix(idioma1.sim)##            consonante vocal\n## consonante         39   311\n## vocal             311   339\n# frecuencias relativas de transiciones o saltos\ncreateSequenceMatrix(idioma1.sim,toRowProbs = TRUE )##            consonante     vocal\n## consonante  0.1114286 0.8885714\n## vocal       0.4784615 0.5215385\n# Estimación de p1\np1.sim = markovchainFit(idioma1.sim,byrow=TRUE)\np1.sim;p1## $estimate\n## MLE Fit \n##  A  2 - dimensional discrete Markov Chain defined by the following states: \n##  consonante, vocal \n##  The transition matrix  (by rows)  is defined as follows: \n##            consonante     vocal\n## consonante  0.1114286 0.8885714\n## vocal       0.4784615 0.5215385\n## \n## \n## $standardError\n##            consonante      vocal\n## consonante 0.01784285 0.05038626\n## vocal      0.02713106 0.02832608\n## \n## $confidenceLevel\n## [1] 0.95\n## \n## $lowerEndpointMatrix\n##            consonante     vocal\n## consonante 0.07645722 0.7898161\n## vocal      0.42528562 0.4660204\n## \n## $upperEndpointMatrix\n##            consonante     vocal\n## consonante  0.1463999 0.9873267\n## vocal       0.5316375 0.5770566\n## \n## $logLikelihood\n## [1] -572.2645##            vocal consonante\n## vocal       0.51       0.49\n## consonante  0.90       0.10\nestimate = as(p1.sim$estimate,\"data.frame\")\nerror = as.vector(p1.sim$standardError)\nic.low = as.vector(p1.sim$lowerEndpointMatrix)\nic.up = as.vector(p1.sim$upperEndpointMatrix)\ncbind(estimate,error,ic.low,ic.up)##           t0         t1      prob      error     ic.low     ic.up\n## 1 consonante consonante 0.1114286 0.01784285 0.07645722 0.1463999\n## 2 consonante      vocal 0.8885714 0.02713106 0.42528562 0.5316375\n## 3      vocal consonante 0.4784615 0.05038626 0.78981615 0.9873267\n## 4      vocal      vocal 0.5215385 0.02832608 0.46602035 0.5770566\n# leemos los datos de Github\ntexto=read.csv(\"https://raw.githubusercontent.com/UMH1477/data/f4e4a62533e24a74be27b8984f9fc23eb1b1ff49/textos.csv\")\n# visualizamos el formato de los datos, con 2 columnas de texto\nhead(texto)##       texto1     texto2\n## 1      vocal consonante\n## 2      vocal consonante\n## 3 consonante consonante\n## 4      vocal      vocal\n## 5 consonante consonante\n## 6 consonante consonante\n# y ejecutamos el test sobre una de las columnas de texto\nverifyMarkovProperty(texto$texto1)## Testing markovianity property on given data sequence\n## Chi - square statistic is: 2.056533 \n## Degrees of freedom are: 5 \n## And corresponding p-value is: 0.8412687\nassessStationarity(texto$texto1,5)## Warning in assessStationarity(texto$texto1, 5): The accuracy of the statistical inference functions\n## has been questioned. It will be thoroughly investigated in future versions of the package.## Warning in chisq.test(mat): Chi-squared approximation may be incorrect\n\n## Warning in chisq.test(mat): Chi-squared approximation may be incorrect## The assessStationarity test statistic is:  0.0002538706 \n## The Chi-Square d.f. are:  8 \n## The p-value is:  1\n# comparamos con el idioma1\nverifyEmpiricalToTheoretical(texto$texto1,idioma1)## Testing whether the\n##            vocal consonante\n## vocal      32800      31854\n## consonante 31854       3491\n## transition matrix is compatible with\n##            vocal consonante\n## vocal       0.51       0.49\n## consonante  0.90       0.10\n## [1] \"theoretical transition matrix\"\n## ChiSq statistic is 2.460873 d.o.f are 2 corresponding p-value is 0.292165## $statistic\n##    vocal \n## 2.460873 \n## \n## $dof\n## [1] 2\n## \n## $pvalue\n##    vocal \n## 0.292165\n# comparamos con el idioma2\nverifyEmpiricalToTheoretical(texto$texto1,idioma2)## Testing whether the\n##            vocal consonante\n## vocal      32800      31854\n## consonante 31854       3491\n## transition matrix is compatible with\n##            vocal consonante\n## vocal       0.25       0.75\n## consonante  0.30       0.70\n## [1] \"theoretical transition matrix\"\n## ChiSq statistic is 76057.57 d.o.f are 2 corresponding p-value is 0## $statistic\n##    vocal \n## 76057.57 \n## \n## $dof\n## [1] 2\n## \n## $pvalue\n## vocal \n##     0"},{"path":"cmtd.html","id":"ejer-u2","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.7 Ejercicios","text":"","code":""},{"path":"cmtd.html","id":"básicos-1","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.7.1 Básicos","text":"Ejercicio B2.1. Para el proceso Meteorologia se desea conocer cuál es el tiempo estimado para tener un día lluvioso si hoy tenemos un día soleado.Ejercicio B2.2. Para el proceso Mercado de valores se desea conocer cuál es el tiempo estimado en conseguir que las acciones alcancen los valores \\(8, 9, 10\\) partiendo de un valor inicial de \\(5\\).Ejercicio B2.3. Consideramos el proceso Mercado de valores. Supongamos que el gerente financiero ha comprado 100 acciones 5 dólares, y está interesado en conocer cuál es el beneficio neto esperado de su inversión en 5 días.Ejercicio B2.4. En una boutique de café se cambian semanalmente los escaparates, promocionando tres tipos de café , B y C en función de la demanda que registran. Según ello, la promoción de los tres tipos cambia de una semana otra de acuerdo la siguiente matriz de transición:\\[P = \n\\begin{pmatrix}\n0.3 & 0.3 & 0.4\\\\\n0.1 & 0.5 & 0.4\\\\\n0.3 & 0.2 & 0.5\\\\\n\\end{pmatrix}\\]Si en la semana 1 se expone el tipo en el escaparate, ¿cuál es la probabilidad de que en la semana 10 se esté promocionando cualquiera de las tres marcas?Ejercicio B2.5. Consideramos el proceso descrito en la sección Telecomunicaciones. Asumimos que en el estado inicial el buffer está lleno y deseamos conocer el número esperado de paquetes en el buffer en los instantes \\(n =1, 2, 5\\) y \\(10\\), asumiendo que el tamaño del buffer es 10 y que el número de paquetes que llegan en un instante es una variable aleatoria \\(Bi(5, 0.2).\\)Ejercicio B2.6. Consideramos el proceso descrito en la sección Planificación de mano de obra. Supongamos que la empresa tiene 100 empleados en la semana 1, distribuidos como sigue: 50 en el nivel 1, 25 en el grado 2, 15 en el grado 3, y 10 en el grado 4. Si cada empleado tiene un comportamiento independiente respecto del resto ¿cuál es el número esperado de empleados en cada grado al principio de la semana 4?Ejercicio B2.7. Consideramos el proceso descrito en la sección Problema de inventario. Estamos interesados en conocer cuál es la proporción de semanas en que el inventario estará lleno durante el proximo año, si empezamos con un inventario de 5 PCs?Ejercicio B2.8. La secuencia de consonantes y vocales en el lenguaje humano se puede modelizar mediante una \\(CMTD\\) dado que después de una vocal siempre le sigue una consonante con probabilidad 0.49 y una vocal con probabilidad 0.51. Después de una consonante hay otra consonante con probabilidad 0.1. Codificamos un texto completo con una secuencia de ceros (vocal) y unos (consonantes). Obtén la matriz de transición para este proceso. Si el texto comienza con una consonante, ¿qué tipo de elemento será el que aparezca en la quinta posición de la secuencia? ¿Qué porcentaje de vocales y consonantes encontraremos en un texto de 2000 letras?Ejercicio B2.9 Considera el proceso descrito en la sección Fiabilidad de máquinas, con dos máquinas. Supón que ambas máquinas están operativas al principio del día 0. Calcula la probabilidad de que el número de máquinas operativas al principio de los próximos tres días sea 2, 1 y 2, en ese orden.Ejercicio B2.10. Calcula la matriz de ocupación \\(M(10)\\), la distribución límite y la estacionaria, para un proceso CMTD con matriz de transición dada por:\\[P=\\begin{pmatrix}\n0.1 & 0.3 & 0.2 & 0.4 \\\\\n0.1 & 0.3 & 0.4 & 0.2 \\\\\n0.3 & 0.1 & 0.1 & 0.5 \\\\\n0.15 & 0.25 & 0.35 & 0.25 \n\\end{pmatrix}\\]","code":""},{"path":"cmtd.html","id":"avanzados-1","chapter":"Unidad 2 Cadenas de Markov de Tiempo Discreto","heading":"2.7.2 Avanzados","text":"Ejercicio A2.1. Los artículos llegan un taller mecánico de forma determinista un ritmo de uno por minuto. Cada artículo se comprueba antes de cargarlo en la máquina. Un artículo es adecuado con probabilidad \\(p\\) y defectuoso con una probabilidad \\(1-p\\). Si un artículo es defectuoso, se descarta; en caso contrario, se carga en la máquina. La máquina tarda exactamente 1 minuto en procesar el artículo, tras lo cual está lista para procesar el siguiente. Consideramos la variable aleatoria \\(X_n\\) que toma el valor \\(0\\) si la máquina está inactiva al principio del n-ésimo minuto y 1 si está iniciando el proceso.Obtén la matriz de transición de este proceso.Si \\(p = 0.98\\), ¿cuál es la proporción de tiempo en que la máquina está cargando un artículo durante las próximas ocho horas?¿Cuántas horas tendrán que pasar para que la máquina descarte un artículo cuando el primero se descarta?Supongamos ahora que la máquina puede procesar dos artículos simultáneamente. Sin embargo, tarda 2 minutos en completar el procesamiento. Delante de la máquina hay un contenedor en el que se pueden almacenar dos artículos defectuosos. En cuanto hay dos artículos en la bandeja, se cargan en la máquina y ésta empieza procesarlos.Obtén la matriz de transición de este proceso.¿Cuál es la proporción de tiempo en que la máquina carga artículos durante las próximas ocho horas?¿Cuántas horas tendrán que pasar para que la máquina descarte dos artículos cuando los dos primeros son defectuosos?Ejercicio A2.2. Un vendedor vive en la ciudad “” y es responsable de la venta de su producto en las ciudades “,” “b” y ‘c.’ Cada semana tiene que visitar una ciudad diferente. Cuando está en su ciudad natal, le da igual la ciudad que visite continuación, así que lanza una moneda y si sale cara va “b” y si sale cruz va “c.” Sin embargo, después de pasar una semana fuera de casa tiene una ligera preferencia por volver casa, así que cuando está en las ciudades ‘b’ o ‘c’ lanza dos monedas. Si salen dos caras, se va la otra ciudad; de lo contrario va ‘.’ Las sucesivas ciudades que visita forman una cadena de Markov con un espacio de estados \\(S = \\{, b, c\\}\\) en la que la variable aleatoria \\(X_n\\) es igual ‘,’ ‘b’ o ‘c’ según su ubicación durante la semana \\(n\\). Obtén la matriz de transición de este proceso.Empezando en su ciudad natal, ¿en qué ciudad se encontrará dentro de seis semanas?¿Cuál es la proporción de tiempo en que el vendedor se encontrará fuera de casa durante los próximos seis meses?Si inicialmente está en la ciudad ‘,’ ¿cuántas semanas tendrán que pasar para que visite la ciudad ‘c?’Si el vendedor obtiene un beneficio de 1200 euros cuando pasa una semana en la ciudad ‘,’ de 1200 euros cuando está en ‘b,’ y de 1250 cuando está en ‘c,’ ¿cuál será el beneficio esperado después de 12 semanas si comienza en su ciudad natal?¿Cuál será el beneficio esperado después de 12 semanas si desconocemos la ciudad de partida pero sabemos que hay una probabilidad de 0.5 que sea ‘,’ 0.3 de que sea ‘b,’ y 0.2 de que sea ‘c?’Ejercicio A2.3. Se lleva cabo un análisis de mercado para conocer las preferencias de compras de coches en formato “renting,” según el cual cada año se renueva el coche cada cliente del servicio en el mes de enero. La empresa está interesada en conocer si los clientes cambian el estilo de vehículo entre las tres opciones posibles (“sedan,” “station wagon,” y “convertible”) de un año al siguiente. Para estudiar este proceso se toman los datos de cambio de vehículo del último mes de enero:Este sistema se puede modelizar según una \\(CMTD\\) con espacio de estados \\(S = \\{s, w, c\\}\\).Obtén la matriz de transición asociada este proceso.¿Cuál es la probabilidad de que un cliente mantenga el mismo tipo de vehículo dentro de tres años? ¿y de cinco?¿Cuál es el tiempo esperado de permanencia con el mismo tipo de vehículo en los próximos 10 años?¿Cuál es el tiempo esperado hasta el primer cambio para cualquiera de los tipos considerados?Si un “sedan” proporciona un beneficio anual de 1200 euros, el “station wagon” de 1500, y el “convertible” de 2500 euros, ¿cuál es el beneficio promedio esperado para un año? ¿y para 5 años?Ejercicio A2.4. Un proceso de fabricación consiste en dos etapas consecutivas mediante el esquema siguiente:En la etapa 1, el 20% de las piezas son devueltas para su reelaboración, el 10% son desechadas, y el 70% restante pasan la etapa 2.En la etapa 2, el 5% de las piezas deben ser devueltas la etapa 1, el 10% deben ser reelaboradas, el 5% son desechadas, y el 80% restantes se consideran adecuadas para la venta.Considerando todos los estados del proceso (e1 = etapa 1; e2 = etapa 2; d = desechado; v = venta) construye la matriz de transición correspondiente este proceso.La estructura de costes del proceso viene dada por:El coste del material que va entrar entra en la etapa 1 es de 150 euros.Cada parte que es procesada en la etapa 1 incurre en un coste de 200 euros.Cada parte que es procesada en la etapa 2 incurre en un coste de 300 euros.Cada parte que es rechazada en el etapa 1 pero si es rechazada en l etapa 2 incurre en un coste de 850 euros.El material que es desechado debe someterse un proceso de eliminación especial con u coste de 50 euros por parte.El sistema es capaz de tratar suficiente material para generar 100 partes al cabo de un día (aptas para la venta o desechadas).Plantea un algoritmo de simulación que permita responder cuál es el coste medio del proceso de fabricación para los próximos 15 días. ¿Y la variabilidad estimada de dicho coste?Si la empresa quiere asegurar un beneficio neto del 5%, ¿qué precio debe vender las piezas aptas para asegurar dicho beneficio de acuerdo al coste medio estimado del proceso? ¿Cuál sería el rango de venta teniendo en cuenta las fluctuaciones del coste medio?Ejercicio A2.4 simplificado\nUn proceso de fabricación consiste en dos etapas consecutivas mediante el esquema siguiente:En la etapa 1, el 20% de las piezas son devueltas para su reelaboración, el 10% son desechadas, y el 70% restante pasan la etapa 2.En la etapa 2, el 5% de las piezas deben ser devueltas la etapa 1, el 10% deben ser reelaboradas, el 5% son desechadas, y el 80% restantes se consideran adecuadas para la venta.Las piezas desechadas se quedan desechadas y las que se ponen la venta se quedan en el mercado.Considerando todos los estados del proceso (e1 = etapa 1; e2 = etapa 2; d = desechado; v = venta) construye la matriz de transición correspondiente este proceso.La estructura de costes del proceso viene dada por:Cada paso por la etapa 1 es de 150 euros.Cada paso por la etapa 2 es de 300 euros.Cada producto desechado debe someterse un proceso de eliminación especial con un coste de 50 euros por parte.Poner la venta un producto conlleva unos costos de distribución de 10 euros.El sistema es capaz de tratar suficiente material para generar 100 partes al cabo de un día (aptas para la venta o desechadas).Plantea un algoritmo de simulación que permita reproducir el recorrido de un producto en la cadena de producción, iniciándose en la etapa 1. Evalúa el coste de ese producto.Plantea un algoritmo de simulación que permita reproducir el recorrido de un producto en la cadena de producción, iniciándose en la etapa 1. Evalúa el coste de ese producto.Simula el proceso de producción durante 10 días y con todos los productos procesados da una estimación del coste medio de producción. Calcula el error y un intervalo de confianza. Interpreta el intervalo de confianza.Simula el proceso de producción durante 10 días y con todos los productos procesados da una estimación del coste medio de producción. Calcula el error y un intervalo de confianza. Interpreta el intervalo de confianza.Si la empresa quiere asegurar (con garantías del 95%) un beneficio neto del 5%, ¿qué precio debe vender cada producto?Si la empresa quiere asegurar (con garantías del 95%) un beneficio neto del 5%, ¿qué precio debe vender cada producto?Ejercicio A2.5. Se lanza un misil al que se le envía una secuencia de señales de corrección de rumbo cuando es necesario. Supongamos que el sistema tiene cuatro estados que se etiquetan como sigue:Estado 0: en rumbo, sin necesidad de correcciones.Estado 1: correcciones mínimas.Estado 2: correcciones mayores.Estado 3: desviación controlable que hace necesaria la autodestrucción del mísil.Sea \\(X_n\\) que representa el estado del sistema después de la n-ésima corrección, de forma que si el mísil está en curso en el instante \\(n\\) se mantendrá en curso durante todo el vuelo; si necesita una corrección mímima, entonces con probabilidad 0.5 será necesaria ninguna corrección posterior, con probabilidad 0.25 será necesaria una nueva corrección menor, y con probabilidad 0.25 será necesaria una corrección mayor. Si en el instante \\(n\\) necesitamos una corrección mayor, con probabilidad 0.5 necesitaremos una corrección menor continuación, con probabilidad 0.25 necesitaremos otra corrección mayor, y con probabilidad 0.25 deberemos abortar la misión.¿Cuál es la matriz de transición para este proceso?Si un mísil necesita una corrección menor al inicio del lanzamiento, ¿cuál será su situación después de 3 correcciones?El mísil gasta 50000 libras de combustible en el lanzamiento, 1000 libras cuando una corrección menor es necesaria, y 5000 cuando una corrección mayor es necesaria. Simula el proceso para tratar de responder estas preguntas:¿Cuál será el consumo medio de combustible después de 4 correcciones?¿Y si lanzamos 6 cohetes la vez?Ejercicio A2.6. Al comienzo de cada semana, el estado de una máquina se determina midiendo la cantidad de corriente eléctrica que utiliza. En función de su lectura de amperaje, la máquina se clasifica en uno de los cuatro estados siguientes: bajo, medio, alto, fallido. Una máquina en estado bajo tiene una probabilidad de 0.05, 0.03 y 0.02 de estar en el estado medio, alto o fallido, respectivamente, al comienzo de la siguiente semana. Una máquina en estado medio tiene una probabilidad de 0.09 y 0.06 de estar en estado alta o fallida, respectivamente, al inicio de la siguiente semana; puede, por sí sola, pasar al estado bajo. Una máquina en estado alto tiene una probabilidad de 0.1 de estar en el estado fallido al comienzo de la siguiente semana; puede, por sí misma, pasar al estado bajo o medio. Si una máquina se encuentra en estado de fallo al comienzo de la semana, se inicia inmediatamente la reparación de la máquina para que (con probabilidad 1) esté en el estado bajo al comienzo de la semana siguiente.Modeliza este proceso como una \\(CMTD\\) y obtén la correspondiente matriz de transición.Si una máquina nueva siempre comienza en el estado bajo, ¿cuál es la probabilidad de que la máquina esté en estado de fallo tras tres semanas?¿Cuál es la probabilidad de que una máquina nueva tenga al menos un fallo dentro de tres semanas?En promedio, ¿cuántas semanas al año estará trabajando la máquina?Cada semana que la máquina está en estado bajo, se obtiene un beneficio de 1.000 dólares; cada semana que la máquina está en el estado medio, se obtiene un beneficio de 500 dólares; cada semana que la máquina está en estado alto, se obtiene un beneficio de 400 dólares; y la semana en la que se fija un fallo, se incurre en un coste de 700 dólares.¿Cuál es el beneficio semanal medio largo plazo obtenido por la máquina?Se ha sugerido cambiar la política de mantenimiento de la máquina. Si al comienzo de una semana la máquina está en el estado alto, la máquina se deja fuera de servicio y es reparada para que al inicio de la siguiente semana vuelva estar en el estado bajo. Cuando se realiza una reparación se incurre en un coste de 600 euros.¿Merece la pena esta nueva política de mantenimiento?Ejercicio A2.7. Nos interesa el traslado de planta de los pacientes dentro de un hospital. efectos de nuestro análisis, consideraremos que el hospital tiene tres tipos diferentes de plantas: habitaciones de “cuidados generales,” habitaciones de “cuidados especiales” y “cuidados intensivos.” Basándonos en datos anteriores, el 60% de los pacientes que llegan, ingresan inicialmente en la categoría de “cuidados generales,” el 30% en la de “cuidados especiales” y el 10% en la de “cuidados intensivos.” Un paciente de “cuidados generales” tiene un 55% de posibilidades de ser dado de alta sano al día siguiente, un 30% de permanecer en la planta de “cuidados generales,” y un 15% de ser trasladado la planta de “cuidados especiales.” Un paciente de “cuidados especiales” tiene un 10% de posibilidades de ser dado de alta al día siguiente, un 20% de ser trasladado “cuidados generales,” un 15% de pasar “cuidados intensivos.” Un paciente de “cuidados intensivos” nunca es dado de alta, hasta que muestra mejoría. Las probabilidades de que el paciente sea trasladado “cuidados generales,” “cuidados especiales” o que permanezca en “cuidados intensivos” son del 5%, el 30% o el 55%, respectivamente.Modeliza este sistema como una \\(CMTD\\) y obtén la correspondiente matriz de transición.¿Cuál es la probabilidad de que un paciente ingresado en la sala de cuidados intensivos salga sano del hospital?¿Cuál es el número esperado de días que un paciente, ingresado en cuidados intensivos pasará en la UCI?¿Cuál es la duración prevista de la estancia de un paciente ingresado en el hospital como paciente de cuidados generales?Durante un día normal, ingresan en el hospital 100 pacientes. ¿Cuál es el número medio de pacientes en la UCI?Ejercicio A2.8. La fabricación de un determinado tipo de placa electrónica consta de cuatro pasos: preparación, montaje, inserción y soldadura. Después de la etapa de montaje, el 5% de las piezas deben ser retiradas; después de la etapa de inserción, el 20% de las piezas son retiradas; y después de la etapa de soldadura, el 30% de las piezas deben ser devueltas la inserción y el 10% debe desecharse. Suponemos que cuando una pieza se devuelve una etapa de procesamiento, es tratada como cualquier otra pieza que entra en esa etapa.Modeliza este sistema como una \\(CMTD\\) y obtén la correspondiente matriz de transición.Si un lote de 100 placas comienza este proceso de fabricación, ¿cuántas se espera que acaben desechadas?¿Con cuántas placas deberíamos empezar si el objetivo es que el número esperado de placas que terminen siendo aceptadas sea igual 100?¿Con cuántas placas deberíamos empezar si queremos estar seguros al 90% de que terminamos con un lote de 100 placas?Cada vez que una placa pasa por una etapa de procesamiento, los costes directos de mano de obra y material son de 10 euros para la preparación, 15 euros para el montaje, 25 euros para la inserción y 20 euros para la soldadura. La materia prima cuesta 8 euros, y una placa desechada devuelve 2 euros. La tasa media de gastos generales es de 1.000.000 de euros al año, lo que incluye valores de recuperación de capital. El ritmo de procesamiento medio es de 5.000 placas por semana.Queremos fijar un precio por placa para que los ingresos previstos sean un 25% superiores los costes previstos. ¿En qué valor debemos fijar el precio?Ejercicio A2.9. Dentro de un área de mercado determinada hay dos marcas de jabón que la mayoría de la gente utiliza, el “superjabón” y el “jabón barato,” y el mercado actual se divide por igual entre las dos marcas. Una empresa está pensando en introducir una tercera marca llamada “jabón extra limpio,” y ha realizado algunos estudios iniciales sobre las condiciones del mercado. Sus estimaciones de las pautas de compra semanales son las siguientes: si un cliente compra superjabón esta semana, hay un 75% de posibilidades de que la próxima semana vuelva comprarlo, un 10% de probabilidad de que use el jabón extra limpio y un 15% de probabilidad de que use el jabón barato. Si un cliente compra el jabón extra limpio esta semana, hay un 50% de probabilidades de que cambie, y si lo hace, siempre será al superjabón. Si un cliente compra jabón barato esta semana, es igual de probable que la próxima semana el cliente compre cualquiera de las tres marcas.Asumiendo que se cumplen las condiciones de Markov, ¿cuál es la mariz de transición para este proceso?¿Cuál es la cuota de mercado largo plazo del nuevo jabón?¿Cuál será la cuota de mercado del nuevo jabón dos semanas después de su introducción?El mercado consta de aproximadamente un millón de clientes cada semana. Cada compra de superjabón produce un beneficio de 15 céntimos; una compra de jabón barato produce un beneficio de 10 céntimos; y una compra del extra limpio produce un beneficio de 25 céntimos. Supongamos que el mercado se encuentra en estado estacionario con la misma distribución entre los dos productos ya comercializados. La campaña publicitaria inicial para introducir la nueva marca fue de 100.000 dólares.¿Cuántas semanas pasarán hasta que se recuperen los 100.000 dólares de los ingresos añadidos del nuevo producto?La empresa considera que con estas tres marcas, una campaña publicitaria de 30.000 dólares por semana aumentará el mercado total semanal en un cuarto de millón de clientes? ¿Merece la pena la campaña? (Utiliza un criterio de media largo plazo).Ejercicio A2.10. Considera una \\(CMTD\\) con espacio de estados \\(S=\\{, b, c\\}\\) y con matriz de transición:\\[P = \n\\begin{pmatrix}\n0.3 & 0.5 & 0.2\\\\\n0.1 & 0.2 & 0.7\\\\\n0.8 & 0.0 & 0.2\\\\\n\\end{pmatrix}\\]Cada visita al ‘estado ’ produce un beneficio de 5 dólares, cada visita al ‘estado b’ produce un beneficio de 10 dólares, y cada visita al ‘estado c’ produce un beneficio de 12 dólares.Escribir un algoritmo que simule la cadena de Markov para poder estimar el beneficio esperado por paso, asumiendo que la cadena siempre comienza en el ‘estado .’Realizar 10 repeticiones del proceso con 25 pasos en cada una y obtener el valor medio del beneficio y rango para las 10 réplicas.Realizar 10 repeticiones con 1000 pasos en cada una y obtener el valor medio del beneficio y rango para las 10 réplicas.Comparar las estimaciones y los rangos de los dos escenarios propuestos.","code":""},{"path":"poissonprocess.html","id":"poissonprocess","chapter":"Unidad 3 Proceso de Poisson","heading":"Unidad 3 Proceso de Poisson","text":"En esta unidad se presentan se presentan los Procesos de Poisson que son la base de muchos de los sistemas de Cadenas de Markov de Tiempo Continuo que estudiaremos con más detalle más adelante. Este tipo de procesos estocásticos se utilizan para modelizar el número de ocurrencias de un evento en un periodo de tiempo determinado y nos sirven para modelizar situaciones bastante comunes como las llegadas de clientes una cola, el número de fallos que se producen en una cadena de producción, el número de reclamaciones que recibe una compañía de seguros, el número de accidentes de tráfico en una carretera, el número de pedidos en un sistema de inventarios,…Veamos continuación un ejemplo sencillo de utilización de este tipo de procesos.Ejemplo 3.1  Estamos interesados en estudiar la dinámica de la llegada de llamadas telefónicas un centro de llamadas. Para describir este proceso consideremos una colección de variables aleatorias \\(\\{N_t; t ≥ 0\\}\\), donde cada variable aleatoria \\(N_t\\), para un \\(t\\) dado, denota el número acumulado de llamadas que llegan al centro hasta el momento \\(t\\). Como estas llamadas registran un recuento, el espacio de estados es el conjunto de números naturales con el cero \\(S= \\{0,1,2,...\\}\\). En otras palabras, la llegada de llamadas telefónicas puede modelarse como un proceso estocástico de tiempos (parámetros) continuos con un espacio de estados contable.","code":""},{"path":"poissonprocess.html","id":"definición-y-propiedades","chapter":"Unidad 3 Proceso de Poisson","heading":"3.1 Definición y propiedades","text":"Definición 3.1  Sea un proceso estocástico de parámetro continuo \\(\\{N_t; t \\geq 0\\}\\) con \\(N_0 = 0\\), \\(N_t\\) representando el número de eventos que acontecen en el periodo \\((0,t]\\) y espacio de estados el de los enteros negativos, \\(S=\\{0,1,2,...\\}\\). Dicho proceso se denomina Proceso de Poisson (PP) de tasa \\(\\lambda\\) si:\\(P(N_t = k) = e^{\\lambda t}(\\lambda t)^k/k!\\) para \\(k=\\{0,1,2,...\\}, t \\geq 0\\), esto es, \\(N_t \\sim Po(\\lambda t)\\).Además, un PP verifica las siguientes propiedades:Propiedad de Markov: \\(P(N_{t+s} = j|N_s=, N_u, 0\\leq u \\leq s)=P(N_{t+s} = j|N_s=)\\). Lo que ocurre hasta cierto instante cuando se sabe lo que ocurrió hasta cierto instante anterior, depende de lo que ocurrió en instantes previos dicho instante anterior.Un proceso de Poisson tiene incrementos independientes. En otras palabras, lo que ocurre en un periodo de tiempo es independiente de lo que ocurre en otro, siempre que se solapen los dos periodos: \\(\\{N_{s+u} - N_s = \\}\\) es independiente del evento \\(\\{N_t = j\\}\\) si \\(t<s\\).Un proceso de Poisson tiene incrementos estacionarios, es decir, lo que sucede en un periodo de tiempo sólo depende de la amplitud de dicho periodo, y de cuándo empezó. La probabilidad \\(P(N_{s+u} - N_s = )\\) sólo depende del valor de \\(u\\), y \\(N_{s+u} - N_s \\sim P(\\lambda u)\\).Usando la definición de una variable aleatoria Poisson, es claro que para un proceso de Poisson\\[E(N_t) = \\lambda t\\]de forma que \\(\\lambda\\) proporciona la tasa media de llegadas por unidad de tiempo para un proceso de llegadas que está descrito por un PP con tasa \\(\\lambda\\).Ejemplo 3.2  Supongamos que \\(N(t)\\) representa el número de operaciones que se realizan en un quirófano de un hospital durante un intervalo de tiempo de amplitud \\(t\\), y que \\(\\{N(t), t\\geq0\\}\\) es un PP de tasa 24 operaciones por día.¿Cuál es el número medio de operaciones que se realizan en un turno de 8 horas?Puesto que un turno de 8 horas representa \\(8/24=1/3\\) de un día, y \\(N(t)\\sim Po(24t)\\), tendremos que \\(N(1/3)\\sim Po(24/3)\\), luego se esperan en torno \\(24/3=8\\) operaciones por turno.¿Cuál es la probabilidad de que haya operaciones entre las 12 de la noche y la 1 de la madrugada?Igual que antes, el número de operaciones que se realizan en una franja de una hora tendrá una distribución \\(N(1/24) \\sim Po(24/24)\\), luego la probabilidad de que haya operaciones en esa franja será de¿Cuál es la probabilidad de que haya tres operaciones entre las 8 .m. y las 12 del mediodía, y 4 operaciones entre las 12 del mediodía y las 5 p.m.?Si asumimos que \\(t=0\\) se corresponde con las 8,.m., las 12 del mediodía han transcurrido 4 horas, y hasta las 5 p.m. han transcurrido 9 horas. La probabilidad que nos piden se refiere una probabilidad conjunta de dos franjas horarias que se solapan, por lo que se trata de sucesos independientes y la probabilidad conjunta es el producto de las probabilidades individuales:\\[\\begin{eqnarray*}\n& Pr[N(4/24)-N(0)=3, N(9/24)-N(4/24)=4]= \\\\\n& \\qquad = Pr[N(4/24)-N(0)=3] \\cdot Pr[N(9/24)-N(4/24)=4]\n\\end{eqnarray*}\\]Ahora por la estacionariedad de los incrementos, tendremos que esa probabilidad la podemos escribir como\\[Pr[N(4/24)=3]\\cdot Pr[N(5/24)=4]\\]con las distribuciones \\(Po(24 \\cdot 4/24)=Po(4)\\) y \\(Po(24 \\cdot 5/24)=Po(5)\\).Proposición 3.1  Debido las propiedades de incrementos independientes y estacionariedad de un proceso de Poisson, la distribución de los tiempos entre llegadas consecutivas puede determinarse fácilmente.Sea \\(T_n\\) una v.. que identifica el tiempo que transcurre entre dos llegadas consecutivas \\(n\\) y \\(n-1\\). La probabilidad de que se produzca ninguna llegada en un intervalo de tiempo de amplitud \\(t\\), implica que \\(T_n>t\\) y viene dada por:\\[Pr(T_n > t)=Pr(N_t = 0) = e^{\\lambda t}.\\] Por lo tanto, \\(P(T_n \\leq 0) = 1 - P(T_n > 0) = 1 - e^{-\\lambda t}\\) para \\(t ≥ 0\\), que es la función de distribución Exponencial.Concluimos pues, que si las llegadas un sistema se producen según un PP de tasa \\(\\lambda\\), entonces los tiempos entre llegadas responden una distribución exponencial de parámetro \\(\\lambda\\).Definición 3.2  Para un PP con tasa \\(\\lambda\\), la distribución del tiempo entre dos llegadas consecutivas es exponencial de media \\(1/\\lambda\\).Si \\(\\{N_t; t \\geq 0\\}\\) es un PP que describe el número de llegadas que acontecen durante un periodo de tiempo de amplitud \\(t \\geq 0\\), entonces los tiempos entre llegadas consecutivas \\(n-1\\) y \\(n\\), \\(\\{T_n, n\\geq 1\\}\\), constituyen una secuencia de variables aleatorias iid (independientes e idénticamente distribuidas) \\(Exp(\\lambda)\\).Lo contrario también es cierto, es decir, un proceso de llegadas con tiempos entre llegadas que son exponenciales, es un PP.Proposición 3.2  Si \\(S_n\\) denota el tiempo que transcurre hasta la n-ésima llegada en un PP de tasa \\(\\lambda\\), entonces \\(S_n\\) se distribuye según una distribución Erlang \\(Erl(n,\\lambda)\\), con función de densidad dada por:\\[f(s) = \\frac{\\lambda(\\lambda s)^{k-1}e^{-\\lambda s}}{(k-1)!}, \\quad \\text{para } s \\geq 0\\] Esta propiedad es consecuencia de que la distribución Erlang \\(Erl(n,\\lambda)\\) surge de la suma de \\(n\\) v.. iid \\(Exp(\\lambda)\\).","code":"\n# probabilidad de que no haya operaciones en 1 hora\n# distribución Po(1)\nlambda=24\nfranja=1/24\nppois(0,lambda*franja)## [1] 0.3678794\ndpois(3,4)*dpois(4,5)## [1] 0.0342805"},{"path":"poissonprocess.html","id":"extensiones_pp","chapter":"Unidad 3 Proceso de Poisson","heading":"3.2 Extensiones","text":"","code":""},{"path":"poissonprocess.html","id":"superposicion_pp","chapter":"Unidad 3 Proceso de Poisson","heading":"3.2.1 Superposición","text":"Ejemplo 3.3  Consideremos una autovía que tiene dos puntos de acceso y B y sólo uno C de salida. Asumimos que los coches acceden la autovía por el punto según un PP con tasa de 8 vehículos por minuto, y también los que acceden por el punto B según un PP con tasa de 6 vehículos por minuto. Queremos estudiar cómo se producen las salidas de la autovía.Definición 3.3  Sean \\(\\{N_t; t \\geq 0\\}\\) y \\(\\{M_t; t \\geq 0\\}\\) dos PP independientes con tasas \\(\\lambda_1\\) y \\(\\lambda_2\\) respectivamente. Entonces el proceso \\(\\{Y_t = N_t + M_t, t \\geq 0\\}\\) es un PP con tasa \\(\\lambda_1 + \\lambda_2\\), que se obtiene de la superposición de los dos PP.La solución al Ejemplo 3.3 para el proceso de salidas de la autovía viene dada por la superposición de los dos procesos de entradas, \\(C=+B\\), de modo que responderá un PP de tasa \\(14=8+6\\).","code":""},{"path":"poissonprocess.html","id":"adelgazamiento_pp","chapter":"Unidad 3 Proceso de Poisson","heading":"3.2.2 Adelgazamiento con mixtura","text":"Ejemplo 3.4  Consideramos el tráfico que llega una bifurcación, que sigue un PP con una tasa de 2 coches por minuto. Además, hay un 30% de posibilidades de que los coches giren la izquierda y un 70% de que giren la derecha. Queremos estudiar el proceso que describe el número de coches que giran la izquierda y de los que giran la derecha.Definición 3.4  Sea \\(\\{N_t; t \\geq 0\\}\\) un PP con tasa \\(\\lambda\\) y sea \\(\\{X_1,X_2,...\\}\\) una secuencia de variables aleatorias iid Bernoulli \\(Ber(p)\\), independientes del proceso de Poisson. Sea \\(M = \\{M_t ;t \\geq 0 \\}\\) un nuevo proceso que registra las llegadas de \\(\\{N_t; t \\geq 0\\}\\) con probabilidad \\(p\\), esto es, si \\(X_n=1\\) la llegada n-ésima se registra, y si \\(X_n=0\\) se registra. Entonces el proceso \\(\\{M_t; t \\geq 0\\}\\) resultante, que supone un “adelgazamiento” o encogimiento del proceso original \\(N_t\\), es un PP con tasa \\(\\lambda p\\).Aplicando este resultado al Ejemplo 3.4, y suponiendo que todos los coches actúan de forma independiente, el flujo de giros por la bifurcación de la izquierda forma un PP con una tasa de \\(0.6=0.3\\times 2\\) por minuto, y el flujo de giros por la bifurcación de la derecha forma un PP con una tasa de \\(1.4=0.7\\times 2\\) coches por minuto.","code":""},{"path":"poissonprocess.html","id":"composicion_pp","chapter":"Unidad 3 Proceso de Poisson","heading":"3.2.3 Composición","text":"En un PP los eventos o llegadas suceden de uno en uno. En otras ocasiones, las llegadas o eventos se producen por lotes y los tamaños de los lotes forman una secuencia de variables aleatorias positivas independientes e idénticamente distribuidas. Un ejemplo lo tenemos en la llegada de clientes un restaurante, que se realiza normalmente en grupos de tamaño variable. Si definimos por \\(N_t\\) el número total de llegadas en el periodo \\((0,t]\\), este se puede modelizar como un PP, pero sí como un “PP compuesto.”Ejemplo 3.5  Consideramos la llegada de pasajeros una estación de tren. Los pasajeros llegan la estación de tren en coche. Los coches llegan la estación según un PP de media 5 coches por hora, \\(N_t \\sim Po(5)\\), donde \\(N_t\\) representa el número de coches que han llegado en \\((0,t]\\).Por otro lado, en cada coche pueden llegar 1, 2 o hasta 3 pasajeros. El número de pasajeros que llegan en el n-ésimo coche se denota con la v.. \\(X_n\\), donde \\(P(X_n = 1) = 0.5\\), \\(P(X_n = 2) = 0.3\\), y \\(P(X_n = 3) = 0.2\\) para cualquier \\(n>0\\).Estamos interesados en saber cuántos pasajeros en total llegan la estación en coche.Definición 3.5  Sea \\(\\{N_t; t \\geq 0\\}\\) un PP de tasa \\(\\lambda\\), que representa el proceso de llegada por lotes un sistema, y sea \\(\\{X_1, X_2,...\\}\\) una secuencia de variables aleatorias ..d., y también independientes de \\(N_t\\), tales que \\(X_n\\) representa el tamaño del lote que llega en n-ésimo lugar. El proceso \\(\\{Y_t; t \\geq 0\\}\\) que acumula el número total de llegadas en \\((0,t]\\) y viene definido por la suma de las llegadas en los \\(N_t\\) lotes que han llegado en dicho periodo, esto es,se denomina Proceso de Poisson compuesto (PPC).Si las v.. \\(\\{X_i, =1,...,N_t\\}\\) independientes de \\(N_t\\) se distribuyen iid con media \\(\\mu=E(X_i)\\) y varianza \\(\\sigma^2=Var(X_i)\\), entonces la esperanza y varianza del número total de llegadas/eventos para cada valor de \\(t \\geq 0\\) se obtiene como:\\[\\begin{eqnarray*}\nE(Y_t) &=& \\mu \\lambda t \\\\\nV(Y_t) &=& (\\sigma^2+\\mu^2) \\lambda t\n\\end{eqnarray*}\\]Nótese que \\(\\sigma^2+\\mu^2=E(X_i^2)\\) es el momento de orden 2 para la v.. \\(X_i\\).La respuesta la cuestión planteada en el Ejemplo 3.5 se obtiene al plantear que el número total de pasajeros que llegan la estación, denotado por \\(\\{Y_t; t > 0 \\}\\), será un PP compuesto, definido por: \\[Y_t=\\sum_{=1}^{N_t} X_i.\\]Calculemos ahora el número esperado de pasajeros (y su error) que llegarán la estación en un periodo de 8 horas. Para ello habremos de calcular en primer lugar la media y varianza del número de viajeros por coche (tamaño del lote):Así, el número medio de pasajeros por coche será 1.8 y 4 su momento de orden 2. El número (total) esperado de pasajeros en 8 horas lo calcularemos multiplicando por la tasa de llegadas de coches, \\(\\lambda\\):Por lo tanto, esperamos que lleguen la estación en 8 horas alrededor de 72 pasajeros, con una desviación típica de 12.65.","code":"\n# Para el número de pasajeros por coche\n# sucesos posibles\nx=c(1,2,3)\n# probabilidades asociadas\np=c(0.5,0.2,0.3)\n\n# valor esperado\nmu=as.numeric(p%*%x);mu## [1] 1.8\n# momento de orden 2\nm2=as.numeric(p%*%(x^2));m2## [1] 4\nlambda=5\nt=8\n# valor esperado\ney=lambda*mu*t\n# varianza\nvy=m2*lambda*t\ncat(\"E(Y_8)=\",ey,\", V(Y_8)=\",vy)## E(Y_8)= 72 , V(Y_8)= 160"},{"path":"poissonprocess.html","id":"pp_noestacionarios","chapter":"Unidad 3 Proceso de Poisson","heading":"3.2.4 PP no estacionarios","text":"Muchos procesos físicos que primera vista parecen candidatos ser modelados como un proceso de Poisson, fallan debido la suposición de estacionariedad. Por ejemplo, consideremos el análisis de tráfico en el que estamos interesados en modelar los tiempos de llegada de los coches una intersección. En la mayoría de los lugares es poco probable que la tasa media de llegada de coches las 2p.m. sea la misma que las 2a.m., lo que significa que el proceso es estacionario y, por lo tanto, el supuesto de estacionariedad exigido los procesos de PP se cumple.Definición 3.6  Sea \\(\\{N_t; t \\geq 0\\}\\) un proceso estocástico de parámetro contínuo con \\(N_0 = 0\\). Si asumimos que existe un función continua \\(m()\\) definida con la integral de la tasa del proceso \\(\\lambda()\\),\\[m(t) = \\int_0^t \\lambda(s)ds, \\quad \\text{ para } t \\geq 0\\]entonces el proceso \\(N_t\\) se dice que es un PP estacionario si:\\(P(N_t = k) = e^{-m(t)}(m(t)^k)/k!\\) para \\(k, t \\geq 0\\), es decir, \\(N_t \\sim Po(m(t))\\).El evento \\(\\{N_{s+u} - N_s = \\}\\) es independiente del evento \\(\\{N_t = j\\}\\) si \\(t<s\\).Estos procesos se denominan también PP homogéneos.Ejemplo 3.6  Un banco ha decidido aumentar la capacidad de su ventanilla, y desea modelar dicho proceso. Un primer paso en la modelización de la ventanilla es analizar el proceso de llegadas de clientes. Las ventanillas abren las 7:30 de la mañana durante los días laborables. Se ha determinado que el proceso de llegadas es un PP estacionario en el que la tasa media de llegadas aumenta lentamente de forma lineal de 10 clientes por hora 12 durante los primeros 60 minutos.Tenemos pues, una tasa de llegadas que varía de modo continuo con \\(t\\) (horas) entre las 7:30 y las 8:30 según la recta:\\[\\lambda(t) = 10 + 2t, \\qquad t \\[0,1]\\]La integral de la tasa del proceso \\(\\lambda(t)\\) es:\\[m(t) = \\int_0^t (10+2s)ds = 10t + t^2, \\quad \\text{ para } t \\leq 1.\\]De esta forma el número esperado de llegadas al banco desde las 8.00 las 8.30 (dado que abre las 7:30) viene dado por:\\[E(N_1 - N_{0.5}) = m(1) - m(0.5), \\quad \\text{ pues } N_1 - N_{0.5} \\sim Po(m(1) - m(0.5))\\]y es de 5.75.","code":"\nm=function(t){10*t+t^2}\nm(1)-m(0.5)## [1] 5.75"},{"path":"poissonprocess.html","id":"simulación","chapter":"Unidad 3 Proceso de Poisson","heading":"3.3 Simulación","text":"Para simular procesos de Poisson vamos utilizar la propiedad que relaciona el número de llegadas con el tiempo entre llegadas consecutivas en la Definición 3.2. Planteemos el algoritmo de simulaciónAlgoritmo de simulación de un Proceso de Poisson de tasa \\(\\lambda\\)Fijar condiciones de simulación (número de eventos o tiempo máximo de simulación).Simular tiempos entre eventos consecutivos \\(t \\sim Exp(\\lambda)\\).Para cada tiempo \\(t\\) acumular el tiempo total transcurrido.Para cada tiempo \\(t\\) acumular el número de eventosDevolver el número de eventos, los tiempos entre eventos y el tiempo total transcurrido con cada evento.Y programamos continuación una función genérica que nos permitirá simular un proceso de Poisson en función de un número prefijado de eventos o llegadas o de un tiempo máximo de duración.Ejemplo 3.7  Consideremos la situación del hospital planteada en el Ejemplo 3.2, donde el número de operaciones que se realizan en un quirófano es un \\(PP(\\lambda)\\), con tasa de intervenciones por día \\(\\lambda=24\\). Queremos estimar por simulación las cuestiones que se proponían en aquel ejemplo:Número esperado de operaciones durante 8 horas.Probabilidad de que haya intervenciones en un periodo de 1 hora.Probabilidad de que haya 3 operaciones entre las 8am y 12pm y 4 entre las 12pm y 5pm.Simulamos una vez el funcionamiento del quirófano controlando el número de operaciones realizar o el tiempo de funcionamientoY continuación calculamos las cantidades solicitadas.Número esperado de operaciones durante 8 horas.Para calcular el número esperado de operaciones que se realizan durante 8 horas tendremos que simular el proceso durante 8 horas varias veces (nsim), y calcular (y guardar) en cada simulación, el número de operaciones que se realizan. El número esperado de operaciones lo obtendremos con el promedio de estas cantidades, y con ellas también una estimación del error.Probabilidad de que haya intervenciones en un periodo de 1 hora.Simularemos nsim veces el proceso durante 1 hora y guardamos el número de operaciones realizadas. Calculamos la probabilidad con el conteo de casos favorables dados por las simulaciones en las que se produce ninguna operación.Probabilidad de que haya 3 operaciones entre las 8am y 12pm y 4 entre las 12pm y 5pm.Simulamos el proceso empezando las 8am y acabando las 5pm, esto es, durante un total de 9 horas. Contabilizamos cuántas operaciones hay en las 4 primeras horas (franja 1) y cuántas en las 5 siguientes (franja 2). Contamos los casos favorables al suceso que se plantea.La simulación para extensiones del PP se deriva de las definiciones dadas en la Sección Extensiones.","code":"\nsimula.pp=function(lambda,neventos=NULL,tmax=NULL){\n  # se lanza la simulación hasta conseguir neventos o hasta un instante tmax\n  # mensaje de error si no se introduce la regla de parada\n  if(is.null(tmax) & is.null(neventos)){\n    return(cat(\"Introduce neventos o tmax\"))\n  }\n  # si no se introduce tmax, la regla de parada es neventos\n  else if(is.null(tmax)){\n    # simulación de los tiempos entre eventos sucesivos\n    t=rexp(neventos,lambda)\n  }\n  # si no se introduce neventos, la regla de parada es tmax\n  else if(is.null(neventos)){\n    t=c()\n    tt=0\n    i=1\n    t[1]=rexp(1,lambda)\n    # si la primera llegada se produce después de tmax, contabilizamos 0 eventos\n    if(t[1]>tmax)\n      return(data.frame(eventos=0,t=0,ttotal=0))\n    # en otro caso, continuamos hasta llegar a tmax\n    else{\n    while(tt<=tmax){\n      i=i+1\n      t[i]=rexp(1,lambda)\n      tt=tt+t[i]\n        }\n    # se seleccionan sólo los eventos que se produjeron antes de tmax\n    t=t[cumsum(t)<=tmax]\n  }}\nreturn(data.frame(eventos=1:length(t),t,ttotal=cumsum(t)))\n}\nsimulacion=simula.pp(lambda=24,neventos=200)\nhead(simulacion)##   eventos           t      ttotal\n## 1       1 0.008396741 0.008396741\n## 2       2 0.068498412 0.076895153\n## 3       3 0.215637900 0.292533053\n## 4       4 0.035509007 0.328042059\n## 5       5 0.019406832 0.347448892\n## 6       6 0.022710126 0.370159018\nsimulacion=simula.pp(lambda=24,tmax=2)\nhead(simulacion)##   eventos           t     ttotal\n## 1       1 0.058025341 0.05802534\n## 2       2 0.001355536 0.05938088\n## 3       3 0.020513519 0.07989440\n## 4       4 0.001007941 0.08090234\n## 5       5 0.047494149 0.12839649\n## 6       6 0.039658236 0.16805472\nnsim=5000\ntmax=8/24\nlambda=24\nset.seed(123)\nnoperaciones=c()\n# simulamos nsim veces el proceso durante 8 horas\nfor(i in 1:nsim){\nsimulacion=simula.pp(lambda=lambda,tmax=tmax);simulacion\n# número de operaciones realizadas\nnoperaciones[i]=max(simulacion$eventos)\n}\nm=mean(noperaciones)\nerror=sd(noperaciones)/sqrt(nsim)\n# calculamos la media y el error\ncat(\"E(operaciones en 8 horas)=\",round(m,2), \", Error=\",round(error,2))## E(operaciones en 8 horas)= 7.97 , Error= 0.04\ncat(\"\\n IC(operaciones en 8 horas)=[\",round(m-qnorm(0.975)*error,2),\n    \",\",round(m+qnorm(0.975)*error,2),\"]\")## \n##  IC(operaciones en 8 horas)=[ 7.89 , 8.04 ]\nnsim=5000\ntmax=1/24\nlambda=24\nset.seed(123)\nnoperaciones=c()\n# simulamos nsim veces el proceso durante tmax horas\nfor(i in 1:nsim){\nsimulacion=simula.pp(lambda=lambda,tmax=tmax)\n# no se ha realizado ninguna operación\nnoperaciones[i]=max(simulacion$eventos)\n}\nfavorables=(noperaciones==0)*1\np=mean(favorables)\nerror=sqrt(sum((favorables-p)^2)/(nsim^2))\n# calculamos la media y el error\ncat(\"Pr(sin operaciones en 1 hora)=\",p, \", Error=\",error)## Pr(sin operaciones en 1 hora)= 0.3688 , Error= 0.006823292\ncat(\"\\n IC(Pr(sin operaciones en 1 hora))=[\",round(p-qnorm(0.975)*error,3), \",\",round(p+qnorm(0.975)*error,3),\"]\")## \n##  IC(Pr(sin operaciones en 1 hora))=[ 0.355 , 0.382 ]\nnsim=5000\ntmax=9/24\nlambda=24\nset.seed(123)\n# vectores para guardar el número de operaciones en cada franja\nnoper1=noper2=c()\n# simulamos nsim veces el proceso durante tmax horas\nfor(i in 1:nsim){\nsimulacion=simula.pp(lambda=lambda,tmax=tmax)\n# contamos el número de operaciones en cada franja\nnoper1[i]=sum(simulacion$ttotal<=4/24)\nnoper2[i]=sum(simulacion$ttotal>4/24)\n}\n# identificamos las cadenas en las que se dan simultaneamente ambos sucesos\nfavorables=((noper1==3)&(noper2==4))*1\np=mean(favorables)\nerror=sqrt(sum((favorables-p)^2)/(nsim^2))\n# calculamos la media y el error\ncat(\"Pr(suceso)=\",p, \", Error=\",error)## Pr(suceso)= 0.032 , Error= 0.002489016\ncat(\"\\n IC(Pr(ssuceso))=[\",round(p-qnorm(0.975)*error,3), \",\",round(p+qnorm(0.975)*error,3),\"]\")## \n##  IC(Pr(ssuceso))=[ 0.027 , 0.037 ]"},{"path":"poissonprocess.html","id":"simulación-con-simmer","chapter":"Unidad 3 Proceso de Poisson","heading":"3.3.1 Simulación con simmer","text":"simmer31 es una librería de R que permite la simulación eventos discretos y que desarrollamos con detalle en la Unidad Simulación DES con simmer.Simular un proceso de Poisson con simmer es bastante sencillo. En primer lugar, contamos muy brevemente la dinámica de simulación del Ejemplo 3.7 con esta librería:Se carga la librería y se define un entorno de simulación con el comando env=simmer()Se define el evento: operación.Se definen las acciones realizan cada uno de los eventos en una trayectoria (quirófano): comenzar la operación.Se generan eventos en función de la distribución para el tiempo entre eventos, y son dirigidas la trayectoria (quirófano).Se corre el sistema durante el tiempo deseado.Si queremos calcular el número esperado de operaciones que se realizan durante 8 horas, simulamos el sistema durante 8 horas, utilizando en lugar del proceso original de número de operaciones en un día, con tasa \\(\\lambda=24\\), el de número de operaciones en una hora, con tasa \\(\\lambda=1\\).Para obtener una estimación de lo que ocurre en un periodo de 8 horas, hemos de simular varias veces ese periodo y conseguir una estimación Monte-Carlo con el número de operaciones efectuadas.Promediamos el número de operaciones que se han producido en cada franja para obtener la estimación Monte-Carlo y su error.Procederíamos de modo similar para resolver las otras cuestiones. Inténtalo tú mismo/.","code":"\n# Función para simular un PP(lambda) hasta t con simmer\nlibrary(tidyverse)\nlibrary(simmer)\n\nsimula.pp.simmer=function(t,lambda){\nenv=simmer()\n\n# Cada evento es una entrada a quirófano\nquirofano <- trajectory() %>%\n  log_(\"Comienza la operación\")\n \nenv %>%\n  # los tiempos entre llegadas se simulan exponenciales\n  add_generator(\"operacion\", quirofano, function() rexp(1,lambda)) %>%\n  run(until=t)\n}\nlambda=1\ntmax=8\n#set.seed(1477)\noperaciones = simula.pp.simmer(tmax,lambda)## 0.162028: operacion0: Comienza la operación\n## 2.26948: operacion1: Comienza la operación\n## 2.53613: operacion2: Comienza la operación\n## 3.82422: operacion3: Comienza la operación\n## 5.772: operacion4: Comienza la operación\n## 6.02077: operacion5: Comienza la operación\n## 6.25954: operacion6: Comienza la operación\n## 6.63566: operacion7: Comienza la operación\n## 7.28285: operacion8: Comienza la operación\n## 7.56707: operacion9: Comienza la operación\n## 7.94946: operacion10: Comienza la operación\n# y obtenemos el número de simulaciones en esa franja con\nget_n_generated(operaciones,\"operacion\")-1## [1] 11\nget_mon_arrivals(operaciones)##           name start_time  end_time activity_time finished replication\n## 1   operacion0  0.1620284 0.1620284             0     TRUE           1\n## 2   operacion1  2.2694828 2.2694828             0     TRUE           1\n## 3   operacion2  2.5361340 2.5361340             0     TRUE           1\n## 4   operacion3  3.8242185 3.8242185             0     TRUE           1\n## 5   operacion4  5.7720047 5.7720047             0     TRUE           1\n## 6   operacion5  6.0207667 6.0207667             0     TRUE           1\n## 7   operacion6  6.2595419 6.2595419             0     TRUE           1\n## 8   operacion7  6.6356628 6.6356628             0     TRUE           1\n## 9   operacion8  7.2828499 7.2828499             0     TRUE           1\n## 10  operacion9  7.5670702 7.5670702             0     TRUE           1\n## 11 operacion10  7.9494570 7.9494570             0     TRUE           1lambda=1\ntmax=8\nnsim=500\n# guardamos en un vector el número de operaciones en cada franja simulada\nfranja=c()\nfor(i in 1:nsim)\nfranja[i] = get_n_generated(simula.pp.simmer(tmax,lambda),\"operacion\")\nm=mean(franja)\nerror=sd(franja)/sqrt(nsim)\nic.low=m-qnorm(0.975)*error\nic.up=m+qnorm(0.975)*error\ncat(\"E=\",m,\", error=\",error,\", IC95%=(\",ic.low,\",\",ic.up,\")\")## E= 8.208 , error= 0.1240655 , IC95%=( 7.964836 , 8.451164 )"},{"path":"poissonprocess.html","id":"ejer-u3","chapter":"Unidad 3 Proceso de Poisson","heading":"3.4 Ejercicios","text":"","code":""},{"path":"poissonprocess.html","id":"básicos-2","chapter":"Unidad 3 Proceso de Poisson","heading":"3.4.1 Básicos","text":"Ejercicio B3.1. En una tienda de animales entran clientes razón de 8 por hora.¿Cuál es la probabilidad de que lleguen al menos 4 clientes durante los próximos 30 minutos?¿Cuál es la probabilidad de que en las 8 horas en que permanece abierta la tienda entren al menos 70 clientes?Ejercicio B3.2. En una estación de bomberos el tiempo entre llamadas por avisos sigue una distribución exponencial con una media de 32 minutos.Acaba de llegar una llamada. ¿Cuál es la probabilidad de que la próxima llamada se produzca en menos de media hora?¿Cuál es la probabilidad de que se produzcan exactamente dos llamadas durante la próxima hora?Ejercicio B3.3. Una empresa que controla la seguridad de una ciudad ha observado que los intentos de entrar en domicilios ajenos para robar (para los que tienen contratada la seguridad con ellos) ocurren con un PP de tasa 2.2 por día. El sistema opera 24 horas al día.¿Cuál es la probabilidad de que mañana se produzcan 4 intentos de robo?¿Cuál es la probabilidad de que se produzca ningún intento de robo durante la noche (entre las 12 de la noche y las 8 de la mañana)?Si ahora es medianoche y el último intento de robo se produjo las 10:30pm, ¿cuál es la probabilidad de que el siguiente intento ocurra antes de las 5:30am?Ejercicio B3.4. En el caso de la empresa de seguridad del Ejercicio B3.3 resulta que además se sabe que el 10% de los intentos de entrar en la casa resultan en robo efectivo.¿Cuál es la probabilidad de que se produzcan 3 intentos de robo que acaben en robo?Ahora mismo son las 6am del lunes. El último intento de robo que acabó en robo ocurrió medianoche. ¿Cuál es la probabilidad de que se hayan producido robos durante dicho periodo?Ejercicio B3.5. En una máquina hay dos tipos comunes de fallos críticos: en la componente electrónica o en la B. Si cualquiera de estas componentes falla, la máquina se para. La componente falla conforme un PP con tasa 1.1 fallos por turno (la fábrica trabaja 24/7 en turnos de 8 horas). La componente B falla según un PP con tasa 1.2 fallos por día.¿Cuál es la probabiliadd de que se produzcan exactamente 5 fallos de la máquina durante un día?¿Cuál es la probabilidad de que la máquina se pare más de una vez durante el siguiente turno?Ahora mismo es mediodía y el último fallo se produjo hace 4 horas. ¿Cuál es la probabilidad de que el próximo parón se produzca antes de las 6pm?Simula los parones de la máquina, mostrando qué componente falla en cada ocasión y asumiendo que el tiempo de reparación es despreciable y la máquina continua trabajando inmediatamente. Estima la probabilidad de que la máquina se pare más de 1 vez durante un turno.Simula los parones de la máquina, mostrando qué componente falla en cada ocasión y asumiendo que el tiempo de reparación de cada componente se distribuye uniforme entre 5 y 60 minutos. Estima la probabilidad de que la máquina se pare más de 1 vez durante un turno.Ejercicio B3.6. Los clientes entran en una tienda según un PP con tasa 5 clientes por hora. La probabilidad de que un cliente se vaya sin comprar es 0.20. Si el cliente compra, lo que se gasta se puede aproximar con una distribución Gamma con parámetro de escala 100€ y de forma 2.5.Da la media y la desviación típica del dinero que consigue la tienda por las compras de los clientes que entran en una hora.Calcula lo mismo para una franja de 10 horas.Estima la probabilidad de que la máquina se pare más de 1 vez durante un turno.Ejercicio B3.7. En el caso de la empresa de seguridad del Ejercicio B3.3 resulta que se ha estudiado mejor y el número de intentos de robo sigue un PP cuya tasa depende de la franja horaria. Entre las 6am y las 8am la tasa es de 0.3, entre las 8pm-medianoche de 0.6, de medianoche las 4am la tasa es 1 y de las 4am las 6am la tasa es 0.3. Contesta las mismas preguntas que se formularon en el Ejercicio B3.3.Ejercicio B3.8. Se envía una nave espacial Júpiter para tomar fotos de las lunas y enviarlas la Tierra. Hay tres sistemas críticos involucrados: la cámara, la batería y la antena de transmisión. Estos tres sistemas fallan independientemente entre sí. La vida esperada de la batería es de 6 años, la de la cámera es 12 años y la de la antena de 10 años. Asume que todos los tiempos de vida son v.. exponenciales La nave alcanzará Júpiter después de 3 años desde que arranca la misión. ¿Cuál es la probabilidad de que la misión resulte exitosa?Ejercicio B3.9. En una maternidad los partos simples se dan con probabilidad, 0.9, los de mellizos o gemelos con probabilidad 0.08 y los de trillizos con probabilidad 0.02. El número de partos sigue un PP con tasa 10 por día.Calcula el número esperado de nacimientos lo largo de un día.¿Cuál es la probabilidad de que se dé al menos un parto de gemelos o mellizos?Suponiendo que durante un día han nacido unos gemelos, ¿cuál es el número de partos que se han dado?Ejercicio B3.10. El número de coches que visitan un parque nacional sigue un PP con tasa 15 por hora. Cada coche tiene k ocupantes con probabilidad \\(p_k\\), donde\\[p_1=0.2, \\quad, p_2=0.3, \\quad p_3=0.3, \\quad p_4=0.1, \\quad p_5=0.5, \\quad p_6=0.05.\\]Calcula la media y la varianza del número de visitantes del parque durante un periodo de 10 horas.Si el coste de la entrada de cada coche es de 4€, con un recargo de 1€ por ocupante, calcula la media y la varianza del dinero que consigue el parque durante 10 horas.","code":""},{"path":"poissonprocess.html","id":"avanzados-2","chapter":"Unidad 3 Proceso de Poisson","heading":"3.4.2 Avanzados","text":"Ejercicio A3.1 Programa un algoritmo de simulación para la superposición de PP definida en la Sección Superposición y resuelve con simulación el Ejemplo 3.3.Ejercicio A3.2 Programa un algoritmo de simulación para la mixtura de PP definida en la Sección Adelgazamiento con mixtura y resuelve con simulación el Ejemplo 3.4.Ejercicio A3.3 Programa un algoritmo de simulación para la composición de PP definida en la Sección Composición y resuelve con simulación el Ejemplo 3.5.Ejercicio A3.4 Programa un algoritmo de simulación para PP estacionario, definido en la Sección PP estacionarios y resuelve con simulación el Ejemplo 3.6.Ejercicio A3.5 Un servicio de venta telefónica recibe llamadas conforme un PP. Aproxima el resultado teórico tanto como puedas y después simula el proceso y calcula el volumen esperado (en términos de euros) de las ventas que se realizan durante un intervalo de 50 minutos desde las 12 del mediodía hasta las 12:50pm bajo las diversas condiciones que se proponen continuación, asumiendo que todos los días son probabilísticamente iguales.El PP de llegadas es estacionario con tasa de 50 llamadas por hora. Además, sólo la mitad de las llamadas acaban en compras, el 30% de las llamadas acaban con una compra de 100€ y el 20% con compras de 200€.Como la mayoría de la gente tiende llamar en su descanso para almorzar, la tasa de llegadas se incrementa lentamente partir de mediodía; entre las 12 y las 12:05 la tasa es de 40 llamadas, entre las 12:05pm y las 12:10pm, la tasa es de 45 llamadas por hora, y desde las 12:10pm hasta las 12:50pm la tasa es de 50 llamadas. Las probabilidades y compras son similares las del apartado 1.La tasa de llamadas se aproxima con una función lineal que da 40 llamadas por hora al mediodía y 50 las 12:15pm. La tasa es constante durante los siguientes 30 minutos. Las probabilidades y compras sin similares las del apartado 1.","code":""},{"path":"CMTC.html","id":"CMTC","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","text":"En esta unidad, consideramos un sistema estocástico que se observa continuamente lo largo del tiempo, siendo \\(X_t\\) el estado en el momento \\(t\\), con \\(t \\geq 0\\). Siguiendo la definición de las CMTD, continuación definimos las cadenas de Markov de tiempo continuo (CMTC).Definición 4.1  Un proceso estocástico \\(\\{X_t; t \\geq 0\\}\\) con espacio de estados \\(S\\) es una cadena de Markov de tiempo continuo, CMTC, si para todo \\(\\) y \\(j\\) en \\(S\\), y \\(t, s \\geq 0\\), cumple la propiedad de Markov:\\[P(X_{s+t} = j \\mid X_s = , X_u, 0 \\leq u \\leq s) = P(X_{s+t} = j \\mid X_s = ).\\]La CMTC \\(\\{X_t; t \\geq 0\\}\\) se denomina homogénea si el cambio entre dos instantes cualesquiera depende exclusivamente del tiempo transcurrido, esto es para cualquier \\(t, s \\geq 0\\),\\[P(X_{s+t} = j \\mid X_s = ) = P(X_t = j \\mid X_0 = ).\\]En toda esta unidad asumimos que las CMTC con las que trabajamos son homogéneas y tienen espacio de estados finito \\(S=\\{1, 2,,...,N\\}\\) de forma que podemos definir la probabilidad de pasar del estado \\(\\) al estado \\(j\\) en un periodo de amplitud \\(t, (0,t],\\) como:\\[p_{ij}(t) = P(X_t = j \\mid X_0 = ), \\quad 1 \\leq , j \\leq N.\\]La matriz de probabilidad de transición \\(P(t)\\) de una CMTC \\(\\{X_t; t \\geq 0\\}\\) viene dada por las distribuciones de probabilidad condicionadas (por filas) de pasar de un estado \\(\\) un estado \\(j\\) en un periodo de tiempo de amplitud \\(t\\):\\[P(t) = \n\\begin{pmatrix}\np_{11}(t) & p_{12}(t) & ... & p_{1N}(t)\\\\\np_{21}(t) & p_{22}(t) & ... & p_{2N}(t)\\\\\n... & ... & ... & ...\\\\\np_{N1}(t) & p_{N2}(t) & ... & p_{NN}(t)\n\\end{pmatrix}\\]Dicha matriz de transición verifica que:Todos sus elementos son probabilidades condicionadas \\(\\{p_{ij}(t); j \\S\\}\\)\\[1 \\geq p_{ij}(t) \\geq 0, \\quad  1 \\leq , j \\leq N; t \\geq 0\\]La suma de las probabilidades en cada fila, esto es, de acceder cualquiera de los estados partir de un estado \\(\\) es igual 1.\\[\\sum_{j=1}^N p_{ij}(t) = 1, \\quad  1 \\leq , j \\leq N; t \\geq 0\\]Ecuaciones de Chapman-Kolmogorov\\[p_{ij}(s+t) =  \\sum_{k=1}^N p_{ik}(s)p_{kj}(t) =  \\sum_{k=1}^N p_{ik}(t)p_{kj}(s)   , \\quad  1 \\leq , j \\leq N; t \\geq 0\\]La dificultad principal con \\(P(t)\\) es que resulta díficil de obtener de forma inmediata para la mayoría de las CMTC, al contrario de lo que ocurría con las CMTD. Necesitamos un método simple que nos permita describir de forma rápida el comportamiento del proceso. continuación, sentamos las bases para el estudio de las CMTC partir de los tiempos de permanencia en cada uno de los estados del proceso. Dado que la única distribución que verifica la propiedad de pérdida de memoria es la exponencial, la utilizaremos como base para la construcción de una CMTC.","code":""},{"path":"CMTC.html","id":"CMTCA","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.1 Evolución del proceso","text":"Sea \\(X_t\\) el estado de un sistema en el instante temporal \\(t\\). Supongamos que el espacio de estados del proceso estocástico \\(\\{X_t; t \\geq 0\\}\\) es \\(S=\\{1, 2,...,N\\}\\). La evolución aleatoria del sistema se produce de la siguiente manera:Supongamos que el sistema comienza en el estado \\(\\) y permanece allí durante un tiempo \\(Exp(r_i)\\) que denominamos tiempo de permanencia en el estado \\(\\), con \\(r_i\\) la tasa media de permanencia; recordemos que en la distribución exponencial las tasas medias son el recíproco de los tiempos medios.Supongamos que el sistema comienza en el estado \\(\\) y permanece allí durante un tiempo \\(Exp(r_i)\\) que denominamos tiempo de permanencia en el estado \\(\\), con \\(r_i\\) la tasa media de permanencia; recordemos que en la distribución exponencial las tasas medias son el recíproco de los tiempos medios.Al final del tiempo de permanencia en el estado \\(\\), el sistema realiza una transición repentina al estado \\(j\\) con probabilidad \\(p_{ij}\\), independientemente del tiempo que el sistema haya permanecido en el estado \\(\\). Una vez en el estado \\(j\\), permanece allí durante un tiempo \\(Exp(r_j)\\).Al final del tiempo de permanencia en el estado \\(\\), el sistema realiza una transición repentina al estado \\(j\\) con probabilidad \\(p_{ij}\\), independientemente del tiempo que el sistema haya permanecido en el estado \\(\\). Una vez en el estado \\(j\\), permanece allí durante un tiempo \\(Exp(r_j)\\).continuación pasa un nuevo estado \\(k\\) con una probabilidad \\(p_{jk}\\), independientemente de la historia del sistema hasta el momento, y repite este comportamiento hasta que finaliza el tiempo de observación del proceso.continuación pasa un nuevo estado \\(k\\) con una probabilidad \\(p_{jk}\\), independientemente de la historia del sistema hasta el momento, y repite este comportamiento hasta que finaliza el tiempo de observación del proceso.Conviene hacer tres observaciones con respecto al funcionamiento del sistema:En primer lugar, las probabilidades de salto \\(p_{ij}\\) deben deben confundirse con las probabilidades de transición \\(p_{ij}(t)\\). En este caso, \\(p_{ij}\\) actúa como la probabilidad de que el sistema pase al estado \\(j\\) cuando sale del estado \\(\\).En segundo lugar, \\(p_{ii} = 0\\), dado que, por definición, el tiempo de permanencia en el estado \\(\\) es el tiempo que el sistema pasa en el estado \\(\\) hasta que sale de él; por lo tanto, es posible una transición de \\(\\) \\(\\).En tercer lugar, en caso de que el estado \\(\\) sea absorbente, es decir que el sistema permanezca en ese estado para siempre una vez que llegue él, fijamos \\(r_i = 0\\).Con estas premisas podremos obtener la matriz de probabilidades de salto, \\(P\\), que denotaremos como:\\[P = \n\\begin{pmatrix}\np_{11} & p_{12} & ... & p_{1N}\\\\\np_{21} & p_{22} & ... & p_{2N}\\\\\n... & ... & ... & ...\\\\\np_{N1} & p_{N2} & ... & p_{NN}\n\\end{pmatrix}\\]Teorema 4.1  El proceso estocástico \\(\\{X_t; t \\geq 0\\}\\) con parámetros \\(r_i\\), \\(1 \\leq \\leq N\\), y probabilidades \\(p_{ij}\\), \\(1 \\leq ,j \\leq N\\) descrito anteriormente es una CMTC.continuación presentamos un par de ejemplos.Ejemplo 4.1  Sistema de vida útil de un satélite. Supongamos que la vida útil \\(T\\) de un satélite de gran altitud es una variable aleatoria exponencial de tasa \\(\\mu\\) en meses, \\(Exp(\\mu)\\), de forma que una vez que falla sigue fallando para siempre, ya que es posible repararlo. Consideramos el proceso \\(X_t = 1\\) si el satélite está operativo en el momento \\(t\\), y 0 en caso contrario. En esta situación \\(r_0 = 0\\) (porque si se estropea, se queda estropeado) y \\(r_1 = \\mu\\) (que es el tiempo esperado de vida), pero desconocemos los valores de \\(P\\), aunque podremos obtener la matriz de transición calculando las probabilidades \\(p_{00}(t)\\) y \\(p_{11}(t)\\) que vienen dadas por:\\[p_{00}(t) = P(\\text{satélite está operativo en t} \\mid \\text{satélite está operativo en 0}) = 1\\]\\[\\begin{eqnarray*}\np_{01}(t) &=& P(X_t=1|X_0=0) = 0 \\\\\np_{10}(t) &=& P(X_t=0|X_0=1) = Pr(T \\leq t) = 1- e^{-\\mu t}\\\\\np_{11}(t) &=& P(X_t=1|X_0=1) = Pr(T >t) = e^{-\\mu t}\n\\end{eqnarray*}\\]La matriz de transición viene dada pues por:\\[P(t) = \n\\begin{pmatrix}\n1 & 0\\\\\n1- e^{-\\mu t} & e^{-\\mu t} \n\\end{pmatrix}\\]Ejemplo 4.2  Sistema del viajante. Un vendedor vive en la ciudad y es responsable de las ciudades , B y C. El tiempo que pasa en cada ciudad es aleatorio. Tras un estudio, se ha determinado que la cantidad de tiempo consecutivo que pasa en una ciudad cualquiera sigue una variable aleatoria con distribución exponencial, cuya media de tiempo de estancia depende de la ciudad. En su ciudad natal pasa un tiempo medio de dos semanas, en la ciudad B pasa un tiempo medio de una semana, y en la ciudad C pasa un tiempo medio de una y media. Cuando sale de la ciudad , lanza una moneda para determinar qué ciudad va continuación; cuando sale de la ciudad B o C, lanza dos monedas de manera que hay un 75% de posibilidades de volver y un 25% de posibilidades de ir la otra ciudad. Sea \\(X_t\\) una variable aleatoria que denota la ciudad en la que se encuentra el vendedor en el momento \\(t\\), de forma que toma el valor 0 si está en , el valor 1 si está en B, y 2 si está en C.El proceso \\(\\{X_t; t \\geq 0\\}\\) con espacio de estados \\(\\{0, 1, 2\\}\\) es una CMTC con:tasas de permanecia (en semanas): \\(r_0 = 1/2=0.5, r_1 = 1, r_2 = 1/1.5 =0.67\\) , ymatriz de saltos\\[P = \n\\begin{pmatrix}\n0 & 0.5 & 0.5\\\\\n0.75 & 0 & 0.25\\\\\n0.75 & 0.25 & 0\n\\end{pmatrix}\\]","code":""},{"path":"CMTC.html","id":"CMTCB","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.2 Descripción del proceso","text":"En virtud del teorema 4.1 todas las CMTC con espacios de estado finitos que tienen tiempos de permanencia nulos en cada estado pueden ser descritos través de las tasas de permanencia y la matriz de saltos. En este punto detallamos este análisis e introducimos todos los conceptos necesarios para el análisis del proceso.La tasa de transición de \\(\\) \\(j\\) se define como el producto de la tasa de permanencia en el estado \\(\\), \\(r_i\\), por la probabilidad de salto al estado \\(j\\), \\(p_{ij}\\)\\[\\begin{equation}\nr_{ij} = r_i p_{ij}\n\\end{equation}\\]De forma análoga las CMTD, una CMTC también puede representarse gráficamente mediante un grafo dirigido cuyos nodos (o vértices) indican cada uno de los estados del proceso, y surge un arco dirigido del nodo \\(\\) al nodo \\(j\\) si \\(p_{ij} > 0\\); además junto cada arco se escribe la tasa de transición \\(r_{ij} = r_i p_{ij}\\). Nunca habrá arcos que empiecen y acaben en el mismo nodo porque \\(p_{ii}=0\\). Esta representación gráfica se denomina diagrama de tasas de la CMTC.Podemos entender la dinámica de una CMTC visualizando una partícula que se mueve de nodo en nodo en el diagrama de tasas de la siguiente manera: permanece en el nodo \\(\\) durante cierto periodo de tiempo de duración variable \\(Exp(r_i)\\) y luego elige uno de los arcos de salida del nodo \\(\\) con probabilidades proporcionales las tasas de los arcos, trasladándose al nodo que conecta dicho arco con el nodo origen \\(\\). Este movimiento continúa para siempre. El nodo ocupado por la partícula en el instante \\(t\\) es el estado de la CMTC en el instante \\(t\\).En esta situación resulta posible obtener los valores de \\(r_i\\) y \\(p_{ij}\\) partir de las tasas \\(r_{ij}\\) dado que:\\[\\begin{eqnarray*}\n\\sum_{j=1}^{N} r_{ij} &=& \\sum_{j=1}^{N} r_i p_{ij} = r_i \\sum_{j=1}^{N} p_{ij} = r_i\\\\\np_{ij} &=& \\frac{r_{ij}}{r_i} \\quad \\text{ si } r_i \\neq 0.\n\\end{eqnarray*}\\]Para un mejor manejo de la información, resulta conveniente construir la matriz de tasas de permanencia (o tasas de ocupación) teniendo en cuenta que \\(r_{ii} = 0\\) para cualquier valor de \\(\\), y por tanto la diagonal de la matriz \\(R\\) es siempre cero. Así tenemos que:\\[R = \n\\begin{pmatrix}\n0 & r_{12} & ... & r_{1N}\\\\\nr_{21} & 0 & ... & r_{2N}\\\\\n... & ... & ... & ...\\\\\nr_{N1} & r_{N2} & ... & 0\n\\end{pmatrix}\\]partir de la matriz \\(R\\) se puede obtener la denominada matriz generadora \\(Q\\) de la CMTC, que se define como aquella que tiene por elementos \\(q_{ij}\\), con:\\[q_{ij} = \\begin{cases}\n-r_i, \\quad \\text{ si } = j, \\\\\nr_{ij}, \\quad \\text{ si } \\neq j.\n\\end{cases}\\]de forma que:\\[Q = \n\\begin{pmatrix}\n-r_1 & r_{12} & ... & r_{1N}\\\\\nr_{21} & -r_2 & ... & r_{2N}\\\\\n... & ... & ... & ...\\\\\nr_{N1} & r_{N2} & ... & -r_N\n\\end{pmatrix}\\]Ejemplo 4.3  Continuando con el sistema de vida útil del satélite del ejemplo 4.1, podemos establecer que \\(r_0 = 0\\) y \\(r_1 = \\mu\\), con \\(p_{10} = 1\\) y \\(p_{01}\\) definida, de forma que:\\[R = \n\\begin{pmatrix}\n0 & 0 \\\\\n\\mu & 0\n\\end{pmatrix} \\quad \\text{ y } \\quad Q = \n\\begin{pmatrix}\n0 & 0 \\\\\n\\mu & -\\mu\n\\end{pmatrix}\\]En esta situación el diagrama de tasas se construye con la librería diagram:\nFigura 4.1: Diagrama de tasas para el tiempo de vida del Satélite\nEjemplo 4.4  Continuando con el sistema del viajante descrito en el ejemplo 4.2 ya que conocemos las tasas medias y las probabilidades de salto podemos obtener la matriz \\(R\\) de forma inmediata:de forma que el diagrama de tasas viene dado por (asignamos el valor de la ciudad cada uno de los posibles estados del sistema)\nFigura 4.2: Diagrama de tasas para el proceso del vendedor\nEl diagrama representa el comportamiento de todo el proceso de viajes y estancias del vendedor.Ejemplo 4.5  Sistema vida útil de una máquina. Consideramos un sistema compuesto por una máquina que funciona durante un cantidad de tiempo que viene determianda por una variable aleatoria \\(Exp(\\mu)\\) hasta que falla. Una vez se detecta la avería, la máquina se repara. El tiempo de reparación es una variable aleatoria \\(Exp(\\lambda)\\) y es independiente del pasado. La máquina está como nueva después de la reparación. Sea \\(X(t)\\) el estado de la máquina en tiempo \\(t\\), de forma que toma el valor 1 si está en marcha y 0 si está parada (porque está siendo reparada).En esta situación el tiempo de estancia en el estado 0 es el tiempo de reparación, de forma que \\(r_0 = \\lambda\\), mientras que el tiempo en el estado 1 es el tiempo de funcionamiento con \\(r_1 = \\mu\\). Además las probabiliddes de salto de interés son \\(p_{01} = 1\\) y \\(p_{10} = 1\\), dado que la máquina siempre es reparada y vuelve funcionar, y porque sabemos que la máquina debe estropearse en algún momento.El proceso definido de esta forma \\(\\{X_t; t \\geq 0\\}\\) es una CMTC cuya matriz de tasas y matriz generadora del sistema vienen dadas por:\\[R = \n\\begin{pmatrix}\n0 & \\lambda \\\\\n\\mu & 0\n\\end{pmatrix} \\quad \\text{ y } \\quad Q = \n\\begin{pmatrix}\n-\\lambda & \\lambda \\\\\n\\mu & -\\mu\n\\end{pmatrix}\\]El diagrama del sistema viene dado por:\nFigura 4.3: Diagrama de tasas para el sistema de una máquina\n","code":"\nestados <- c(\"0\", \"1\", \"2\")\nnestados <- length(estados)\n\nP <- matrix(nrow = nestados, ncol = nestados, \n            data = c(0, 0.5, 0.5, 0.75, 0, 0.25, 0.75, 0.25, 0), \n            byrow = 3)\nr <- matrix(nrow = nestados, ncol = nestados, \n            data = rep(c(0.5, 1, 1.5),3))\n\nR <- P*r\nR##       [,1]  [,2] [,3]\n## [1,] 0.000 0.250 0.25\n## [2,] 0.750 0.000 0.25\n## [3,] 1.125 0.375 0.00"},{"path":"CMTC.html","id":"CMTCC","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.3 Análisis preliminar del proceso","text":"Aunque más adelante estudiaremos los aspectos teóricos para el análisis completo de una CMTC, en este punto utilizamos la simulación del sistema para analizar su comportamiento. Nos centramos en las herramientas de simulación estudiadas hasta este punto para más adelante presentar con detalle la librería simmer que nos permite simular procesos y sistemas complejos.Utilizamos los ejemplos 4.2 y 4.5 para mostrar cómo analizar un sistema, dado que el descrito en el ejemplo 4.1 se puede analizar sin más que describir la tasa del tiempo de vida del satélite.","code":""},{"path":"CMTC.html","id":"sistema-de-vida-útil-de-una-máquina","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.3.1 Sistema de vida útil de una máquina","text":"Comenzamos con el ejemplo 4.5, para el que vamos construir un algoritmo con el que simular el sistema hasta cierto instante de tiempo.Algoritmo para el sistema de vida útil de una máquina:Fijar tasas de funcionamiento \\(\\mu\\) y reparación \\(\\lambda\\), así como el tiempo en que el sistema estará funcionando (\\(tfin\\)).Fijar el tiempo de funcionamiento \\(tfun = 0\\), tiempo de reparación \\(trep = 0\\), y tiempo de funcionamiento del sistema \\(tsis = tfun + trep\\).Fijar el número de vistas al estado de funcionamiento \\(nfun = 0\\) y al estado de reparación \\(nrep =0\\).Repetir los pasos siguientes hasta abandonar el sistema:Generar \\(tfun \\sim Exp(\\mu)\\) actualizando \\(tsis\\) y \\(nfun\\).Si \\(tsis > tfin\\), abandonar el sistema.Generar \\(trep \\sim Exp(\\lambda)\\) actualizando \\(tsis\\) y \\(nrep\\).Si \\(tsis > tfin\\), abandonar el sistema.Los valores \\(tfun\\), \\(trep\\), así como las veces que se visitan los estados de funcionamiento y reparación nos permiten describir el funcionamiento del sistema para un tiempo prefijado.Para facilitar el análisis establecemos que todos los tiempos del sistema están en días y que deseamos estudiar el sistema durante un año. Creamos una función que nos permite modificar los valores de la tasa del tiempo de funcionamiento (recíproco de la media de tiempo en funcionamiento ), la tasa de reparación (recíproco de la media del tiempo de reparación) y el tiempo total de funcionamiento del sistema. Almacenamos los resultados de cada paso por el sistema para poder realizar los análisis correspondientes.Supongamos que través de los registros históricos de funcionamiento y reparación de la máquina se sabe que el tiempo medio de funcionamiento es de 60 días (\\(\\mu = 1/60\\)) y el tiempo medio de reparación es de cuatro días (\\(\\lambda = 1/4\\)). Además se está interesado en estudiar el funcionamiento del sistema para el próximo año (365 días). Queremos pues, estimar:Proporción del tiempo que la máquina está funcionando y en reparación.Número de ocasiones en que la máquina debe ser reparada.Si el beneficio neto es de 100 euros por cada día que la máquina está funcionando y una pérdida de 1500 euros por cada día que está en reparación ¿cuál es el beneficio esperado para el próximo año?Obtenemos la simulación del sistema:Podemos ver que el número de ciclos en que la máquina esta en fucionamiento es 6 mientras que el número de veces que ha necesitado reparación son 5.Calculamos ahora los tiempos totales de funcionamiento y reparación:Por tanto, la proporción de tiempo que la máquina está en funcionamiento es 0.99, y el beneficio estimado para el próximo año viene dado por:","code":"\nTSIM_one_machine <- function(tasafun, tasarep, tfin)\n{\n  # Parámetros de la función\n  # =========================\n  # tasafun: tasa de funcionamiento\n  # tasarep: tasa de reparación\n  # tfin: tiempo de funcionamiento del sistema\n  \n  # inicialización de parámetros del sistema \n  tfun = trep = nfun = nrep = tsis = vector()\n  # estado inicial del sistema\n  i <- 1\n  tfun[i] = trep [i] = nfun[i] = nrep[i] = 0\n  tsis[i] <- tfun[i] + trep[i]\n  \n  # Fijamos semilla\n  set.seed(123)\n  # Bucle de simulación\n  while(tsis[i] <= tfin)\n  {\n    i<- i + 1\n    # Máquina en funcionamiento\n    nfun[i] = nfun[i-1] + 1\n    tfun[i] = rexp(1, tasafun) \n    tsis[i] = tsis[i-1] + tfun[i]\n    trep[i] = 0 #Actualizamos estos dos parámetros ya que no hemos entrado en reparación\n    nrep[i] = nrep[i-1]\n    if(tsis[i] > tfin) {\n      # adaptamos valores para quedarnos en los 365 días\n      tfun[i] <- tfin - tsis[i-1]\n      tsis[i] <- tsis[i-1] + tfun[i]\n      break\n      }\n    # Máquina en reparación\n    nrep[i] = nrep[i-1] + 1\n    trep[i] = rexp(1, tasarep)\n    tsis[i] = tsis[i] + trep[i]\n    if(tsis[i] > tfin) {\n    # adaptamos valores para quedarnos en los 365 días\n      trep[i] <- tfin - tsis[i-1] \n      tsis[i] = tsis[i] + trep[i]\n      break\n      }\n  }\n  res <- tibble(tfun, nfun, trep, nrep, tsis)\n  # Devolvemos resultados del sistema quitando la fila de inicialización\n  return(res[-1,])\n}\nmu <- 1/60\nlambda <- 1/4\nsimulacion <- TSIM_one_machine(mu, lambda, 365)\nsimulacion## # A tibble: 6 × 5\n##     tfun  nfun  trep  nrep  tsis\n##    <dbl> <dbl> <dbl> <dbl> <dbl>\n## 1  50.6      1 2.31      1  52.9\n## 2  79.7      2 0.126     2 133. \n## 3   3.37     3 1.27      3 137. \n## 4  18.9      4 0.581     4 157. \n## 5 164.       5 0.117     5 321. \n## 6  44.5      6 0         5 365\ntiempos <- apply(simulacion[c(1,3)], 2, sum)\ntiempos##       tfun       trep \n## 360.603564   4.396436\nbeneficio <- 100 * tiempos[\"tfun\"] - 1500 * tiempos[\"trep\"]\nbeneficio##    tfun \n## 29465.7"},{"path":"CMTC.html","id":"sistema-del-viajante","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.3.2 Sistema del viajante","text":"continuación analizamos el sistema del viajante correspondiente al ejemplo 4.2. En primer lugar establecemos el algoritmo de simulación del sistema. Para facilitar todas las posibilidades del algoritmo asumimos que el vendedor comienza el recorrido en la ciudad en la que reside.Algoritmo para el análisis del sistema del viajante:Fijar tasas de permanencia en cada ciudad \\(\\mu_A\\), \\(\\mu_B\\), y \\(\\mu_C\\), así como las probabilidades de salto dadas en la matriz \\(P\\), y una varibale que indica la ciudad en la que nos encontramos (\\(ciudad\\)).Fijar el tiempo de funcionamiento del sistema \\(tsis = 0\\), tiempo de permanencia en cada ciudad \\(tiempo = 0\\), y el tiempo de estudio \\(tfin\\).Generar \\(tiempo \\sim Exp(\\mu_a)\\) y actualizar \\(tsis\\), de forma que si \\(tsis > tfin\\) abandonamos el sistema.Generamos un salto de la ciudad \\(\\) de acuerdo las probabilidades de \\(P\\) correspondientes la ciudad \\(\\).Repetir los pasos siguientes hasta que el tiempo en el sistema supere el tiempo fijado:Actualizamos \\(ciudad\\), generamos \\(tiempo \\sim Exp(\\mu_{ciudad})\\) y actualizamos \\(tsis\\), de forma que si \\(tsis > tfin\\) abandonamos el sistema.Generamos un salto de la ciudad del paso anterior de acuerdo las probabilidades de \\(P\\) correspondientes dicha ciudad.Los valores \\(tiempo\\), y \\(ciudad\\) nos permiten describir el funcionamiento del sistema para un tiempo prefijado.continuación construimos la función para simular el sistema hasta cierto instante de tiempo.Supongamos que estamos interesados en aproximar el comportamiento del vendedor durante el próximo año (52 semanas) para poder contestar las preguntas siguientes:Proporción de tiempo que el vendedor pasa en cada ciudad.Número de ocasiones en que visita cada ciudad.Simulamos pues el sistema y contestamos las preguntas planteadas:","code":"\nTSIM_viajante <- function(tasaA, tasaB, tasaC, tfin)\n{\n  # Parámetros de la función\n  # =========================\n  # tasaA: tasa de permanencia en A\n  # tasaB: tasa de permanencia en B\n  # tasaC: tasa de permanencia en C\n  # tfin: tiempo de funcionamiento del sistema\n  \n  # inicialización de parámetros del sistema \n  tiempo = tsis = ciudad = vector()\n  # Probabilidades de salto. Fijamos la primera ya que la otra es complementaria\n  pA <- 0.5 # de A a B. De A a C es  1-pA\n  pB <- 0.75 # de B a A. De B a C es  1-pB\n  pC <- 0.75 # de C a A. De C a B es  1-pC\n  \n  # estado inicial del sistema\n  i <- 1\n  ciudad[i] <- \"A\"\n  # Fijamos semilla\n  set.seed(123)\n  # Primer tiempo de estancia\n  tiempo[i] = rexp(1, tasaA)\n  tsis[i] <- tiempo[i]\n  # Saltamos de la ciudad A\n  uniforme <- runif(1)\n  ifelse(uniforme <= pA, ciudad[i+1] <- \"B\", ciudad[i+1] <- \"C\")\n      \n  # Bucle de simulación\n  while(tsis[i] <= tfin)\n  {\n    i<- i + 1\n    uniforme <- runif(1)\n    if(ciudad[i] == \"A\")\n      {\n        # Calculamos tiempo de permanencia\n        tiempo[i] <- rexp(1, tasaA)\n        # Actualizamos y valoramos si hemos alcanzado el tiempo límite\n        tsis[i] = tsis[i-1] + tiempo[i]\n        if(tsis[i] > tfin){\n            tiempo[i] <- tfin - tsis[i-1] \n            tsis[i] = tsis[i-1] + tiempo[i]\n            break\n          }\n        # Si no hemos alcanzado el límite realizamos un nuevo salto\n        ifelse(uniforme <= pA, ciudad[i+1] <- \"B\", ciudad[i+1] <- \"C\")\n      }\n    if(ciudad[i] == \"B\")\n      {\n        # Calculamos tiempo de permanencia\n        tiempo[i] <- rexp(1, tasaB)\n        # Actualizamos y valoramos si hemos alcanzado el tiempo límite\n        tsis[i] = tsis[i-1] + tiempo[i]\n        if(tsis[i] > tfin){\n            tiempo[i] <- tfin - tsis[i-1] \n            tsis[i] = tsis[i-1] + tiempo[i]\n            break\n          }\n        # Si no hemos alcanzado el límite realizamos un nuevo salto\n        ifelse(uniforme <= pB, ciudad[i+1] <- \"A\", ciudad[i+1] <- \"C\")\n      }  \n    if(ciudad[i] == \"C\")\n      {\n        # Calculamos tiempo de permanencia\n        tiempo[i] <- rexp(1, tasaC)\n        # Actualizamos y valoramos si hemos alcanzado el tiempo límite\n        tsis[i] = tsis[i-1] + tiempo[i]\n        if(tsis[i] > tfin){\n            tiempo[i] <- tfin - tsis[i-1] \n            tsis[i] = tsis[i-1] + tiempo[i]\n            break\n          }\n        # Si no hemos alcanzado el límite realizamos un nuevo salto\n        ifelse(uniforme <= pC, ciudad[i+1] <- \"A\", ciudad[i+1] <- \"C\")\n      }\n  }\n  # Devolvemos resultados del sistema \n  ciudad <- factor(ciudad)\n  res <- tibble(tiempo, ciudad, tsis)\n  return(res)\n}\ntasaA <- 1/2\ntasaB <- 1/1\ntasaC <- 2/3\ntfin <- 52\nsimulacion <- TSIM_viajante(tasaA, tasaB, tasaC, tfin)  \n# Análsis del sistema\nsimulacion %>% \n  group_by(ciudad) %>% \n  summarise(visita = n(), estancia = sum(tiempo)) %>%\n  mutate(proporcion = estancia/52)## # A tibble: 3 × 4\n##   ciudad visita estancia proporcion\n##   <fct>   <int>    <dbl>      <dbl>\n## 1 A          16     30.3      0.583\n## 2 B           8     10.7      0.206\n## 3 C          11     11.0      0.211"},{"path":"CMTC.html","id":"análisis-con-simmer","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.3.3 Análisis con simmer","text":"Si bien dedicamos en este curso un capítulo entero para contar el funcionamiento de la librería simmer, puesto que estos ejemplos son relativamente sencillos, podemos introducir sin demasiada complicación el algoritmo de simulación con simmer.La libreria simmer permite simular de sistemas tanto continuos como discretos bajos dos premisas fundamentales:Proceso de llegadas (“arrivals”) al sistema.Proceso de servicio (“server”): en el que cada una de las llegadas se les asigna una serie de actividades realizar (integradas en ‘trayectorias’) y unos recursos o servidores que resuelven con ellas las actividades.Para el sistema descrito en ejemplo 4.5 el proceso de llegadas viene identificado por las averías que se producen en determinados instantes de tiempo. El proceso de servicio se corresponde con las reparaciones de las máquinas, las que se dedica cierto tiempo. En este caso el recurso es el reparador encargado de resolver la avería y poner en marcha la máquina de nuevo.El primer paso del algoritmo de simulación es cargar las librerías y definir la semilla de simulación:Definimos ahora el entorno de simulación del sistema:Analizamos ahora los resultados que proporciona el sistema simulado. Podemos acceder las información de dos formas diferentes mediante las funciones get_mon_arrivals() para describir las llegadas (averías) y get_mon_resources() para describir la ocupación de los servidores recursos (técnicos reparadores).El objeto resultante tiene las columnas siguientes:name: nombre de las llegadas (averías), numeradas correlativamentestar_time: instante en el que llega al sistema (se produce la avería)end_time: instante en el que sale del sistema (se ha reparado)activity_time: tiempo dedicado la tarea (tiempo de reparación)finished: si la tarea ha finalizado dentro del periodo de tiempo de simulación establecido.replication: número de replicas del sistema (1 porque sólo hemos lanzado una cadena).Con la función get_mon_resources() tenemos una descripción continua de los recursos del proceso con las columnas:resource: recurso (numerado correlativamente si hubiera más de uno)time: instante de tiempo en que se ha registrado alguna actividad (avería, reparación, puesta en marcha)server: número de servidores (recursos) ocupados (como sólo hay un técnico, es igual 1)queue: llegadas en la cola (averías que están esperando ser reparadas porque el técnico está ocupado)capacity: capacidad del sistema o número de reparadores en el sistemaqueue_size: tamaño de la cola de espera (averías en espera para ser reparadas)system: llegadas en el sistema (número de averías en ese instante, en reparación o en cola)limit: capacidad + tamaño de la colareplication: número de replica del sistema (1 porque sólo se ha lanzado una cadena).partir de los resultados podemos responder las mismas preguntas que ya planteamos antes:Proporción del tiempo que la máquina está funcionando y en reparación.Número de ocasiones en que la máquina debe ser reparada.Si el beneficio neto es de 100 euros por cada día que la máquina está funcionando y una pérdida de 1500 euros por cada día que está en reparación ¿cuál es el beneficio esperado para el próximo año?Para responder al primer pregunta basta con sumar los tiempos de actividad y calcualr su proporción sobre los 365 días de simulación:La proporción de tiempo en que la máquina está funcionando es del 93.87% y el tiempo que está en reparación es del 6.13%.El número de ocasiones en que la máquina está en reparación corresponde al número de veces que accedemos la tarea de reparación, que en este caso es de 6.Para calcular el beneficio obtenido lo largo del año utilizamos el tiempo de reparación obtenido:Como se puede ver, los resultados son muy similares los obtenidos con el algoritmo que programamos nosotros. Para conseguir estimaciones estables deberíamos realizar diferentes replicaciones del sistema (lanzar varias cadenas) y promediar los beneficios obtenidos mediante un estimador Monte-Carlo. Podemos replicar fácilmente el sistema añadiendo dos líneas de código. Cada cadena replicada tendrá un distintivo diferente en el argumento ‘replicate’ cuando monitorizamos los resultados.Ahora almacenamos todas las simulaciones modo de matriz, en concreto ‘tibble,’ para poder realizar los cálculos oportunos agrupando por réplicas y con ellos poder calcular las estimaciones Monte-Carlo del tiempo total de reparación y del número de reparaciones.En ‘mmedia_nrepara’ tenemos la estimación del número de reparaciones en un año, en ‘min_nrepara’ y ‘max_nrepara’ el mínimo y el máximo respectivamente; en ‘media_taveria’ tenemos una estimación del tiempo medio acumulado en reparaciones en un año, con sus cuartiles (q25, q50 y q75) y desviación típica (sd).Así podemos calcular los beneficios esperados en función del número de días que la máquina funciona y los que está estropeada:Podemos considerar también otros dos escenarios posibles: uno pesimista, con un mayor tiempo acumulado de reparación (cuantil 75), y uno optimisma, con un menor tiempo (con el cuantil 25), y calcular con ellos los beneficios:¿Qué conclusiones podemos extraer de este análisis?Para finalizar este apartado presentamos un nuevo ejemplo donde el espacio de estados está compuesto por una pareja de valores y por un único valor como en los ejemplos que hemos presentado hasta ahora.","code":"\nlibrary(simmer)\nlibrary(simmer.plot)\nlibrary(simmer.bricks)\nset.seed(1234)\n# Tasas de permanencia del sistema\n##################################\nlambda <- 1/4  # tasa reparación\nmu <- 1/60     # tasa funcionamiento\n\n# Sistema\n#################################################\nsistema.1m <- function(t, lambda, mu)\n{\n  # tarea dentro de sistema: reparación de las averías\n  reparar <- trajectory() %>%\n    # la máquina estropeada se asigna a un reparador\n    seize(\"reparador\", amount = 1) %>%              \n    # el tiempo de reparación es aleatorio\n    timeout(function() rexp(1, lambda)) %>%   \n    # la máquina ya ha sido reparada\n    release(\"reparador\", amount = 1)               \n\n  # Configuración del sistema \n  #################################################\n  simmer() %>%\n    # Se definen los recursos: un único reparador y cola infinita\n    add_resource(\"reparador\", capacity = 1) %>%           \n    # Simulador de los tiempos entre averías, dirigidas a la trayectoria \"reparar\"\n    add_generator(\"averia\", reparar, function() rexp(1, mu)) %>% \n    # Tiempo funcionamiento del sistema\n    run(until = t)     \n}\n\n### Simulación del sistema durante 365 días\noperar <- sistema.1m(365, 1/4, 1/60)\nreparacion = get_mon_arrivals(operar)\nreparacion##      name start_time end_time activity_time finished replication\n## 1 averia0   150.1055 150.1318    0.02632783     TRUE           1\n## 2 averia1   164.9110 166.4598    1.54873033     TRUE           1\n## 3 averia2   269.4758 272.7721    3.29632606     TRUE           1\n## 4 averia3   274.8728 278.2250    3.35216128     TRUE           1\n## 5 averia4   287.0299 294.5502    7.52030671     TRUE           1\n## 6 averia5   332.6557 339.2903    6.63464954     TRUE           1\nrecursos = get_mon_resources(operar)\nrecursos##     resource     time server queue capacity queue_size system limit replication\n## 1  reparador 150.1055      1     0        1        Inf      1   Inf           1\n## 2  reparador 150.1318      0     0        1        Inf      0   Inf           1\n## 3  reparador 164.9110      1     0        1        Inf      1   Inf           1\n## 4  reparador 166.4598      0     0        1        Inf      0   Inf           1\n## 5  reparador 269.4758      1     0        1        Inf      1   Inf           1\n## 6  reparador 272.7721      0     0        1        Inf      0   Inf           1\n## 7  reparador 274.8728      1     0        1        Inf      1   Inf           1\n## 8  reparador 278.2250      0     0        1        Inf      0   Inf           1\n## 9  reparador 287.0299      1     0        1        Inf      1   Inf           1\n## 10 reparador 294.5502      0     0        1        Inf      0   Inf           1\n## 11 reparador 332.6557      1     0        1        Inf      1   Inf           1\n## 12 reparador 339.2903      0     0        1        Inf      0   Inf           1\ntiempo_reparacion <- sum(reparacion$activity_time)\npropor <- round(100*(1-(tiempo_reparacion/365)), 2)\npropor## [1] 93.87\n(365-tiempo_reparacion)*100 - tiempo_reparacion*1500## [1] 694.3972\n# lanzamos 'nreplicas' de la cadena, que se almacenan en una lista\nnreplicas <- 500\nenvs <- lapply(1:nreplicas, function(i){\n  operar <- sistema.1m(365, 1/4, 1/60)\n})\n# guardamos todas las llegadas en formato 'tibble'\nsimulaciones <- as_tibble(get_mon_arrivals(envs))\n\n# agrupamos por 'replication' para calcular los descriptivos de interés en cada réplica\nsalida <- simulaciones %>% \n  group_by(replication) %>% \n  # Calculamos los descriptivos por cada réplica\n  summarise(nreparaciones = n(), \n            tiempoparada = sum(activity_time)) %>% \n  # Calculamos las estimaciones Monte-Carlo con los descriptivos de las réplicas\n  summarise(mmedia_nrepara = mean(nreparaciones),\n            min_nrepara = min(nreparaciones),\n            max_nrepara = max(nreparaciones),\n            media_taveria = mean(tiempoparada),\n            q25_taveria = quantile(tiempoparada, 0.25),\n            q50_taveria = quantile(tiempoparada, 0.50),\n            q75_taveria = quantile(tiempoparada, 0.75),\n            sd_taveria = sd(tiempoparada) \n            )\nsalida## # A tibble: 1 × 8\n##   mmedia_nrepara min_nrepara max_nrepara media_taveria q25_taveria q50_taveria q75_taveria\n##            <dbl>       <int>       <int>         <dbl>       <dbl>       <dbl>       <dbl>\n## 1           6.12           1          15          23.8        13.4        21.3        31.9\n## # … with 1 more variable: sd_taveria <dbl>\n# número de días en funcionamiento vs número de días en reparación\n(365-salida$media_taveria)*100 - salida$media_taveria*1500## [1] -1561.395\n(365-salida$q75_taveria)*100 - salida$q75_taveria*1500##       75% \n## -14480.82\n(365-salida$q25_taveria)*100 - salida$q25_taveria*1500##      25% \n## 15047.35"},{"path":"CMTC.html","id":"mantenimiento-de-aronaves","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.3.4 Mantenimiento de aronaves","text":"Una empresa de mantenimiento de aeronaves está interesada en el proceso de avería-reparación de cierto tipo de aviones. El tipo de avión de interés es un avión comercial reacción con cuatro motores, dos en cada ala. Cuando un motor se enciende, el tiempo que se puede mantener en funcionamiento hasta que falla es una variable aleatoria exponencial con parámetro \\(\\lambda\\). Si el fallo se produce en vuelo, puede haber reparación, pero el avión necesita al menos un motor en cada ala para funcionar correctamente y poder volar con seguridad. En concreto, la empresa está interesada en poder predecir la probabilidad de un vuelo sin problemas.Si denotamos por \\(X_L(t)\\) y \\(X_R(t)\\) el número de motores funcionando en el instante \\(t\\) en el ala izquierda y el ala derecha respectivamente, podemos considerar el estado del sistema en el instante \\(t\\) como \\(X(t) = (X_L(t), X_R(t))\\). Si asumimos que los fallos en los motores son independientes entre sí, podemos ver que el proceo \\(\\{X(t), t \\geq 0\\}\\) es una CMTC con espacio de estados:\\[S = \\{ (0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2,2) \\}\\]En esta situación, el avión sigue funcionando en el subconjunto de estados \\(S = \\{ (1, 1), (1, 2), (2, 1), (2,2) \\}\\).Vamos asumir (aunque es real) que el sistema sigue funcionando, incluso cuando hay posibilidad de un accidente, hasta que llegamos al estado \\((0, 0)\\). Dado que hay reparación posible, la matriz de tasas entre estados del sistema viene dada por\\[R = \n\\begin{pmatrix}\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\\lambda & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 2\\lambda & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\\lambda & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & \\lambda & 0 & \\lambda & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & \\lambda & 0 & 2\\lambda & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 2\\lambda & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 2\\lambda & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 2\\lambda & 0 & 2\\lambda & 0\n\\end{pmatrix} \\]y el diagrama que representa el sistema resulta:\nFigura 4.4: Diagrama de tasas para el sistema motores de aviones\nPara facilitar el algoritmo de simulación en esta situación, vamos asignar un código cada uno de los posibles estados del sistema:\\[S = \\{ 1 = (0, 0), 2 = (0, 1), 3 = (0, 2), 4 = (1, 0), 5 = (1, 1), 6 = (1, 2), 7 = (2, 0), 8 = (2, 1), 9 = (2,2) \\}\\]y asumimos que la media del tiempo hasta que un motor falla cuando está encendido es de 20 horas, es decir, \\(\\lambda = 1/20\\). continuación hemos construido una función para simular el sistema descrito:Veamos una simulación del sistema:El resultado obtenido es el estado en cada paso del algoritmo hasta llegar la parada total, los tiempos para alcanzar cada estado, y el número de motores con fallo.Podemos operar los tiempos para saber cuándo tendremos más de dos motores con fallo (últimas dos filas de la simulación).Si el vuelo que acabamos de empezar es de \\(x\\) horas ¿cómo podemos estimar la probabilidad de poder terminar el vuelo de forma segura? Para responder esta pregunta podremos calcular la proporción de tiempo que corresponde con un fallo leve (1 o 2 motores con fallo) con respecto las \\(x\\) horas de duración del vuelo.Calculamos continuación el tiempo de fallo del sistema y evaluamos la probabilidad para diferentes tiempos de duración de vuelo.Cualquier viaje inferior 8.8 horas será un viaje seguro, mientras que si el tiempo es superior, la probabilidad de tener un viaje seguro aumenta.Para estudiar la estabilidad de dichas probabilidades realizamos 1000 simulaciones del sistema y estimamos las probabilidades mediante estimadores Monte-Carlo de los tiempos de fallo.Cualquier viaje inferior 11.9 horas será un viaje seguro, mientras que si el tiempo es superior, la probabilidad de tener un viaje seguro aumenta. Podemos representar el gráfico de probabilidad de un viaje seguro:\nFigura 4.5: Probabilidad de un viaje seguro\n","code":"\nTSIM_aviones <- function(tasa)\n{\n  # Parámetros de la función\n  # =========================\n  # tasa: tasa de fallo de un motor\n  \n  # Valores fijos del sistema\n  # codigos de motores funcionando obviando el estado inicial\n  codigo <- 1:8\n  # motores con fallo de acuerdo al código\n  motoresOFF <- c(4, 3, 2, 3, 2, 1, 2, 1)\n  \n  # inicialización de parámetros del sistema \n  tiempo =  estado = fallos = vector()\n  i<-1\n  # Primer fallo\n  # Posibles estados de salto\n  saltos = c(codigo[6], codigo[8])\n  # tiempos asociados a cada fallo\n  simula = rexp(2, 2*tasa)\n  # Seleccionamos el salto\n  posicion = which.min(simula)\n  if(posicion == 1)\n  {\n    estado[i] <- saltos[posicion]\n    tiempo[i] <- simula[posicion] \n    fallos[i] <- motoresOFF[saltos[posicion]]\n    # nuevo salto\n    i <- i + 1\n    saltos = c(codigo[3], codigo[5])\n    simula = c(rexp(1, tasa), rexp(1, 2*tasa))\n    posicion = which.min(simula)\n    if(posicion == 1)\n    {\n      estado[i] <- saltos[posicion]\n      tiempo[i] <- simula[posicion] \n      fallos[i] <- motoresOFF[saltos[posicion]]\n      # dos últimos saltos\n      estado[i+1] <- 2; estado[i+2] <- 1\n      tiempo[i+1] <- rexp(1, 2*tasa); tiempo[i+2] <- rexp(1, tasa)\n      fallos[i+1] <- motoresOFF[estado[i+1]]; fallos[i+2] <- motoresOFF[estado[i+2]]\n    }\n    else\n    {\n      estado[i] <- saltos[posicion]\n      tiempo[i] <- simula[posicion] \n      fallos[i] <- motoresOFF[saltos[posicion]]  \n      # dos últimos saltos\n      estado[i+1] <- 2; estado[i+2] <- 1\n      tiempo[i+1] <- rexp(1, tasa); tiempo[i+2] <- rexp(1, tasa)\n      fallos[i+1] <- motoresOFF[estado[i+1]]; fallos[i+2] <- motoresOFF[estado[i+2]]\n    }\n  }\n  else\n  {\n    estado[i] <- saltos[posicion]\n    tiempo[i] <- simula[posicion] \n    fallos[i] <- motoresOFF[saltos[posicion]]\n    # nuevo salto\n    i <- i + 1\n    saltos = c(codigo[7], codigo[5])\n    simula = c(rexp(1, tasa), rexp(1, 2*tasa))\n    posicion = which.min(simula)\n    if(posicion == 1)\n    {\n      estado[i] <- saltos[posicion]\n      tiempo[i] <- simula[posicion] \n      fallos[i] <- motoresOFF[saltos[posicion]]\n      # dos últimos saltos\n      estado[i+1] <- 2; estado[i+2] <- 1\n      tiempo[i+1] <- rexp(1, 2*tasa); tiempo[i+2] <- rexp(1, tasa)\n      fallos[i+1] <- motoresOFF[estado[i+1]]; fallos[i+2] <- motoresOFF[estado[i+2]]\n    }\n    else\n    {\n      estado[i] <- saltos[posicion]\n      tiempo[i] <- simula[posicion] \n      fallos[i] <- motoresOFF[saltos[posicion]]  \n      # dos últimos saltos\n      estado[i+1] <- 2; estado[i+2] <- 1\n      tiempo[i+1] <- rexp(1, tasa); tiempo[i+2] <- rexp(1, tasa)\n      fallos[i+1] <- motoresOFF[estado[i+1]]; fallos[i+2] <- motoresOFF[estado[i+2]]\n    }    \n  }\n\n  # Devolvemos resultados del sistema \n  res <- tibble(estado, tiempo, fallos)\n  return(res)\n}\nset.seed(12)\ntasa <- 1/20\nsistema <- TSIM_aviones(tasa)\nsistema## # A tibble: 4 × 3\n##   estado tiempo fallos\n##    <dbl>  <dbl>  <dbl>\n## 1      8   6.36      1\n## 2      7   2.35      2\n## 3      2  18.2       3\n## 4      1   5.67      4\n# Tiempo de fallo\nTfallo <- round(sum(sistema$tiempo[sistema$fallos <= 2]), 2)\n# Duración del vuelo\ntd <- seq(0.1, 12, by = 0.1)\nprob <- vector()\n# Probabilidad viaje seguro\nfor(i in 1:length(td))\n{\n  prob[i] <- ifelse(Tfallo >= td[i], 1, round(Tfallo/td[i], 3))\n}\n# Obtenemos el valor mínimo de tiempo para asegurar un viaje seguro\nlimite <- min(td[which(prob != 1)])\nlimite## [1] 8.8\nnsim <- 1000\nTfallo <- vector()\n# Repetición del sistema y calculo de tiempo \nfor(i in 1:nsim)\n{\n  sistema <- TSIM_aviones(tasa)\n  Tfallo[i] <- round(sum(sistema$tiempo[sistema$fallos <= 2]), 2)\n}\n# Estimador Monte-Carlo\nestimMC<- mean(Tfallo)\n# Duración del vuelo\ntd <- seq(0.1, 20, by = 0.1)\nprob <- vector()\n# Probabilidad viaje seguro\nfor(i in 1:length(td))\n{\n  prob[i] <- ifelse(estimMC >= td[i], 1, round(estimMC/td[i], 3))\n}\n# Obtenemos el valor mínimo de tiempo para asegurar un viaje seguro\nlimite <- min(td[which(prob != 1)])\nlimite## [1] 11.9"},{"path":"CMTC.html","id":"CMTCD","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.4 Procesos de nacimiento y muerte","text":"Los procesos de nacimiento y muerte que estudiamos en este apartado juegan un papel muy importante dentro de las CMTC, ya que son de uso habitual en muchas aplicaciones prácticas que veremos de ahora en adelante.Definición 4.2  Una CMTC \\(\\{X_t; t \\geq 0\\}\\) con espacio de estados \\(S = \\{0, 1, 2,...,N\\}\\) y matriz de tasas dada por:\\[R = \n\\begin{pmatrix}\n0 & \\lambda_0 & 0 & 0 & \\ldots & 0 & 0 \\\\\n\\mu_1 & 0 & \\lambda_1 & 0 & \\ldots & 0 & 0 \\\\\n0 & \\mu_2 & 0 & \\lambda_2 & \\ldots & 0 & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ldots & \\vdots & \\vdots \\\\\n0 & 0 & 0 & 0 & \\ldots & 0 & \\lambda_{N-1} \\\\\n0 & 0 & 0 & 0 & \\ldots &\\mu_N & 0\n\\end{pmatrix} \\]se denomina proceso finito de nacimiento y muerte donde los \\(\\lambda_i\\) se denominan parámetros de nacimiento (transición del estado \\(\\) al \\(+1\\)) y los \\(\\mu_i\\) se denominan parámetros de muerte (transición del estado \\(\\) al \\(-1)\\), donde por conveniencia se asume que \\(\\lambda_K = 0\\) y \\(\\mu_0 = 0\\) indicando que hay nacimientos en el estado \\(K\\) y que hay muertes en el estado \\(0\\).En esta situación el proceso permanece una cantidad de tiempo \\(exp(\\lambda_i + \\mu_i)\\) en el estado \\(\\) y después salta al estado \\(+1\\) con probabilidad \\(\\lambda_i/(\\lambda_i + \\mu_i)\\), o al estado \\(-1\\) con probabilidad \\(\\mu_i/(\\lambda_i + \\mu_i)\\). Además, la matriz generadora del proceso viene dada por:\\[R = \n\\begin{pmatrix}\n- \\lambda_0& \\lambda_0 & 0 & 0 & \\ldots & 0 & 0 \\\\\n\\mu_1 & -(\\mu_1 + \\lambda_1) & \\lambda_1 & 0 & \\ldots & 0 & 0 \\\\\n0 & \\mu_2 & -(\\mu_2 + \\lambda_2) & \\lambda_2 & \\ldots & 0 & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ldots & \\vdots & \\vdots \\\\\n0 & 0 & 0 & 0 & \\ldots & -(\\mu_{k-1} + \\lambda_{k-1}) & \\lambda_{k-1} \\\\\n0 & 0 & 0 & 0 & \\ldots & \\mu_k & -\\mu_k\n\\end{pmatrix} \\]continuación presentamos diferentes ejemplos de aplicación de los procesos de nacimiento y muerte.","code":""},{"path":"CMTC.html","id":"colas-de-espera-de-capacidad-finita-con-un-servidor","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.4.1 Colas de espera de capacidad finita con un servidor","text":"Aunque en la unidad siguiente estudiaremos con mucho más detalle los diferentes sistemas de colas de espera, vamos presentar aquí el modelo más sencillo de colas, para comprobar que se puede modelar como un proceso de nacimiento y muerte.Imaginemos que tenemos un cajero bancario al que los clientes acuden de acuerdo Proceso de Poisson de parámetro \\(\\lambda\\), es decir que las llegadas son aleatorias y se distribuyen según una \\(Exp(\\lambda)\\). Si hay \\(K-1\\) clientes haciendo cola para ser atendidos, un cliente nuevo tomará la opción de buscar otro cajero, es decir, el sistema tiene capacidad \\(K\\) (1 cliente atendido y \\(K-1\\) en la cola de espera). Además, el tiempo de servicio del cajero tiene una distribución \\(Exp(\\mu)\\).En esta situación la variable \\(X(t)\\) que indica el número de sujetos en el sistema en el instante \\(t\\) es una CMTC denominada cola \\(M/M/1/K\\), donde \\(M\\) hace referencia los tiempos de llegada y servicio exponenciales, el \\(1\\) hace referencia la capacidad del servicio (sólo un cliente puede ser atendido en un instante dado), \\(K\\) es el tamaño del sistema (o aforo total), y \\(S = \\{0, 1, 2,...K \\}\\) el espacio de estados. Este tipo de sistemas son procesos de nacimiento y muerte con:\\[\\begin{eqnarray*}\n\\lambda_i &=& \\lambda, \\quad 0 \\leq \\leq K-1, \\\\\n\\mu_i &=& \\mu, \\quad 0 \\leq \\leq K,\n\\end{eqnarray*}\\]donde el “nacimiento” y la “muerte” hacen referencia la llegada al cajero y la salida del cajero respectivamente.Veamos la descripción del sistema:En el estado \\(X_t=0\\) el sistema está vacío y el único evento que puede ocurrir es una llegada, que se produce después de un tiempo \\(Exp(\\lambda)\\), provocando una transición al estado \\(X_t=1\\). En este caso \\(r_{01} = \\lambda\\).En el estado \\(X_t=0\\) el sistema está vacío y el único evento que puede ocurrir es una llegada, que se produce después de un tiempo \\(Exp(\\lambda)\\), provocando una transición al estado \\(X_t=1\\). En este caso \\(r_{01} = \\lambda\\).En el estado \\(X_t=\\) (\\(1 \\leq \\leq K-1\\)), tenemos dos posibilidades en el sistema: una llegada o una salida. En el primer caso tenemos \\(r_{, +1} = \\lambda\\), mientras que en el segundo tenemos \\(r_{, -1} = \\mu\\).En el estado \\(X_t=\\) (\\(1 \\leq \\leq K-1\\)), tenemos dos posibilidades en el sistema: una llegada o una salida. En el primer caso tenemos \\(r_{, +1} = \\lambda\\), mientras que en el segundo tenemos \\(r_{, -1} = \\mu\\).En el estado \\(X_t=K\\) sólo se puede producir una salida de forma que \\(r_{K, K-1} = \\mu\\).En el estado \\(X_t=K\\) sólo se puede producir una salida de forma que \\(r_{K, K-1} = \\mu\\).Por tanto, la matriz de tasas correspondiente este proceso viene dada por:\\[R = \n\\begin{pmatrix}\n0 & \\lambda & 0 & 0 & \\ldots & 0 & 0 \\\\\n\\mu & 0 & \\lambda & 0 & \\ldots & 0 & 0 \\\\\n0 & \\mu & 0 & \\lambda & \\ldots & 0 & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ldots & \\vdots & \\vdots \\\\\n0 & 0 & 0 & 0 & \\ldots & 0 & \\lambda \\\\\n0 & 0 & 0 & 0 & \\ldots &\\mu & 0\n\\end{pmatrix} \\]El diagrama de tasas para una cola \\(M/M/1/4\\), es decir con una capacidad de 4 usuarios en el sistema (1 atendido y tres en espera) es:\nFigura 4.6: Diagrama de tasas para cola M/M/1/4.\nEste sistema puede implementarse fácilmente en simmer si entendemos como “resource” al servicio del cajero y como “generator” la llegada al cajero. Escribimos el algoritmo de forma general para cualquier valor de \\(K\\).Imaginemos que por la mañanas (de 8 15) las llegadas de clientes se producen con una tasa de 15 clientes/hora, mientras que el tiempo medio que el cliente permanece en el cajero es de 6 minutos. Expresada en minutos tendríamos una tasa de llegadas \\(\\lambda = 15/60\\), y una tasa de servicio \\(\\mu = 1/6\\). Se ha observado además que cuando la cola de espera es de tres clientes nadie más espera para hacer cola (\\(K = 4\\)). Analizamos el sistema de forma básica para una mañana cualquiera, es decir para un periodo de 7 horas (420 minutos).Veamos con un poco de detalle las salidas que proporciona el sistema. Comenzamos con el proceso de llegadas al sistema viendo las primeras 10 llegadas al sistema:En la columna name tenemos el identificador de la llegada al sistema (cajero), en las columnas start_time y end_time tenemos el instante de tiempo en el que llega y sale del cajero. La columna activity_time muestra el tiempo de servicio en el cajero (durante el que es atendido el cliente); un valor 0 identifica un cliente que ha sido atendido porque sobrepasó la capacidad del sistema (esperó al ver la cola y se marchó). Estos coinciden con los valores FALSE de la columna finished, que identifica los clientes que han podido ser atendidos. Con estas salidas resulta muy fácil calcular el tiempo de servicio del sistema así como el porcentaje de clientes rechazados, y el tiempo esperando en la cola.Podemos estudiar el comportamiento del sistema, y en particular de la cola, también en términos de los servidores.En este caso las columnas nos informan sobre el instante de tiempo (time) en el que se produce alguna actividad en el sistema, la columna server indica el número de servidores ocupados atendiendo algún cliente, queue el número de clientes en la cola de espera, capacity la capacidad de servicio del sistema, queue_size el tamaño máximo de la cola, system el número de clientes en el sistema, limit la capacidad total de sistema, y finalmente replication da un indicador de la replicación de las simulaciones.Con estas salidas podemos describir fácilmente el comportamiento de la cola del sistema ya que podemos estudiar el número de clientes en cola lo largo del tiempo.Simulamos ahora el sistema en 500 ocasiones para inferir con mayor precisión el comportamiento del sistema.Para comentar: ¿Qué conclusiones extraemos del análisis realizado? ¿Cómo valorarías la ocupación del sistema? ¿Qué ocurriría si añadimos un nuevo cajero y ampliamos la capacidad del sistema 8 clientes?","code":"\n# Sistema\n#################################################\ncola.MM1K <- function(t, lambda, mu, servidores, usuarios)\n{\n  # lambda: tasa de llegadas\n  # mu: tasa de servicio\n  # servidores: número de servidores\n  # usuarios: capacidad total del sistema\n  cola <- usuarios - servidores\n  \n  servicio <- trajectory() %>%\n    # empieza a ser atendido\n    seize(\"atendiendo\", amount = 1) %>%   \n    # durante un tiempo exp(mu)\n    timeout(function() rexp(1, mu)) %>% \n    # termina el servicio de atención\n    release(\"atendiendo\", amount = 1)               \n\n  # Configuración del sistema \n  #################################################\n  simmer() %>%\n    # se crean los recursos (servidores) y se dimensiona la cola\n    add_resource(\"atendiendo\", capacity = servidores, queue_size = cola) %>%    \n    # se generan las llegadas de clientes según Exp(lambda)\n    add_generator(\"llegada\", servicio, function() rexp(1, lambda)) %>% \n    run(until = t)     \n}\nset.seed(12)\n### Simulación del sistema\nt=420; \nlambda=15/60; mu=1/6\nservidores=1; usuarios=4\ncajero <- cola.MM1K(t, lambda, mu, servidores, usuarios)\n### Salidas del sistema\ncajero.df.res <- get_mon_resources(cajero)  # recursos (servidores)\ncajero.df.arr <- get_mon_arrivals(cajero)   # llegadas (clientes)\nhead(cajero.df.arr, n = 10)##         name start_time  end_time activity_time finished replication\n## 1   llegada0   8.756865  9.461164      0.704299     TRUE           1\n## 2   llegada1  11.299066 22.198513     10.899446     TRUE           1\n## 3   llegada2  22.728061 46.307530     23.579469     TRUE           1\n## 4   llegada7  53.191599 53.191599      0.000000    FALSE           1\n## 5   llegada3  23.861384 53.496376      7.188846     TRUE           1\n## 6   llegada9  57.528321 57.528321      0.000000    FALSE           1\n## 7   llegada4  40.759227 59.558394      6.062018     TRUE           1\n## 8  llegada11  68.130173 68.130173      0.000000    FALSE           1\n## 9  llegada12  74.418248 74.418248      0.000000    FALSE           1\n## 10  llegada5  45.814971 75.428935     15.870541     TRUE           1\n# llegadas al sistema: número de clientes que han pasado por el cajero\nnsis <- nrow(cajero.df.arr);nsis## [1] 108\n# tiempo total de servicio\ntserver <- sum(cajero.df.arr$activity_time);tserver## [1] 407.9837\n# proporción de tiempo que el sistema está ocupado (atendiendo o en espera)\nround(100*tserver/t,2)## [1] 97.14\n# porcentaje de clientes que se marcharon sin ser atendidos\nrechazados <- sum(cajero.df.arr$finished == FALSE)\nround(100*rechazados/nsis,2)## [1] 48.15\n# Tiempos de espera en cola para ser atendido\ntespera <- cajero.df.arr$end_time - cajero.df.arr$start_time - cajero.df.arr$activity_time\n# tiempo medio de espera en cola y desv.típica\nmean(tespera);sd(tespera)## [1] 8.280251## [1] 10.53434\nhead(cajero.df.res, n = 10)##      resource      time server queue capacity queue_size system limit replication\n## 1  atendiendo  8.756865      1     0        1          3      1     4           1\n## 2  atendiendo  9.461164      0     0        1          3      0     4           1\n## 3  atendiendo 11.299066      1     0        1          3      1     4           1\n## 4  atendiendo 22.198513      0     0        1          3      0     4           1\n## 5  atendiendo 22.728061      1     0        1          3      1     4           1\n## 6  atendiendo 23.861384      1     1        1          3      2     4           1\n## 7  atendiendo 40.759227      1     2        1          3      3     4           1\n## 8  atendiendo 45.814971      1     3        1          3      4     4           1\n## 9  atendiendo 46.307530      1     2        1          3      3     4           1\n## 10 atendiendo 48.326016      1     3        1          3      4     4           1\n# Evolución del tamaño de la cola\nggplot(cajero.df.res, aes(time, queue)) +\n  geom_step() +\n  scale_x_continuous(breaks = seq(0, 420, 60)) + \n  labs(x = \"Tiempo (en minutos)\", y = \"Tamaño de la cola\")\n# Porcentaje de clientes en cola\nggplot(cajero.df.res, aes(x = queue)) + \n  geom_bar(aes(y = ..prop.. , group = 1)) + \n  scale_y_continuous(labels = scales::percent) + \n  labs(x = \"Clientes en la cola\", y = \"Porcentaje\")\n# Réplicas del sistema\nnreplicas=500\nt=420; \nlambda=15/60; mu=1/6\nservidores=1; usuarios=4\n\nenvs <- replicate(nreplicas,cola.MM1K(t, lambda, mu, servidores, usuarios))\n# almacenamos análisis de llegadas del sistema\nsimarrivals<-as_tibble(get_mon_arrivals(envs))\n\nsalida<-simarrivals %>% \n  group_by(replication) %>% \n  # Resumen de las simualciones\n  summarise(clientes = n(), \n            tiemposervicio = sum(activity_time),\n            proptiemposervicio = round(tiemposervicio/420, 2),\n            rechazados = clientes - sum(finished),\n            proprechazados = round(rechazados/clientes,2)) %>% \n  summarise(media_clientes = mean(clientes),\n            media_tserver = mean(tiemposervicio),\n            media_ptserver = 100*mean(proptiemposervicio),\n            media_rechazados = mean(rechazados),\n            media_prechazados = 100*mean(proprechazados)\n            )\nsalida## # A tibble: 1 × 5\n##   media_clientes media_tserver media_ptserver media_rechazados media_prechazados\n##            <dbl>         <dbl>          <dbl>            <dbl>             <dbl>\n## 1           102.          377.           89.8             37.9              36.7"},{"path":"CMTC.html","id":"excmtc007","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.4.2 Mantenimiento de máquinas","text":"El problema del mantenimiento de máquinas es muy habitual dentro de las CMTC. Supongamos que disponemos de \\(N\\) máquinas que funcionan durante 24 horas seguidas y \\(M\\) personas que pueden repararlas (\\(M \\leq N\\)). Las máquinas son idénticas, y los tiempos de vida de las máquinas (reparaciones o mantenimiento) son variables aleatorias independientes \\(Exp(\\mu)\\). Cuando las máquinas fallan, son reparadas por orden de fallo (la primera que falla es la primera en ser reparada) por los \\(M\\) reparadores. Cada máquina averiada necesita una y sólo una persona para repararla, y los tiempos de reparación se distribuyen como una \\(Exp(\\lambda)\\); una vez reparada, la máquina continúa comportándose como una máquina nueva. Si \\(X(t)\\) el número de máquinas que funcionan en el momento \\(t\\), el proceso \\(\\{X(t), t \\geq 0\\}\\) es un proceso de nacimiento (avería) y muerte (reparación) con parámetros:\\[\\lambda_i = \\lambda \\cdot min(N-, M), \\quad 0 \\leq \\leq N,\\]\\[\\mu_i = \\mu \\cdot , \\quad 0 \\leq \\leq N.\\]\n::: exampleImaginemos un problema sencillo de mantenimiento de máquinas, que se puede generalizar fácilmente, en el que tenemos 4 máquinas y 2 reparadores, de forma que el espacio de estados (número de máquinas en funcionamiento) viene dado por \\(S = \\{0, 1, 2, 3, 4\\}\\). En este ejemplo vamos ver cómo los parámetros de nacimiento y muerte corresponden con los que acabamos de definir.:::Descripción del sistema:En el estado \\(X(t)=0\\), todas las máquinas están estropeadas, dos se encuentran en reparación (puesto que hay dos reparadores) y dos esperando ser reparadas, Los tiempos de reparación son iid \\(Exp(\\lambda)\\) y un vez se complete cualquiera de las dos repaciones el sistema cambiará al estado 1. De esta forma, \\(r_{01} = \\lambda_0 = \\lambda + \\lambda = 2\\lambda\\).En el estado \\(X(t)=0\\), todas las máquinas están estropeadas, dos se encuentran en reparación (puesto que hay dos reparadores) y dos esperando ser reparadas, Los tiempos de reparación son iid \\(Exp(\\lambda)\\) y un vez se complete cualquiera de las dos repaciones el sistema cambiará al estado 1. De esta forma, \\(r_{01} = \\lambda_0 = \\lambda + \\lambda = 2\\lambda\\).En el estado \\(X(t)=1\\), una máquina está en funcionamiento, hay dos en reparación y otra está en espera. Cuando una de las dos máquinas es reparada pasamos al estado 2. De esta forma, \\(r_{12} = \\lambda_1 = 2\\lambda\\). Además, en este estado la máquina que está funcionando puede fallar después de mantenerse en funcionamiento un tiempo \\(Exp(\\mu)\\) volviendo al estado 0, de forma que, \\(r_{10} = \\mu_1 = \\mu\\).En el estado \\(X(t)=1\\), una máquina está en funcionamiento, hay dos en reparación y otra está en espera. Cuando una de las dos máquinas es reparada pasamos al estado 2. De esta forma, \\(r_{12} = \\lambda_1 = 2\\lambda\\). Además, en este estado la máquina que está funcionando puede fallar después de mantenerse en funcionamiento un tiempo \\(Exp(\\mu)\\) volviendo al estado 0, de forma que, \\(r_{10} = \\mu_1 = \\mu\\).En el estado \\(X(t)=2\\), con razonamientos similares, tendremos que \\(r_{23} = \\lambda_2 = 2\\lambda\\) y \\(r_{21} = \\mu_2 = 2\\mu\\).En el estado \\(X(t)=2\\), con razonamientos similares, tendremos que \\(r_{23} = \\lambda_2 = 2\\lambda\\) y \\(r_{21} = \\mu_2 = 2\\mu\\).Para el resto de estados tendremos que \\(r_{34} = \\lambda_3 = \\lambda\\), \\(r_{32} = mu_3 = 3\\mu\\), y \\(r_{43} = \\mu_4 = 4\\mu\\).Para el resto de estados tendremos que \\(r_{34} = \\lambda_3 = \\lambda\\), \\(r_{32} = mu_3 = 3\\mu\\), y \\(r_{43} = \\mu_4 = 4\\mu\\).En esta situación el diagrama del proceso viene dado por:\nFigura 4.7: Diagrama de tasas para el mantenimiento de máquinas\nEste sistema se puede modelizar fácilmente en simmer sin más que fijar las tasas correspondientes, el número de máquinas disponibles, y el número de operarios. Supongamos que los tiempos de vida de las máquinas son variables aleatorias exponenciales con media de 3 días, mientras que los tiempos de reparación son variables exponenciales con media de 2 horas. Expresando todo en horas, tendríamos una tasa de reparación de \\(\\mu = 1/2\\), y una tasa de llegadas \\(\\lambda = 1/72\\).De nuevo planteamos una función que nos permita cambiar fácilmente los parámetros del sistema si fuera necesario. La empresa está interesada en:¿Cuántas máquinas estarán en funcionamiento después de 3 días?¿Durante qué porcentaje del tiempo las cuatro máquinas están funcionando?Simulamos el sistema y analizamos un poco la salida. Dado que en este sistema hay llegadas solo podemos estudiar los recursos.Respondemos en primer lugar al número de máquinas en funcionamiento los tres díasA las 72 horas el número de máquinas funcionando se corresponde con el valor de server. Para conocer el tiempo que las cuatro máquinas han estado funcionando debemos manipular los resultados obtenidos en el proceso de simulación.La proporción de tiempo en que las cuatro máquinas están funcionando simultáneamente es 95.36. Estudiamos la estabilidad del sistema realizando 500 simulaciones del sistema y estimando las cantidades de interés para la empresa.Tenemos entonces que el número de máquinas en funcionamiento es 1.97 y el tiempo de funcionamiento de las cuatro máquinas estimado es 3.58 para un periodo de 72 horas cuando al inicio todas las máquinas están paradas.","code":"\n# Sistema\n#################################################\nmantenimiento <- function(t, lambda, mu, capacidad)\n{\n  # lambda: tasa de reparación\n  # mu: tasa de vida de la máquina\n  # capacidad: reparadores\n  # K: máquinas\n  \n  # Distribuciones de tiempos\n  vida <- function() rexp(1, lambda)\n  reparacion <- function() rexp(1, mu)\n  \n  # Trayectoria \n  maquina <- trajectory() %>%\n    seize(\"funcionando\") %>%\n    timeout(vida) %>%\n    release(\"funcionando\") %>%\n    seize(\"reparando\") %>%\n    timeout(reparacion) %>%\n    release(\"reparando\") %>%    \n    rollback(6)\n\n  # Configuración del sistema \n  simmer() %>%\n    add_resource(\"funcionando\", capacity = Inf) %>%\n    add_resource(\"reparando\", capacity = capacidad, queue_size = Inf) %>%\n    add_generator(\"sistema\", maquina, at(0, 0, 0, 0)) %>%\n    run(until = t)     \n}\nt=72 # 3 días\nlambda=1/72; mu=1/2\ncapacidad=2 # nº reparadores\n### Simulación del sistema\nmaquinas <- mantenimiento(t, lambda,mu, capacidad)\n### Salidas del sistema\nmaquinas.df.res <- get_mon_resources(maquinas)\nhead(maquinas.df.res, 10)##       resource     time server queue capacity queue_size system limit replication\n## 1  funcionando  0.00000      1     0      Inf        Inf      1   Inf           1\n## 2  funcionando  0.00000      2     0      Inf        Inf      2   Inf           1\n## 3  funcionando  0.00000      3     0      Inf        Inf      3   Inf           1\n## 4  funcionando  0.00000      4     0      Inf        Inf      4   Inf           1\n## 5  funcionando 39.64840      3     0      Inf        Inf      3   Inf           1\n## 6    reparando 39.64840      1     0        2        Inf      1   Inf           1\n## 7    reparando 40.91384      0     0        2        Inf      0   Inf           1\n## 8  funcionando 40.91384      4     0      Inf        Inf      4   Inf           1\n## 9  funcionando 63.84362      3     0      Inf        Inf      3   Inf           1\n## 10   reparando 63.84362      1     0        2        Inf      1   Inf           1\n# última iteración del sistema\ntail(maquinas.df.res, 1)##       resource     time server queue capacity queue_size system limit replication\n## 12 funcionando 65.62617      4     0      Inf        Inf      4   Inf           1\n### Seleccionamos todos los recursos cuando las máquinas están funcionando\nmaquinas.df.sel <- maquinas.df.res %>%\n  subset(resource == \"funcionando\")\n### Calculamos los tiempos de funcionamiento\ndeltas_4 <- diff(maquinas.df.sel$time)\n### Seleccionamos cuando las 4 máquinas están activas\nboth_working_4 <- which(maquinas.df.sel$system == 4)\nt_both_working_4 <- deltas_4[both_working_4]\n### Caculamos la proporción de tiempo\nres<-sum(t_both_working_4, na.rm=TRUE) / max(maquinas.df.sel$time)\n# Réplicas del sistema\nreplicas <- 500\nenvs <- lapply(1:replicas, function(i){\n  maquinas <- mantenimiento(72, 1/2, 1/72, 2)\n})\n\n# almacenamos análisis de llegadas del sistema\nsimresources<-as_tibble(get_mon_resources(envs))\n## funciones para calcular cantidades de interés\nmaquinasON <- vector()\npropTimeON <- vector()\nfor (i in 1:500)\n{\n  datos <- simresources[simresources$replication == i,]\n  # máquinas en funcionamiento\n  maquinasON[i] <- tail(datos, 1)$server\n  # Proporción de tiempo\n  maquinas.df.sel <- datos %>%\n  subset(resource == \"funcionando\")\n  ### Calculamos los tiempos de funcionamiento\n  deltas_4 <- diff(maquinas.df.sel$time)\n  ### Seleccionamos cuando las 4 máquinas están activas\n  both_working_4 <- which(maquinas.df.sel$system == 4)\n  t_both_working_4 <- deltas_4[both_working_4]\n  ### Caculamos la proporción de tiempo\n  propTimeON[i]<-round(100*sum(t_both_working_4, na.rm=TRUE) / max(maquinas.df.sel$time), 2)\n}"},{"path":"CMTC.html","id":"central-telefónica","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.4.3 Central telefónica","text":"Una centralita telefónica puede atender \\(K\\) llamadas la vez en un momento dado. Las llamadas llegan según un proceso de Poisson con tasa \\(\\lambda\\). Si la centralita ya está atendiendo \\(K\\) llamadas cuando llega una nueva llamada, ésta se pierde. Si una llamada es aceptada, dura un tiempo \\(Exp(\\mu)\\) y luego termina. Todas las llamadas son independientes entre sí. Sea \\(X(t)\\) el número de llamadas que la centralita gestiona en el momento \\(t\\).El proceso \\(\\{X(t); t \\geq 0\\}\\) es una CMTC con espacio de estados \\(S = \\{0, 1, 2,...,K\\}\\) de forma que:En el estado \\(\\), con \\(0 \\leq \\leq K-1\\) la llegada de una llamada desencadena una transición al estado \\(+1\\) con tasa \\(\\lambda\\) (\\(r_{+1} = \\lambda\\)), mientras que en el estado \\(K\\) se pueden recibir llamadas.En el estado \\(\\), con \\(0 \\leq \\leq K-1\\) la llegada de una llamada desencadena una transición al estado \\(+1\\) con tasa \\(\\lambda\\) (\\(r_{+1} = \\lambda\\)), mientras que en el estado \\(K\\) se pueden recibir llamadas.En el estado \\(\\), con \\(1 \\leq \\leq K\\) cualquiera de las llamadas \\(\\) puede completarse y desancedar una transición al estado \\(-1\\). La tasa de transición es \\(r_{-1} = \\mu\\). En el estado 0 hay salidas.En el estado \\(\\), con \\(1 \\leq \\leq K\\) cualquiera de las llamadas \\(\\) puede completarse y desancedar una transición al estado \\(-1\\). La tasa de transición es \\(r_{-1} = \\mu\\). En el estado 0 hay salidas.El sistema \\(\\{X(t); t \\geq 0\\}\\) es un proceso de nacimiento y muerte con:\\[\\lambda_i = \\lambda, \\quad 0 \\leq \\leq K-1\\] \\[\\mu_i = \\mu, \\quad 0 \\leq \\leq K\\] que como veremos más adelante se denomina cola \\(M/M/K/K\\), es decir, llegadas y servicios exponenciales con \\(K\\) servidores y de capacidad \\(K\\).La función de simmer para estudiar este sistema viene dada por:","code":"\n# Sistema\n#################################################\ncola.MMKK <- function(t, lambda, mu, servidores, usuarios)\n{\n  # lambda: tasa de llegadas\n  # mu: tasa de servicio\n  # servidores: número de servidores\n  # usuarios: capacidad total del sistema\n  cola <- usuarios - servidores\n  \n  servicio <- trajectory() %>%\n    seize(\"atendiendo\", amount = 1) %>%              \n    timeout(function() rexp(1, mu)) %>%   \n    release(\"atendiendo\", amount = 1)               \n\n  # Configuración del sistema \n  #################################################\n  simmer() %>%\n    add_resource(\"atendiendo\", capacity = servidores, queue_size = cola) %>%           \n    add_generator(\"llegada\", servicio, function() rexp(1, lambda)) %>% \n    run(until = t)     \n}"},{"path":"CMTC.html","id":"call-center","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.4.4 Call Center","text":"El sistema de reservas telefónicas de una aerolínea es un “call center” formado por \\(s\\) empleados de reservas llamados agentes. Una llamada entrante para una reserva es atendida por un agente si hay uno disponible; de lo contrario, la persona que llama es puesta en espera. El sistema puede poner en espera un máximo de \\(H\\) personas. Cuando un agente está disponible, las llamadas en espera se atienden por orden de llegada. Cuando todos los agentes están ocupados y hay \\(H\\) llamadas en espera, cualquier llamada adicional recibe una señal de ocupado y se pierden permanentemente. Sea \\(X(t)\\) la varaible aleatoria que registra el número de llamadas en el sistema, las atendidas por los agentes más las que están en espera, en el momento \\(t\\) . Si las llamadas recibidas se comportan como un \\(PP(\\lambda)\\) y los tiempos de procesamiento de las llamadas son variables aleatorias iid \\(Exp(\\mu)\\), el sistema \\(\\{X(t); t \\geq 0\\}\\) es una CMTC, con espacio de estados \\(S = \\{0, 1, 2,...,K\\}\\) donde \\(K = s + H\\).Se puede demostrar fácilmente que este sistema es un proceso de nacimiento y muerte con tasas:\\[\\lambda_i = \\lambda, \\quad 0 \\leq \\leq K-1\\] \\[\\mu_i = min(, s)\\mu, \\quad 0 \\leq \\leq K\\] que en la terminologia habitual se denomina cola \\(M/M/s/K\\). Para simular este proceso podemos utilizar la función del ejemplo anterior.","code":""},{"path":"CMTC.html","id":"CMTCE","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.5 Otros tipos de sistemas","text":"Presentamos en este punto otros sistemas que se corresponden con procesos de nacimiento y muerte, pero que son muy habituales en el mundo real.","code":""},{"path":"CMTC.html","id":"gestión-de-inventarios","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.5.1 Gestión de inventarios","text":"Una tienda minorista gestiona el inventario de un tipo de producto, que denominamos \\(P\\), de la forma siguiente. Cuando el número de elementos de \\(P\\) disminuye un número fijo \\(l\\), se hace un pedido al fabricante de \\(m\\) repuestos de \\(P\\). El pedido tarda un tiempo aleatorio en ser entregado al minorista. Si el inventario es como máximo \\(l\\) cuando se entrega un pedido (incluido el pedido recién entregado), se realiza inmediatamente otro pedido de \\(m\\) artículos. Supongamos que que los plazos de entrega son variables aleatorias iid \\(Exp(\\lambda)\\) y que la demanda se produce según un \\(PP(\\mu)\\). Las demandas que pueden ser satisfechas inmediatamente se pierden.Sea \\(X(t)\\) el número de elementos de \\(P\\) en stock en el momento \\(t\\). Obsérvese que el número máximo de elemntos de \\(P\\) en stock es \\(K = l + m\\), lo que ocurre si el pedido se entrega antes de que se produzca la siguiente demanda. El espacio de estados es, pues, \\(S = \\{0, 1, 2,...,K\\}\\). En el estado \\(0\\), las demandas se pierden, y el stock salta \\(m\\) cuando se entrega el pedido pendiente actual (lo que ocurre la tasa \\(\\lambda\\)). Por tanto, tenemos \\(r_{0m} = \\lambda\\). En el estado \\(\\) \\((1 \\leq \\leq l)\\) hay un pedido pendiente. El estado cambia \\(-1\\) si se produce una demanda (lo que ocurre la tasa \\(\\mu\\)) y \\(+ m\\) si se entrega el pedido. Por lo tanto, tenemos \\(r_{+m} = \\lambda\\) y \\(r_{-1} = \\mu\\). Finalmente, si \\(X(t) = \\) (\\(l + 1 \\leq \\ K\\)), hay pedidos pendientes, y la única transición es de \\(\\) \\(- 1\\), y eso ocurre cuando se produce una demanda. Por lo tanto, \\(r_{-1} = \\mu\\). El proceso \\(X(t), t \\geq 0\\) definidido de esta forma es una CMTC.Consulta sobre modelo simmer para inventarios (https://stackoverflow.com/questions/51680140/immediate-inventory-restock--r-simmer)","code":""},{"path":"CMTC.html","id":"proceso-de-fabricación","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.5.2 Proceso de fabricación","text":"Un proceso de de fabricación sencilla consiste en una sola máquina que puede estar encendida o apagada. Si la máquina está encendida, produce artículos según un proceso de Poisson con tasa \\(\\lambda\\). La demanda de artículos llega según un \\(PP(\\mu)\\) La máquina se controla de la siguiente manera. Si el número de artículos en stock alcanza un número máximo \\(K\\) (la capacidad de almacenamiento), la máquina se apaga. La máquina se enciende cuando el número de artículos en stock disminuye hasta un nivel preestablecido \\(l < K\\). Si la variable aleatoria \\(X(t)\\) nos indica el número de artículos en stock en el momento \\(t\\), el proceso \\(X(t), t \\geq 0\\) es una CMTC ya que sabemos si la máquina está encendida o apagada si \\(l < X(t) < K\\). Si se considera \\(Y(t)\\) como el estado en el que se encuentra la máquina en el momento \\(t\\), de forma que un \\(1\\) indica encendido y un \\(0\\) que está apagada, entonces el proceso \\(\\{X(t), Y(t), t\\geq 0\\}\\) es una CMTC con espacio de estados:\\[S = \\{(, 1), 0 \\leq < K\\} \\cup \\{(, 0), l < \\leq K\\}\\]Hay que tener en cuenta que la máquina siempre está encendida si el número de elementos es \\(l\\) o menos. Por lo tanto, necesitamos los estados \\(\\{(, 0), 0 \\leq \\leq l\\}\\). El análisis habitual de los eventos desencadenantes arroja las siguientes tasas de transición:\\[r_{(, 1)(+1, 1)} = \\lambda, \\quad 0 \\leq < K-1,\\]\\[r_{(K-1, 1)(K, 0)} = \\lambda, \\] \\[r_{(, 1)(-1, 1)} = \\mu, \\quad 1\\leq \\leq K-1,\\]\\[r_{(, 0)(-1, 0)} = \\mu, \\quad l+1 < \\leq K,\\]\\[r_{(l+1, 0)(l, 1)} = \\mu.\\]","code":""},{"path":"CMTC.html","id":"CMTCF","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.6 Probabilidades de transición","text":"El aspecto funcdamental para estudiar el comportamiento de cualquier CMTC es la obtención y análisis de las probabilidades de transición entre los estados del procso partir de la matriz de tasas obtenida en puntos anteriores. Aunque haremos un desarrollo teórico de este rporblema, veremos que es necesario un algoritmo de computación para obtener dichas probabilidades.Sea \\(X(t), t \\geq 0\\) una CMTC con espacio de estados \\(S = \\{1,2,...,N\\}\\) y con matriz de tasas \\(R = [r_{ij}]\\). Si asumimos que la distribución de probabilidad en el estado incial, \\(X(0)\\) es conocida, entonces tenemos que:\\[P(X(t) = j) = \\sum_{=1}^N P(X(t) = j | X_0 = )P(X_0 = ), \\quad 1 \\leq j \\leq N.\\] Es necesario obtener \\(P(X(t) = j | X_0 = ) = p_{ij}(t)\\) para obtener la función de distribución de probabilidad de \\(X(t)\\). Antes de ver como obtener dichas probabildiades introducimos la notación necesaria.ya hemos visto antes que una CMTC permance un tiempo \\(Exp(r_i)\\) en el estado \\(\\) con \\(r_i = \\sum_{j=1}^N r_{ij}\\) y, si \\(r_i > 0\\) entonces pasamos al estado \\(j\\) con probabilidad \\(p_{ij} = r_{ij}/r_i\\). Asumiendo que existe un número finito \\(r\\) que satisface:\\[r \\geq max(r_i), \\quad 1\\leq \\leq N\\] podemos definir la matriz \\(\\hat{P} = [\\hat{p}_{ij}]\\) como:que es una matriz estocástica.Teorema 4.2  La matriz de tarnsición de probabilidades, \\(P\\), de una CMTC viene dada por:\\[P(t) = \\sum_{k=0}^{\\infty} e^{-rt}\\frac{(rt)^k}{k!} \\hat{P}^k\\]Esta forma de obtener \\(P\\) se denomina método de uniformización, y proporciona un método numérico para obtener las probabilidades de transición deseadas, sin más que usar los \\(m\\) primeros términos de la serie infinita definida. Para asegurar la convergencia de dichas probabilidades se usan como reglas habituales:\\[m \\approx max\\{rt + r\\sqrt{rt}, 20\\},\\]y\\[r = max(r_i), \\quad 1\\leq \\leq N,\\] aunque en algunos casos resulta más conveniente utilizar \\(r = sum_{=1}^N r_i\\). De hecho, veremos que ambos resultados son muy similares y podremos usar la suma en todos los casos.Algoritmo para obtener \\(P\\):Fijar \\(R\\), \\(t\\), y \\(0 < \\epsilon < 1\\). Por defecto fijamos \\(\\epsilon = 0.00001\\).Obtener r.Calcular \\(\\hat{P}\\).Calcular \\(= \\hat{P}\\); \\(c = e^{rt}\\); \\(B = e^{rt}\\); \\(sum = c\\); \\(k=1.\\)Mientras que \\(sum < 1-\\epsilon\\), calcular:\\[c = c*(rt)/k; \\quad B = B + cA; \\quad = \\hat{P}\\] \\[sum = sum + c; \\quad k = k + 1\\] Al finalizar la matriz \\(B\\) es una aproximación de \\(P(t)\\) con error inferior \\(\\epsilon\\).En realidad en nuestro algoritmo añadiremos un parámetro extra para indicar como se debe calcular el valor de \\(r\\), bien como el máximo los elementos por filas de \\(R\\) o como la suma de todos ellos.Veamos un ejemplo donde la matriz de tasas viene dada por:Si estamos interesados en las probabilidades de transición entre estados cuando han transcurrido 2 unidades de tiempo podemos calcular (ambas versiones):Ambas matrices proporciona un resultado prácticamente idéntico. Estas matrices nos permiten obtener las probabildiades de pasar del estado 1 cualquiera de los otros estados en dos unidades de tiempo, sin más que tomar los elementos de la fila 1 de la matriz obtenida.¿Cómo interpretamos esas probabilidades?Veamos ahora la aplicación de este algoritmo alguno de los ejemplos con los que hemos ido trabajando en esta unidad.Ejemplo 4.6  Para los datos correspondientes al cajero bancario estamos interesados en conocer la probabilidad de que después de 50 minutos de funcionamiento el sistema este completamente ocupado (1 usuario atendido y tres en cola), cuando partímos de \\(0\\) clientes en el sistema (\\(p_{04}(4)\\)). La matriz de tasas viene dada por:Obtenemos la distribución de probabilidad asociada al estado 4 para \\(t = 50\\):La probabilidad de interés es 0.3741 (\\(p_{15}(50)\\)) lo que demuestra que es factible que el sistema llegue al estado 4 partiendo del estado 0 después de 4 horas.Aunque el cálculo teórico es muy preciso hay situaciones donde los sistemas reales con los que estamos trabajndo hacen bastante costoso obtener la matriz \\(R\\), y resulta más sencillo tratar de aproximar las probabilidades de transición mediante simulación. Para ello basta con replicar el sistema de simulación un número los suficientemente grande ya aproximar mediante Monte-Carlo. En este caso deberíamos obtner el estado dle sistema después de 50 minutos y aproximar la probabilidad como el número de veces que se alcanza el estado de interés dividido por las réplicas realizadas. la precisión de esta aproximación depende en gran medida del número de réplicas.Podemos ver que la aproximación obtenida es similar (hasta el segundo decimal) la obtneida partir de la matriz \\(R\\) del proceso. Simulando podemos aproximar las cantidades de interés siempre que el sistema empieza desde el punto de interés.Para practicar la obtención de la matriz de probabilidades de transición puedes resolver los ejercicios B-1 B-4 de la colección al final de la unidad.","code":"\nmatriz.prob.trans<- function(Rmat, ts, cal)\n{\n  # Algortimo de uniformización para obtener P(t)\n  ################################################\n  \n  # Parámetros de la función\n  # Rmat: matriz de tasas\n  # ts: instante de tiempo\n  # epsilon: error en la aproximación\n  # cal: forms de obtener r con dos valores 1 = máximo, 2 = suma\n  epsilon <- 1e-05\n  # Paso 2. Calculo de r\n  ris <- apply(Rmat, 1, sum)\n  ifelse(cal == 1, rlimit <- max(ris), rlimit <- sum(Rmat))\n  # Paso 3. Calculo de hat(P)\n  hatP <- Rmat/rlimit\n  diag(hatP) <- 1 - ris/rlimit\n  # Paso 4. Calculo de matrices y vectores accesorios\n  rts <- rlimit*ts\n  A <- hatP\n  c <- exp(-rts)\n  B <- c*diag(nrow(Rmat))\n  suma <- c\n  k <- 1\n  # Bucle simulación\n  cota <- 1- epsilon\n  while(suma < cota)\n  {\n    c <- c*rts/k\n    B <- B + c*A\n    A <- A%*%hatP\n    suma <- suma + c\n    k <- k + 1\n  }\n  return(round(B, 4))\n}\nR = matrix(c(0, 2, 3, 0, 4, 0, 2, 0, 0, 2, 0, 2, 1, 0, 3, 0), byrow = TRUE, ncol = 4)\nPmat1<-matriz.prob.trans(R, 2, 1); Pmat1##        [,1]   [,2] [,3]   [,4]\n## [1,] 0.2001 0.2001  0.4 0.1998\n## [2,] 0.2002 0.2001  0.4 0.1997\n## [3,] 0.1999 0.2000  0.4 0.2001\n## [4,] 0.1998 0.1999  0.4 0.2003\nPmat2<-matriz.prob.trans(R, 2, 2); Pmat2##        [,1]   [,2] [,3]   [,4]\n## [1,] 0.2001 0.2001  0.4 0.1998\n## [2,] 0.2002 0.2001  0.4 0.1997\n## [3,] 0.1999 0.2000  0.4 0.2001\n## [4,] 0.1998 0.1999  0.4 0.2003\nPmat1[1,]; Pmat2[1,]## [1] 0.2001 0.2001 0.4000 0.1998## [1] 0.2001 0.2001 0.4000 0.1998\nestados <- c(0, 1, 2, 3, 4)\nnestados <- length(estados)\n\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nlambda <- 15/60\nmu <- 1/6 \n\nR[1,2] <- lambda \nR[2,1] <- mu \nR[2,3] <- lambda \nR[3,2] <- mu \nR[3,4] <- lambda \nR[4,3] <- mu \nR[4,5] <- lambda\nR[5,4] <- mu\n# Matriz de probabilidades de transición\nPmat<-matriz.prob.trans(R, 50, 2)\nPmat##        [,1]   [,2]   [,3]   [,4]   [,5]\n## [1,] 0.0812 0.1190 0.1730 0.2528 0.3741\n## [2,] 0.0793 0.1172 0.1722 0.2539 0.3775\n## [3,] 0.0769 0.1148 0.1711 0.2553 0.3819\n## [4,] 0.0749 0.1128 0.1702 0.2565 0.3856\n## [5,] 0.0739 0.1118 0.1698 0.2571 0.3874\nreplicas <- 2500\nenvs <- lapply(1:replicas, function(i) {\n    repcajero <- cola.MM1K(50, 15/60, 1/6, 1, 4)\n})\n# almacenamos análisis de recursos del sistema\nsimresource <- as_tibble(get_mon_resources(envs))\n# Almacenamos el estado final de la cola en el último instante del sistema\nsalida <- simresource %>%\n  group_by(replication) %>%\n  summarise(estado = last(system))\n# Estimamos la probabilidad\nround(table(salida$estado)/replicas, 3)## \n##     0     1     2     3     4 \n## 0.089 0.122 0.162 0.251 0.376"},{"path":"CMTC.html","id":"CMTCG","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.7 Análisis de tiempos de ocupación","text":"En esta sección, nos concentramos en el análisis de los tiempos de ocupación de un estado determinado en un intervalo de tiempo finito \\([0, T]\\), es decir, la duración esperada de tiempo que el sistema pasa en ese estado. Como ocurre con las probabildiades de trasnsición presentamos un algortimo para obtener las cantidades de interés partir de la matriz de tasas, y veremos como la simulación del proceso nos puede ayudar dar respuesta las mismas cuestiones.Teorema 4.3  Si \\(P(t)\\) es la matriz de transiciones de probabilidad del proceso \\(\\{X(t), t \\geq 0\\}\\) con espacio de estados \\(S = \\{1, 2,...,N\\}\\), se define la cantidad \\(m_{ij}(T)\\) como el tiempo de ocupación del estado \\(j\\) hasta el tiempo \\(T\\) partiendo del estado \\(\\) como:\\[m_{ij}(T) = \\int_0^T p_{ij}(t)dt, \\quad 1 \\leq , j \\leq N.\\]Cuando tenemos formas explicitas para cada uno de los elemntos de \\(P(t)\\) (este es el caso para la mayoría de los sistemas de colas de espera) este probelma se puede resolver teóricamente, pero en la mayoria de ocasiones es necesario un algoritmo de computación para aproximar estas cantidades. continuación se presenta el algoritmo necesario, pero antes veamos la aproximación mediante series de la matriz \\(M(T) = [m_{ij}(t)]\\).Teorema 4.4  Si \\(Y\\) es una variable aletoria Poisson de parámetro \\(r*t\\) entonces:\\[M(T) = \\frac{1}{r} \\sum_{k = 0}^{\\infty} P(Y > k) \\hat{P}^k, \\quad T \\geq 0.\\]Algoritmo para obtener \\(M(T)\\):Fijar \\(R\\), \\(T\\), y \\(0 < \\epsilon < 1\\). Por defecto fijamos \\(\\epsilon = 0.00001\\).Obtener r.Calcular \\(\\hat{P}\\).Calcular \\(= \\hat{P}\\); \\(k = 0\\)Calcular \\(yek = exp(-r*t)\\), \\(ygk = 1 - yek\\), \\(suma = ygk\\)Calcular \\(B = ygk * \\)Mientras que \\(suma/r < T-\\epsilon\\), calcular:\\[k = k + 1; \\quad yek = yek*(rT)/k; \\quad ygk = ygk - yek\\] \\[B = B + ygk*; \\quad = \\hat{P}; \\quad suma = suma + ygk\\] Al finalizar la matriz \\(B/r\\) es una aproximación de \\(M(T)\\) con error inferior \\(\\epsilon\\).En realidad en nuestro algoritmo añadiremos un parámetro extra para indicar como se debe calcular el valor de \\(r\\), bien como el máximo los elementos por filas de \\(R\\) o como la suma de todos ellos.Ejemplo 4.7  Retomamdo el sistema sobre el tiempo de vida de una máquina descrito en el ejemplo 4.5, supongamos que el tiempo esperado hasta que falla una máquina son 10 días, mientras que el tiempo esperado de reparación es de 1 día. Si la máquina funciona el primer día de enero ¿cuál es el tiempo total esperado de funcionamiento de la máquina al finalizar el mes de enero? Dado que el proceso sólo tiene espacio de estados \\(S = \\{0, 1\\}\\), la cantidad de interés es \\(m_{11}(31)\\). Con \\(\\lambda = 1\\) y \\(\\mu = 0.1\\), la matriz de tasas del proceso viene dada por:Obtenemos ahora la matriz \\(M(31)\\) correspondiente la cantidad de interés, teniendo en cuenta que partimos de que la máquina está en marcha (primera fila de \\(M\\)) al inicio:Por tanto, el tiempo esperado de funcionamiento es de 28.26 días, mientras que el tiempo de reparación es de \\(2.74\\) días. Utilizando el simulador del proceso podemos ver que el resultado obtenido es similar.Para practicar este apartado puedes resolver los ejercicios B-5 B-8 de la colección al final de la unidad.","code":"\ntiempos.ocupacion<- function(Rmat, Ts, cal)\n{\n  # Algortimo de uniformización para obtener M(T)\n  ################################################\n  \n  # Parámetros de la función\n  # Rmat: matriz de tasas\n  # ts: instante de tiempo\n  # epsilon: error en la aproximación\n  # cal: forms de obtener r con dos valores 1 = máximo, 2 = suma\n  epsilon <- 1e-05\n  # Paso 2. Calculo de r\n  ris <- apply(Rmat, 1, sum)\n  ifelse(cal == 1, rlimit <- max(ris), rlimit <- sum(Rmat))\n  # Paso 3. Calculo de hat(P)\n  hatP <- Rmat/rlimit\n  diag(hatP) <- 1 - ris/rlimit\n  # Paso 4. \n  k <- 0\n  A <- hatP\n  # Paso 5.\n  yek <- exp(-1*rlimit*Ts)\n  ygk <- 1 - yek\n  suma <- ygk\n  # Paso 6.\n  B <- ygk*diag(nrow(Rmat))\n  # Bucle simulación\n  cota <- Ts- epsilon\n  while(suma/rlimit < cota)\n  {\n    k <- k + 1\n    yek <- yek*(rlimit*Ts)/k\n    ygk <- ygk - yek\n    B <- B + ygk*A\n    A <- A%*%hatP\n    suma <- suma + ygk\n  }\n  return(round(B/rlimit, 4))\n}\nnestados <- 2\nlambda <- 1\nmu <- 0.1\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\n\nR[1,2] <- lambda \nR[2,1] <- mu \ntiempos.ocupacion(R, 31, 1)##        [,1]    [,2]\n## [1,] 3.6446 27.3554\n## [2,] 2.7355 28.2645\n# Réplicas del proceso\nreplicas <- 2500\nenvs <- lapply(1:replicas, function(i) {\n    maquina <- sistema.1m(31, 1, 1/10)\n})\n# almacenamos análisis de llegadas del sistema\nsimarrivals <- as_tibble(get_mon_arrivals(envs))\n# Almacenamos el estado final de la cola en el último instante del sistema\nsimarrivals %>%\n  mutate(tOFF = end_time - start_time) %>%\n  group_by(replication) %>%\n  summarise(totalOFF = sum(tOFF)) %>%\n  ungroup() %>%\n  summarise(mOFF = mean(totalOFF), mON = 31 - mOFF)## # A tibble: 1 × 2\n##    mOFF   mON\n##   <dbl> <dbl>\n## 1  3.33  27.7"},{"path":"CMTC.html","id":"CMTCH","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.8 Comportamiento límite del proceso","text":"En el análisis del comportamiento límite de una CMTD analizamos la distribución de probabilidad límite, la distribución estacionaria, y la distribución de los tiempos de ocupación. En el caso de las CMTC estudiaremos cantidades similares. En primer lugar analizaremos las probabilidades límite:\\[\\lim_{t \\rightarrow \\infty} P(X(t) = j, \\quad 1 \\leq j \\leq N\\]Si existen dichos límites el conjunto \\(p = [p_1, p_2,...,p_N]\\) se conoce como distribución límite de la CMTC.Teorema 4.5  Una CMTC \\(\\{X(t), t \\geq 0\\}\\) irreducible con matriz de tasas \\(R\\) tiene una única distribución límite \\(p = [p_1, p_2,...,p_N]\\), que se puede obtener como solución de las ecuaciones de balance:\\[p_j r_j = \\sum_{=1}^N p_ir_{ij}, \\quad 1 \\leq j \\leq N\\] \\[\\sum_{=1}^N p_i = 1\\]En este sentido podemos interpretar \\(p_jr_j\\) como la tasa de la CMTC cuanod deja el estado \\(j\\), mientras que \\(p_jr_{ij}\\) es la tasa de entrada de la CMTC estado \\(j\\) desde el estado \\(\\).Teorema 4.6  Dado una CMTC \\(\\{X(t), t \\geq 0\\}\\) irreducible con distribución límite \\(p\\), entonces la distribución estacionaria de la CMTC viene dada por \\(p\\), es decir:\\[P(X(0) = j) = p_j \\text{ para } 1 \\leq j leq N\\] \\(P(X(t) = j) = p_j \\text{ para } 1 \\leq j leq N, t \\geq 0\\)$partir de la distribución límite resulta posible obtener la distribución de ocupación de la CMTC.Teorema 4.7  Sea \\(m_{ij}(T)\\) el tiempo total esperado que la cadena permanece en el estado hata el tiempo \\(T\\) para una CMTC irreducible que comienza en el estado \\(\\). Entonces:\\[\\lim_{T \\rightarrow \\infty} \\frac{m_{ij}(T)}{T} = p_j\\]continuación se presenta la solución de la distribución límite para los procesos de nacimiento y muerte. En el resto de sistemas se deberan plantear las ecuaciones de balance y resorverlas. En ambas situaciones presentamos las correspondientes funciones que nos permiten obtener las cantidades de interés.Sea \\(\\{X(t), t \\geq 0\\}\\) un proceso de nacimiento y muerte con espacio de estados \\(S = \\{0, 1,...,K\\}\\), y tasas de nacimiento \\(\\{\\lambda_i, 0 \\leq < K\\}\\) y tasas de muerte \\(\\{\\mu_i, 1 \\leq \\leq K\\}\\). Entonces la CMTC así definida es irreducible y tiene una única distribuión límite con:\\[p_i = \\frac{\\rho_i}{\\sum_{j = 0}^K \\rho_j}, \\quad 0 \\leq \\leq K,\\] donde \\(\\rho_0 = 1,\\) y\\[\\rho_i = \\frac{\\prod_{j=0}^{-1}\\lambda_j}{\\prod_{j=1}^{}\\mu_j}, \\quad 1 \\leq \\leq K,\\]Antes de comenzar con los ejemplos vamos crear una función que permita obtener la distibución límite y la distribución de ocupación para los procesos de nacimiento y muerte.Ejemplo 4.8  Retomamdo el sistema descrito en el ejemplo 4.5, supongamos que el tiempo esperado hasta que falla una máquina son 10 días, mientras que el tiempo esperado de reparación es de 1 día. Si la máquina funciona el primer día de enero ¿cuál es la distribución límite del proceso?Este sistema es un proceso de nacimiento y muerte donde podemos aplicar la función anterior para obtener la distribución límite con dos estados y tasas \\(\\lambda = 1\\), \\(\\mu = 1/10\\) (expresadas en periodos de diez días).El comportamiento límite nos indica que la máquina está el 90.9% del tiempo en funcionamiento, mientras que sólo el 9.1% en reparación. Para un periodo de un año tendríamos que los díass esperados de reparación y funcionamiento son:Veamos ahora como obtener la distribución límite para procesos más generales. Definimos una función que nos permite obtener la distribución límite de un CMTC partir de cualquier matriz de tasas resolviendo las ecuaciones de balance.Ejemplo 4.9  Para el sistema de proceso de fabricación se está interesado en conocer cuando la máquina estará parada largo plazo. Dado que el espacio de estados es \\(S = \\{1, 2,...,6\\}.\\) la máquina está aprada cuando nos encontramos en los estados \\(5 = (4, 0)\\) y \\(6 = (3, 0)\\). partir de la información del sistema podemos obtener la distribución límite del proceso, pero en este caso como se trata de un proceso de nacimiento y muerte debemos plantear las ecuaciones de balance, partir de la matriz de tasas, y resolver el sistema numéricamente.Resolvemos las ecuaciones de balance para el sistema del proceso de fabricación. Definimos la matriz de tasas y ejecutamos la función anterior para obtener las probabilidades límite del proceso:La probabilidad de interés viene dada por 0.2987, de forma que la máquina permancerá apagada sobre el 30% del tiempo.Para practicar este apartado puedes resolver los ejercicios B-9 B-12 de la colección al final de la unidad.","code":"\n# Obtención de distribuciones límite \ndistr.lim.nm <- function(estados, lambdas, mus)\n{\n  # Parámetros de la función\n  # ========================\n  # estados: número de estados del sistema\n  # lambdas: vector de tasas de nacimiento\n  # mus: vector de tasas de muerte\n  \n  # definimos vector de rho\n  rhos <- rep(1, estados)\n  # calculamos productos acumlados para lambda y mu\n  prl <- cumprod(lambdas)\n  prm <- cumprod(mus)\n  # rellenamos rho con los productos acumulados\n  rhos[2:estados] <- prl/prm\n  # suma de rhos\n  sumarhos <- sum(rhos)\n  # vector de probabilidades\n  ps <- rhos/sumarhos\n  return(ps)\n}\nprobs <- distr.lim.nm(2, 1, 0.1)\nprobs## [1] 0.09090909 0.90909091\n365*probs## [1]  33.18182 331.81818\n# Función para la resolución numérica de las ecuaciones de balance\ndistr.lim.general<-function(Rmat)\n{\n  # Parámetros de la función\n  #=========================\n  # Rmat: matriz de tasas del sistema\n  \n  # número de estados del sistema\n  estados <- nrow(Rmat)\n  # Calculamos r_i y lo colocamos en formato matriz\n  sumarows <- diag(apply(Rmat, 1, sum), estados)\n  # Matriz de coeficientes del sistema de ecauciones de balance\n  A <- t(R)-sumarows\n  # Completamos la matriz añadiendo la restricción de suma de p`s iagual a 1\n  A <- rbind(A, rep(1, estados))\n  # Vector de términos independientes del sistema\n  CS <- c(rep(0, estados), 1)\n  # Resolcuión del sistema\n  ps <- qr.solve(A, CS)\n  return(ps)\n}\n# Estados del sistema\nnestados <- 6\n# Matriz de tasas\nlambda <- 6\nmu <- 5\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nR[1,2] <- lambda \nR[2,1] <- mu\nR[2,3] <- lambda \nR[3,2] <- mu\nR[3,4] <- lambda\nR[4,3] <- mu\nR[4,5] <- lambda\nR[5,6] <- mu\nR[6,3] <- mu\n# Resolución  de las ecuaciones de balance\nps <- distr.lim.general(R)\nps## [1] 0.1584649 0.1901579 0.2281895 0.1244670 0.1493604 0.1493604"},{"path":"CMTC.html","id":"CMTCI","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.9 Análisis de costes","text":"En este punto vemos como podemos introducir costes en las CMTC y los procedimientos numéricos necesarios para su análisis. En todo el punto consideramos \\(\\{X(t), t \\geq 0\\}\\) una CMTC con espacio de estados \\(S = \\{1, 2,...,N\\}\\) y matriz de tasas \\(R\\). Además, siempre que la CMTC está en el estado \\(\\) se incurre en una tasa de coste \\(c(), 1 \\leq \\leq N\\).","code":""},{"path":"CMTC.html","id":"coste-total-esperado-a-tiempo-t","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.9.1 Coste total esperado a tiempo \\(T\\)","text":"En esta subsección, estudiamos el CTE, el coste total esperado hasta un tiempo finito \\(T\\), llamado horizonte. Nótese que la tasa de coste en el tiempo \\(t\\) es \\(c(X(t))\\). Por lo tanto, el coste total hasta el tiempo \\(T\\) viene dado por:\\[\\int_0^T c(X(t))dt.\\]De esta forma el coste esprado total hasta el instante \\(T\\), empezando en el estado \\(\\), viene dado por:\\[g(, T) = E\\left( \\int_0^T c(X(t))dt \\mid X(0) = \\right), \\quad 1 \\leq \\leq N.\\]Teorema 4.8  Si \\(M(T) = [m_{ij}(T)]\\) es la matriz de ocupación entonces:\\[g(T) = M(T)c,\\]donde \\(c = [c(1), c(2),...,c(N-1), c(N)]'\\) y \\(g(T) = [g(1, T), g(2,T),..., g(N-1, T), g(N, T)]'.\\)Ejemplo 4.10  Para el sistema de mantenimiento de máquinas se conoce que que el beneficio por cada hora que la máquina está funcionanado es de 50 euros, mientras que el coste de que la máquina este apagada es de 15 euros por hora, al que hay que sumar 10 euros por cada hora de reparación. Estamos interesados en conocer el coste-beneficio de un periodo de 24 horas si al finalizar todas las máquinas están funcionando. Si \\(X(t)\\) es el número de máquinas funcionando en el instante \\(t\\), el espacio de estados para 4 máquinas viene dado por \\(S = \\{0, 1, 2, 3, 4\\}\\) y el vector de costes es:\\[\n\\begin{matrix}\nc(0) = & 0*50 - 4*15 - 2*10 = - 80,\\\\\nc(1) = & 1*50 - 3*15 - 2*10 = - 15,\\\\\nc(2) = & 2*50 - 2*15 - 2*10 = 50,\\\\\nc(3) = & 3*50 - 1*15 - 1*10 = 125,\\\\\nc(4) = & 4*50 - 0*15 - 0*10 = 200.\n\\end{matrix}\n\\] El vector de costes para el periodo de 24 horas viene dado por:\\[\ng(24) = M(24)*c =\n\\begin{bmatrix}\n3844.69 \\\\\n4116.57 \\\\\n4327.23 \\\\\n4474.96 \\\\\n4621.05\n\\end{bmatrix}\n\\]de forma que la cantidad de interés, \\(g(4, 24)\\) que corresponde con el elemento \\((5,1)\\) de la matriz, establece un beneficio de 4621.05 euros. Veamos como obtener esta cantidad utilizando el código correspondiente.El beneficio es 4621.058 euros.","code":"\n# Matriz de tasas\nnestados <- 5\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nlambda <- 1/2\nmu <- 1/72 \n\nR[1,2] <- 2*lambda \nR[2,1] <- mu \nR[2,3] <- 2*lambda \nR[3,2] <- 2*mu \nR[3,4] <- 2*lambda \nR[4,3] <- 3*mu \nR[4,5] <- lambda\nR[5,4] <- 4*mu\n# Matriz de ocupación\nmmat <- tiempos.ocupacion(R, 24, 1)\n# Vector de costes\ncostes <- matrix(c(-80, -15, 50, 125, 200), ncol = 1)\n# Matriz de beneficios\nbeneficios <- mmat%*%costes\nbeneficios##          [,1]\n## [1,] 3844.694\n## [2,] 4116.585\n## [3,] 4327.238\n## [4,] 4474.971\n## [5,] 4621.058"},{"path":"CMTC.html","id":"tasas-de-coste-a-largo-plazo","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.9.2 Tasas de coste a largo plazo","text":"Para el sistema de vida de una máquina, supongamos que se da el coste \\(C\\) del tiempo de inactividad. Queremos saber cuánto debe ser la tasa de ingresos durante el tiempo de actividad para que sea económicamente rentable operar la máquina. Si nos guiamos por el coste total, la respuesta dependerá de del horizonte de planificación \\(T\\) y también del estado inicial de la máquina. Una alternativa es calcular los ingresos netos largo plazo por unidad de tiempo para esta máquina e insistir en que sea positivo para la rentabilidad. Esta respuesta dependerá de \\(T\\), y, como veremos ni siquiera del estado inicial de la máquina. Por lo tanto, el cálculo de estos índices de costes o ingresos largo plazo es muy útil. En esta subsección mostraremos cómo calcular estas cantidades.Teorema 4.9  Sea \\(\\{X(t), t \\ geq 0\\}\\) una CMTC irreducible con estados \\(\\{1, 2,...,N\\}\\), distribución límite \\(p = [p_1, p_2,...,p_N]\\) y vector de costes \\(c = [c_1, c_2,..., c_N]\\), entonces la tasa de coste largo plazo viene dada por:\\[g() = \\sum_{j = 1}^N p_jc(j), \\quad 1 \\leq \\leq N\\]Ejemplo 4.11  Si consideramos el sistema de vida de una máquina supongamos que el coste por unidad de tiempo de que la máquina este apagado es \\(C\\). ¿Cuál es el la tasa mínima de ingresos \\(\\) necesaria durante el tiempo de actividad para alcanzar el punto de equilibrio largo plazo?Utilizando las tasas definidas anteriormente (\\(\\lambda = 1, \\mu = 0.1\\)), la distribución límite del sistema \\(p = [0.0909, 0.9091]\\), y el vector de costes \\(c =[-C, ]\\) para el espacio de estados \\(S = \\{0, 1\\}\\), la tasa de coste largo plazo por unidad de tiempo viene dada por la expresión:\\[ g = 0.9091*- 0.0909*C\\] de forma que para mantener el sistema en equilibrio, \\(g \\geq 0\\), se debe cumplir que:\\[\\geq \\frac{0.0909}{0.9091}*C = 0.099989*C \\approx 0.1*C\\]Así, los ingresos por unidad de tiempo superiores 0.1 veces por el coste de que la máquina este parada por unidad de tiempo resulta rentable. Si la empresa ha establecido un ingreso por hora de 50 euros, cuando sabe que el coste por hora es de 10 euros cuando está apagada, se desea saber si se cumple la condición de equilibrio para los costes.Ejemplo 4.12  Consideramos el sistema de la central telefónica donde la capacidad máxima de la centralita es de seis llamadas. Las llamadas llegan según un \\(PP\\) con una tasa de 4/minuto, y la duración media de cada llamada exponencial de media 2 minutos. En primer lugar deseamos conocer le beneficio por unidad de tiempo si la facturación por minuto de cada llamada es de 10 céntimos. En segundo lugar deseamos estimar la pérdida que sufrimos por todas las llamadas que pueden ser atendidas. Consideramos como \\(X(t)\\) al número de llamadas que están siendo atendidas en el instante \\(t\\).En primer lugar calculamos la distribución límite del proceso. Dado que se trata de un proceso de nacimeinto y muerte utilizamos la función correspondiente.Establecemos los beneficios \\(c() = 10i\\) y calculamos el global por unidad de tiempoEl beneficio por unidad de tiempo es de 48.82 céntimos. Si rechazaramos ninguna llamada tendríasmo que el beneficio por minuto sería de 80 céntimos, que se corresponde con la tasa de 4 llamadas por minuto, el beneficio de 10 céntimos por minuto, y que duración de las llamadas es de 2 minutos. Esto supone que la pérdida por minuto debido las lamadas rechazadas se puede estimar como \\(80 - 48.82 = 31.18\\) céntimos por minuto.","code":"\n# Matriz de tasas\nnestados <- 7\nlambdas <- rep(4, 6) \nmus <- (1:6)/2\n# Probabilidades del sistema\nprobs <- distr.lim.nm(nestados, lambdas, mus)\n# vector de beneficios\nbeneficio <- 10*(0:6) \n# beneficio por unidad de tiempo\nsum(beneficio*probs)## [1] 48.81985"},{"path":"CMTC.html","id":"CMTCJ","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.10 Tiempos de primer paso","text":"Como ocurría con las CMTD podemos hablar de los tiempos de primer paso en las CMTC. Si \\(\\{X(t), t \\geq 0\\}\\) es una CMTC con espacio de estados \\(\\{1, 2,...,N\\}\\) y matriz de tasas \\(R\\), entonces se define como el tiempo de primer paso al estado \\(N\\) como:\\[T = min\\{t \\geq 0: X(t) = N\\}.\\]Más concretamente estudíamos el valor esperado de \\(T\\), \\(E(T)\\). Para ello definimos los tiempos esperados partir de cada uno de los estados del sistema como:\\[m_i = E(T \\mid X(0) = ), \\quad 1 \\leq \\leq N-1\\] y \\(m_N = 0.\\)Teorema 4.10  Los valores \\(\\{m_i, 1 \\leq \\leq N-1\\}\\) satisfacen\\[r_im_i = 1 + \\sum_{j=1}^{N-1} r_{ij}m_j, \\quad 1\\leq \\leq N-1.\\]Si deseamos calcular los tiempos de primer paso un subconjunto de estados, \\(\\) se puede adaptar el teorema anterior ya que sólo debemos resolver el sistema:\\[r_im_i() = 1 + \\sum_{j \\notin } r_{ij}m_j(), \\quad 1\\leq \\leq N-1.\\]continuación presentamos un algoritmo para calcular los valores de \\(m_i\\) partir de la matriz de tasas del sistema, donde debemos indicar el estado o estados desde los que partimos al inicio.Ejemplo 4.13  En las condiciones del sistema \\(M/M/1/K\\) del cajero bancario descrito anteriormente, estamos interesados en conocer el tiempo quen debe trasncurrir hasta que la cola esta vacia si ahora mismo hay un cliente en el sistema y cero en la cola (\\(X(0) = 0\\)). Recordemos que el esapcio de estados hace referencia al número de clientes en la cola y viene dado por \\(\\{0, 1, 2, 3, 4, 5\\}.\\)El tiempo esperado hasta que la cola este vacia de nuevo son 0.1736 horas o 10.42 minutos.Ejemplo 4.14  En las condiciones del sistema de mantenimiento de areonaves descrito anteriormente. Supongamos que en un experimento de prueba el avión despega con cuatro motores motores que funcionan correctamente y sigue volando hasta que se estrella. Estamos interesados en conocer el tiempo esperado del accidente.Recordemos que el espacio de estados del sistema es \\(\\{1, 2,...,,9\\}\\), y sabemos que el avión se estrallará si en algún momento accedemos al subconjunto de estados \\(\\{1, 2, 3, 4, 7\\}.\\) Calculamos los tiempos de primer paso cuando \\(X(0) = \\{5, 6, 8, 9\\}\\), aunque como el avión está en condiciones çoptimas para despegar nos debermeos fijar en el valor correspondiente al estado 9. Recordemos que el tiempo medio hasta que falla un motor es de 200 horas, de forma que \\(\\lambda = 1/200 = 0.005.\\)De esta forma, partiendo de un avión en condiciones óptimas el tiempo ahsta que ocurra un incidente que le impida volar es de 183.33 horas, o lo que es lo mismo 183 horas y 20 minutos.","code":"\n# Función para la resolución numérica de las ecuaciones de balance\ntiempos.primer.paso<-function(Rmat, A, estados)\n{\n  # Parámetros de la función\n  #=========================\n  # Rmat: matriz de tasas del sistema\n  # A: vector de estados que debemos alcanzar\n  # estados: conjunto de estados total (como carácter)\n  \n  # Estados como texto\n  \n  estados <- as.character(estados)\n  # Tasas r\n  rts <- diag(apply(Rmat, 1, sum), nrow(Rmat))\n  # Seleccionamos el subconjunto de la matriz quitando fila y columna\n  Rmod <- Rmat[-A, -A]\n  rates <- rts[-A, -A]\n  # Número de m´s a estimar\n  lms <- nrow(Rmod)\n  # Matriz de coeficientes del sistema de ecuaciones de balance\n  B <- rates - Rmod\n  # Vector de términos independientes del sistema\n  CS <- rep(1, lms)\n  # Resolución del sistema\n  ps <- as.data.frame(qr.solve(B, CS))\n  rownames(ps) <- paste(\"estado\", estados)[-A]\n  colnames(ps) <-\"tiempo\"\n  return(ps)\n}\n# Definición matriz de tasas\nnestados <- 6\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nR[1,2] <- 10\nR[2,1] <- 15 \nR[2,3] <- 10 \nR[3,2] <- 15 \nR[3,4] <- 10 \nR[4,3] <- 15 \nR[4,5] <- 10\nR[5,4] <- 15\nR[5,6] <- 10\nR[6,5] <- 15\n\n# Tiempos de primer el estado 1 que deseamos alcanzar (corresponde con el primer elemento del espacio de estados)\ntiempos.primer.paso(R, 1, 0:5)##             tiempo\n## estado 1 0.1736626\n## estado 2 0.3341564\n## estado 3 0.4748971\n## estado 4 0.5860082\n## estado 5 0.6526749\n# Definición matriz de tasas\nnestados <- 9\nlambda <- 0.005\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nR[2,1] <- lambda \nR[3,2] <- 2*lambda \nR[4,1] <- lambda \nR[5,2] <- lambda \nR[5,4] <- lambda \nR[6,3] <- lambda \nR[6,5] <- 2*lambda\nR[7,4] <- 2*lambda\nR[8,5] <- 2*lambda\nR[8,7] <- lambda\nR[9,6] <- 2*lambda\nR[9,8] <- 2*lambda\n\n# Conjunto que debemos alcanzar\nA <- c(1, 2, 3, 4, 7)\n# Tiempos de primer paso \ntiempos.primer.paso(R, A, 1:9)##            tiempo\n## estado 5 100.0000\n## estado 6 133.3333\n## estado 8 133.3333\n## estado 9 183.3333"},{"path":"CMTC.html","id":"CMTCK","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.11 Ejercicios","text":"Los ejercicios que se presentan continuación se estruturan en dos niveles de dificultad. El primer nivel son ejercicios más básicos (codificados con una B), y que son parte de los ejmplos rabajados en la unidad, mientras que el segundo bloque necesitan una mayor cantidad de trabajo (codificados con una ). Al final de los ejercicios se encuentra el código de R para resolver algunos de dichos ejercicios. Cuando consideres necesario puedes plantear una solución mediante simulación para contestar las preguntas de interés.Ejercicio B-1. Para el proceso de mantenimiento de máquinas estamos interesados en calcular el valor esperado del número de máquinas en funcionamiento después de 9 horas de funcionamiento, suponiendo que el sistema empieza con todas las máquinas paradas.Ejercicio B-2. Para el proceso de mantenimiento de aeronaves supongamos que cada motor funciona en promedio unas 200h antes de detectarse cualquier problema. Si los cuatro motores están funcionando antes de comenzar un vuelo de seis horas ¿cuál es la probabilidad de que el vuelo llegue de forma segura? (Hint: Para seolver este ejercico ten en cuenta la codificación de estados establecida en la definición del sistema).Ejercicio B-3. Para el proceso de centralita telefónica supongamos que la capacidad total de la centralita es de 10 llamadas y que se reciben llamadas una tasa de 1 por minuto, y que el tiempo medio de atención de cada llamada es de 10 minutos. Si ahora mismo la centralita está atendiendo 3 llamadas:¿cuál es la probabilidad de que la centralita este como máximo al 50% de su capacidad dentro de media hora? ¿y dentro de una hora?.Si la centralita está activa durante 6 horas más ¿cuantas llamadas estarán pendientes al finalizar el tiempo de trabajo?Ejercicio B-4. Para el proceso de sistema de inventarios supongamos que la capacidad máxima de stock del producto \\(KD\\) es 20, y que se solicitan nuevas piezas cuando el stock es inferior 6. Además tenemos que la tasa de entrega de nuevos productos es de tres días, mientras que la demanda de dicho producto es de 3 piezas/dia. Si en estos momentos hay stock de la pieza \\(KD\\) la empresa esta interesada en conocer ¿cuál es el stock más probable dentro de 8 días? ¿cuál es la probabilidad de que tengamos que reabastecernos al finalizar de los ocho días?Ejercicio B-5. Para el proceso \\(M/M/1/K\\) del cajero bancario supongamos que los clientes llegan con una tasa de 10 por hora y que tardan en promedio unos cuatro minutos en realizar las operaciones con el cajero. Supongamos que hay espacio para como máximo cinco clientes delante del cajero automático, mientras que un cliente está siendo atendido. Si el cajero está inactivo ¿cuál es el tiempo esperado de inactividad del cajero durante la siguiente hora?.Ejercicio B-6. Para el proceso de fabricación consideramos la situación siguiente. Supongamos que el sistema funciona las 24 horas del día, las demandas se producen cinco por hora y el tiempo medio de fabricación de un artículo es de 10 minutos. La máquina se pone en marcha cuando el stock de artículos fabricados se reduce dos, y permanece encendida hasta que las existencias aumentan cuatro, momento en el que se apaga. Supongamos que el stock es de cuatro (y la máquina está apagada) al principio. Estamos interesados en la cantidad de tiempo esperada durante el cual la máquina está encendida durante las siguientes 24 horas.Ejercicio B-7. Para el proceso de sistema de inventarios supongamos que la capacidad máxima de stock del producto \\(KD\\) es 20, y que se solicitan nuevas piezas cuando el stock es inferior 6. Además tenemos que la tasa de entrega de nuevos productos es de tres días, mientras que la demanda de dicho producto es de 3 piezas/dia. Si en estos momentos hay stock de la pieza \\(KD\\) la empresa esta interesada en conocer ¿cuál es el tiempo esperado durante el cúal se debe reabastecer el almacén durante los próximos 8 días?Ejercicio B-8. Para el proceso de centralita telefónica supongamos que la capacidad total de la centralita es de 10 llamadas y que se reciben llamadas una tasa de 1 por minuto, y que el tiempo medio de atención de cada llamada es de 10 minutos. Si ahora mismo la centralita está atendiendo 3 llamadas ¿cuál es el tiempo esperado de que el sistema este por encima del 80% de ocupación? ¿y por debajo del 20%? ¿cuál es el tiempo esperado de que el sitema este plena capacidad?Ejercicio B-9. Para el sistema de mantenimiento de máquinas consideramos cuatro máquinas disponibles y dos operarios para repararlas en caso de fallo con tiempos de vida de las máquinas exponenciales con media de 3 días, y tiempos medios de reparación de 2 horas. Estamos interesados en la probabilidad largo plazo de que todas las máquinas estén en funcionamiento, y en la fracción de tiempo largo plazo que los dos operarios están ocupados.Ejercicio B-10. Para el proceso \\(M/M/1/K\\) del cajero bancario supongamos que los clientes llegan con una tasa de 10 por hora y que tardan en promedio unos cuatro minutos en realizar las operaciones con el cajero. Supongamos que hay espacio para como máximo cinco clientes delante del cajero automático, mientras que un cliente está siendo atendido. ¿Cómo interpretamos estas probabilidades? ¿Cuál es la probabilidad de que tengamos más de dos clientes en la cola? ¿y de que tengamos como máximo 2?Ejercicio B-11. Para el sistema de mantenimiento de aeronaves estamos interesados en conocer cual es la probabilidad límite de que el avión pueda finalizar el vuelo.Ejercicio B-12. Para el sistema del vendedor por ciudades viajante estamos interesados en conocer la largo plazo cual es la proporción de tiempo que permanecerá en cada ciudad. En este caso la matriz de tasas debe tener en cuenta las probabilidades de moverse de una ciudad otra. Si el beneficio que obtiene el vendedor es de 80 euros/día en la ciudad , 100 euros/día en la ciudad B, 125 euros/día en C, y que además se incurre en un gasto por desplazamiento de 25 céntimos por kilómetro caundo hay 50 kilómetros entre y B, 65 kilómetros entre y C, y 80 kilómetros entre B y C ¿cuál es el beneficio total esperado del sistema para un periodo de un mes? ¿Cuál es la tasa de coste largo plazo? Si el viajante comienza su viaje en la ciudad ¿cuál es el tiempo esperado hasta que el viajante vuelva la ciudad ?Ejercicio B-12. Un taller mecánico consta de dos taladradoras y dos tornos. Los tiempos de vida de las taladradoras son variables aleatorias \\(Exp(\\mu_b)\\) y las de los tornos son variables aleatorias \\(Exp(\\mu_l)\\). El taller mecánico tiene dos reparadores: Al y Bob. Al puede reparar tanto tornos como taladros, mientras que Bob sólo puede reparar tornos. Los tiempos de reparación de las taladradoras son \\(Exp(\\lambda_b\\) y para los tornos \\(Exp(\\lambda_l)\\), independientemente de quién repare las máquinas. Las taladradoras tienen prioridad en las reparaciones. Las reparaciones pueden adelantarse. Haciendo las suposiciones de independencia apropiadas independencia, modelar este taller mecánico como un CMTC, considerando el proceso \\((t) = (b, l)\\) que indica el número de taladros y tornos en funcionamiento en el instante \\(t\\) y obtener la correspondiente matriz de tasas.Ejercicio -1 Un fondo de inversión se clasifica en cuatro estados según los beneficios que produce por unidad de tiempo: altos, medios, bajos, y pérdidas. Además, el movimiento entre estados puede ser visto como una CMTC con matriz de tasas:\\[\nR = \\begin{pmatrix}\n0 & 0.1 & 0.1 & 0\\\\\n0 & 0 & 0.3 & 0.1\\\\\n0 & 0 & 0.5 & 0.5\\\\\n1.5 & 0 & 0  & 0 \n\\end{pmatrix}\n\\] Mientras que el sistema está en cada uno de los estados, el beneficio respectivo estimado es de 500, 250, 100, y -600 euros por unidad de tiempo.¿cuál es el coste total esperado para un periodo de 10 unidades de tiempo?¿cuál será la tasa de coste largo plazo?Si ahora mismo estamos en pérdidas ¿cuánto tiempo tiene que pasar hasta que alcanzemos beneficios altos?La empresa considera que si el coste del estado de pérdidas se duplicará (pasar de 600 1200) mejorarían los datos de las cuestiones anteriores ¿qué lo podemos decir la empresa?Ejercicio -2. Sea \\(\\{X(t), t \\geq 0\\}\\) una CMTC con estados \\(\\{1, 2, 3, 4, 5\\}\\) y matriz de tasas\\[\nR = \\begin{pmatrix}\n0 & 4 & 4 & 0 & 0\\\\\n5 & 0 & 5 & 5 & 0\\\\\n5 & 5 & 0 & 4 & 4\\\\\n0 & 5 & 5  & 0 & 4\\\\\n0 & 0& 5& 5& 0\n\\end{pmatrix}\n\\]Calcular la matriz de tiempos de ocupación para \\(t=0.2\\).Obtener la distribución límite del proceso.Si el sistema incurre en costes de acuerdo la ecuación \\(c() = 2i+1, \\quad 1\\leq \\leq 5\\) ¿Cuál el coste total esperado en el intervalo de tiempo \\([0, 10]\\), si el sistema está ahora mismo en el estado 2. ¿Cuál sería la tasa de coste largo plazo?¿Cuál es el tiempo esperado para ir del estado 1 al estado 5?Ejercicio -3. Sea \\(\\{X(t), t \\geq 0\\}\\) una CMTC con estados \\(\\{1, 2, 3, 4, 5, 6\\}\\) y matriz de tasas\\[\nR = \\begin{pmatrix}\n0 & 6 & 6 & 8 & 0 & 0\\\\\n0 & 0 & 6 & 8 & 0 & 0\\\\\n0 & 0 & 0 & 6 & 4 & 0\\\\\n0 & 6 & 8  & 0 & 0 & 0\\\\\n6 & 0& 0& 0& 6 & 0\n\\end{pmatrix}\n\\]Calcular la matriz de tiempos de ocupación para \\(t=0.1\\).Obtener la distribución límite del proceso.Si el sistema incurre en costes de acuerdo la ecuación \\(c() = 2i^2+3, \\quad 1\\leq \\leq 6\\) ¿Cuál el coste total esperado en el intervalo de tiempo \\([0, 15]\\), si el sistema está ahora mismo en el estado 4. ¿Cuál sería la tasa de coste largo plazo?¿Cuál es el tiempo esperado para ir del estado 6 al estado 4?Ejercicio -4. Un peso de \\(18\\) toneladas está sostenido por \\(3\\) cables que se reparten la carga por igual. Cuando uno de los cables se rompe, los restantes, que se han roto, se reparten la carga partes iguales. Cuando se rompe el último cable, se produce un fallo. La tasa de fallos de un cable es \\(0.2\\) por año y tonelada. Los tiempos de vida de los \\(3\\) cables son independientes entre sí. Se considera \\(X(t)\\) como el número de cables que siguen sin romperse en el momento \\(t\\).¿Cuál es la probabilidad de que el sistema dure más de dos años?¿Cuál es el tiempo estimado hasta que el sistema falle si ahora los tres cables están bien?Ejercicio -5. Un ordenador tiene cinco unidades de procesamiento (CPUs). Los tiempos de vida de las CUPs son variables aleatorias iid exponenciales de media 2 años. Cuando una CPU falla, el ordenador intenta aislarla automáticamente y reconfigurar el sistema con las demás CPU. Sin embargo, este proceso tiene éxito con una probabilidad \\(0.94\\), denominada factor de cobertura. Si la reconfiguración tiene éxito el sistema continúa con una CPU menos. Si el proceso falla, todo el sistema se bloquea. Supongamos que el proceso de reconfiguración es instantáneo y que una vez que el sistema se bloquea, se detiene definitivamente. Se considera \\(X(t)\\) igual cero si el sistema ha dejado de funcionar en el instante \\(t\\), o en caso contrario es igual al número de CPUs en funcionamiento en el momento \\(t\\).¿Cuál es la probabilidad de que los cinco procesadores funcionen 5 años sin fallos? (asumimos que todos los procesadores están en funcionamiento en el instante 0)Imaginemos ahora que el sistema puede ser reparado cuando falla. El tiempo enecesario para la reparación es una variable aleatoria exponencial de media 5 días, y una vez se finaliza todas las CPUS funcionan de nuevo.¿Cuál es la probabilidad límite de que el sistema este en reparación?.¿cuál es el tiempo esperado hasta que el sistema falla y debe ser reparado si en estos momentos funcionan todos los procesadores?.Supongamos que cada hora de trabajo de cada procesasor proporciona 100 euros de beneficio, mientras que las reparaciones cuestan 200 euros/hora. ¿cuál es el beneficio esperado durante el primer año si los cinco procesadores están trabajndo ahora mismo?Ejercicio -6. Una estación de servicio tiene tres servidores (1, 2, y 3). Cuando llega un cliente, es asignado al servidor libre con el índice más bajo. Si los servidores están ocupados el cliente se detiene y deja la estación de servicio. Los tiempos de servicio de cada servidor son variables aletorias \\(Exp(\\mu_i)\\) con:media de 8 minutos para el servidor 1,la media del servidor 2 es dos veces más rápido que el servidor 3,la media del servidor 1 es dos veces más rápido que el servidor 2.Los clientes llegan de acuerdo un \\(PP(\\lambda)\\) con tasa de 20 clientes por hora.¿cuál es la probabilidad de que los tres servidores esten ocupados los 20 minutos, asumiendo que el sistema está vacio en el instante 0?¿cuál es el tiempo de ocupación de cada estado del sistema en 50 minutos, asumiendo que el sistema está vacio en el instante 0?¿cuál es el tiempo esperado hasta que los tres servidores estén libres, asumiendo qeu el sistema tiene un cliente?Si los costes de los tres servidores son 40, 20 y 10 euros por hora respectivamente ¿cuál el valor de \\(c\\) más pequeño que hace que el sistema sea rentable largo plazo?Ejercicio -7. Una estación de servicio monoservicio atiende dos tipos de clientes. Los clientes de tipo \\(, = 1, 2,\\) llegan según un \\(PP(\\lambda_i)\\) independientes. La estación tiene espacio para atender como máximo \\(K\\) clientes. Los tiempos de servicio son variables aleatorias iid \\(Exp(\\mu)\\) para ambos tipos de clientes. La política de admisión es la siguiente. Si, en el momento de una llegada, el número total de clientes en el sistema es \\(M\\) o menos (aquí \\(M < K\\) es es un número entero fijo), se permite que el cliente que llega se incorpore la cola; en caso contrario sólo si es del tipo 1. Esto crea un trato preferente para los clientes de tipo 1. Sea \\(X(t)\\) el número de clientes (de ambos tipos) en el sistema en el tiempo \\(t\\) . Si las tasas de llegadas son de 5 y e minutos, la tasa de servicio es de 4 minutos, \\(K = 5\\), y \\(M = 3\\).¿Cuál es la variable de interés del sistema?¿Cuáles son los tiempos de ocupación en el periodo de 60 minutos desde el inicio del servico, si en el instante inicial hay clientes?¿Cuál es la probabilidad largo plazo de que la estación esté vacía?Si al abrir la gasolinera tenemos un cliente ¿cuánto tiempo debe pasar hasta que rechazemos el primer cliente?Ejercicio -8 Una pequeña gasolinera tiene un surtidor y espacio para un total de tres coches (uno en el en el surtidor y dos en espera). El tiempo entre las llegadas de los coches la estación es una variable aleatoria exponencial con una tasa media de llegada de 10 coches por hora. El tiempo que cada coche pasa delante del surtidor es una variable aleatoria exponencial con una media de cinco minutos (es decir, una tasa media de 12 por hora). Si hay tres coches en la estación y llega otro coche, el coche recién llegado sigue su camino y nunca entra en la estación. Considera \\(X(t)\\) como el número de coches en la estación en el momento \\(t\\).¿Cuál es la probabilidad largo plazo de que la estación esté vacía?¿Cuál es el número esperado de coches en la estación largo plazo?¿Cuál es la proporción de tiempo que la estación estará completa en un periodo de 8 horas?Si al abrir la gasolinera tenemos un cliente ¿cuánto tiempo debe pasar hasta que tengamos ningún cliente en el sistema? ¿y más de uno?Ejercicio -9 (Cola \\(M^x/M/1/K\\)). Una pequeña tienda de autoservicio 24 horas de carretera tiene espacio para 5 automóviles en el parking. Los vehículos llegan al azar, siendo los tiempos de llegada una variable aleatoria exponencial con una media de 10 vehículos por hora. El número de personas dentro de cada coche es una variable aleatoria, \\(N\\), donde \\(P(N = 1) = 0.1\\), \\(P(N = 2) = 0.7\\) y \\(P(N = 3) = 0.2\\). La gente de los coches entra en la tienda y permanece en ella un tiempo exponencial. La duración media de la estancia en la tienda es de 10 minutos y cada persona actúa de forma independiente de todas las demás, saliendo de la tienda por separado y esperando en sus coches los demás. Si llega un coche y la tienda está demasiado llena para que todas las personas del coche entren en ella, el coche saldrá y nadie de ese coche entrará en la tienda. Si \\(X(t)\\) es el número de individuos en la tienda en el momento \\(t\\), obtén la matriz de tasas corespondiente este proceso.¿Cuál es la probabilidad largo plazo de que la tienda esté vacía?¿Cuál es la proporción de tiempo que la estación estará completa en un periodo de 24 horas?Ejercicio -10. Un determinado equipo electrónico tiene dos componentes y B. El tiempo hasta fallo del componente está descrito por una función de distribución exponencial con un tiempo medio de 100 horas. El componente B tiene una vida media hasta el fallo de 200 horas y también está descrito por una distribución exponencial. Cuando uno de los componentes falla, el equipo se apaga y se realiza el mantenimiento. El tiempo de reparación del componente se distribuye exponencialmente con un tiempo medio de 5 horas si fue el que falló y 4 horas si es B el que falla. Se considera el proceso \\(X(t)\\) con espacio de estados \\(\\{1, 2, 3\\}\\) donde el estado \\(1\\) denota que el equipo está funcionando, \\(2\\) denota que el componente ha fallado, y \\(3\\) denota que el componente B ha fallado.¿Cuál es la probabilidad largo plazo de que el equipo funcione?¿cuál es la proporción de tiempo esperado que el sistema estará funcionando durante las próximas 500 horas?Un contratista externo realiza los trabajos de reparación de los componentes cuando se produce un fallo y cobra 100 euros por hora por el tiempo más los gastos de viaje, lo que supone 500 euros más por cada visita. La empresa ha determinado que puede contratar y formar su propio propio reparador. Si cuentan con su propio empleado para las reparaciones, le costará 40 euros por hora, tanto cuando la máquina esté en funcionamiento como cuando esté parada. Ignorando el coste de la formación inicial y la posibilidad de que un empleado contratado para los trabajos de reparación pueda hacer otras cosas mientras la máquina está en funcionamiento, ¿merece la pena económicamente contratar y formar su propia persona?Ejercicio -11. Una pieza de automóvil necesita tres operaciones de mecanizado realizadas en una determinada secuencia. Estas operaciones son realizadas por tres máquinas. La pieza se introduce en la primera máquina, donde la operación de mecanizado dura en media 1 minuto. Una vez finalizada la operación, la pieza pasa la máquina 2, donde el mecanizado requiere un tiempo medio de 1.2 minutos. continuación, pasa la máquina 3, donde la operación dura en promedio 1 minuto. hay espacio de almacenamiento entre las dos máquinas, por tanto si la máquina 2 esta trabajando, la pieza de la máquina 1 puede ser retirada aunque la operación en la máquina 1 se haya completado. Decimos que la máquina 1 está bloqueada en este caso. Hay un amplio suministro de piezas sin procesar disponibles de modo que la máquina 1 siempre puede procesar una nueva pieza cuando una pieza terminada se desplaza la máquina 2. Modele este sistema como un CMTC. (Hint: Tenga en cuenta que la máquina 1 puede estar trabajar o estar bloqueada, la máquina 2 puede estar trabajando, bloqueada o inactiva, y la máquina 3 puede estar trabajando o inactiva).Calcular la cantidad de tiempo esperada que la máquina 1 está bloqueada durante la primera hora, asumiendo que todas la máquinas están trabajando en el instante 0.Calcule la fracción de tiempo largo plazo en que la última máquina está trabajando en el sistema de producción.Cada máquina cuesta 40 euros por hora mientras trabaja en un componente y produce un beneficio de 75 euros/hora la pieza en la que trabaja. El valor añadido, o el coste de funcionamiento, es cero cuando la máquina está parada o bloqueada. Calcula la contribución neta de las tres máquinas por unidad de tiempo largo plazo.","code":""},{"path":"CMTC.html","id":"CMTCL","chapter":"Unidad 4 Cadenas de Markov de Tiempo Contínuo","heading":"4.12 Soluciones","text":"Ejercicio B-1.Distribución de probabilidad asociada al evento de interés:Solución con simmer:Ejercicio B-2.Probabilidades de transición para el evento de interés:Por tanto, la probabilidad de un fallo que le impida al avión finalizar el viaje es 0.0018.Ejercicio B-5.Obtenemos ahora la matriz \\(M(1)\\):Estamos interesados en la transición \\(X(0) = 0\\) \\(X(1) = 0\\) que corresponde con el elemento \\([1,1]\\) de la matriz obtenida. Utilizando simmer:El tiempo que el sistema esta libre es de mean(res) horas. En este caso, la estimación obtenida si es más diferente del ressultado teórico. Podrímaos incluir un mayor número de réplicas para intentar conseguir algo más de precisión.Ejercicio B-6.Sea \\(X(t)\\) el número de artículos en stock en el tiempo \\(t\\), e \\(Y(t)\\) el estado de la máquina en el tiempo \\(t\\). El conjunto de estados de este proceso viene dado por:\\[S = \\{1 = (0, 1), 2 = (1, 1), 3 = (2, 1), 4 = (3, 1), 5 = (4, 0), 6 = (3, 0)\\}.\\] En la situación inicial nos encontramos en el estado \\(5 = (4, 0) = (X(0), Y(0))\\) y estamos interesados en el tiempo en que la máquina estará después de 24 horas en los estados \\(1, 2, 3\\) o \\(4\\), es decir:\\[m_{51}(24) + m_{52}(24) + m_{53}(24) + m_{54}(24)\\] En esta situación tenemos que la tasa de producción es \\(\\lambda = 60/10 = 6\\) y la de demanda es \\(\\mu = 5\\), de forma que la matriz de tasas viene dada por:Obtenemos ahora la matriz \\(M(24)\\):La cantidad buscada viene dada por:Ejercicio B-9.Así, largo plazo, todas las máquinas funcionan el 89,6% del tiempo (\\(p_4 = p[5]\\)). Ambos operarios están ocupados siempre que el sistema está en el estado \\(0\\), \\(1\\) o \\(2\\). Por lo tanto, la fracción de tiempo largo plazo en que ambos reparadores están ocupados viene dada por \\(p_0 + p_1 + p_2\\):Ejercicio B-10.Ejercicio B-11.Recordemos que el espacio de estados es \\(\\{1, 2,...,9\\}\\) y nos intersa obtener la probabilidad del sujconjunto \\(\\{1, 2, 3, 4, 7\\}\\). Obtenemos en primer lugar la matriz de tasas:Ejercicio B-12.","code":"\n# Matriz de tasas\nestados <- c(0, 1, 2, 3, 4)\nnestados <- length(estados)\n\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nlambda <- 1/2\nmu <- 1/72 \n\nR[1,2] <- 2*lambda \nR[2,1] <- mu \nR[2,3] <- 2*lambda \nR[3,2] <- 2*mu \nR[3,4] <- 2*lambda \nR[4,3] <- 3*mu \nR[4,5] <- lambda\nR[5,4] <- 4*mu\n# Matriz de probabilidades de transición\nPmat<-matriz.prob.trans(R, 9, 1)\n# Distribución de probabildiad buscada\nPmat[1,]## [1] 0.0002 0.0020 0.0136 0.1547 0.8295\n# valor esperado\nesperanza <- round(sum(estados*Pmat[1,]), 1)\nreplicas <- 2500\nenvs <- lapply(1:replicas, function(i) {\n  maquinas <- mantenimiento(9, 1/2, 1/72, 2)\n})\n# almacenamos análisis de recursos del sistema\nsimresource <- as_tibble(get_mon_resources(envs))\n# Almacenamos el estado final de la cola en el último instante del sistema\nsalida <- simresource %>%\n  filter(resource == \"funcionando\") %>% #seleccionamos el recurso adecuado\n  group_by(replication) %>%\n  summarise(estado = last(system))\n# Estimamos la distribución de probabilidad\ndistrprob <- round(table(salida$estado)/replicas, 3)\nesperanza <- sum(as.numeric(names(distrprob))*distrprob)\nesperanza## [1] 0.101\n# Matriz de tasas\nestados <- c(\"(0, 0)\", \"(0, 1)\", \"(0, 2)\", \"(1, 0)\", \n             \"(1, 1)\", \"(1, 2)\", \"(2, 0)\", \"(2, 1)\", \"(2,2)\")\nnestados <- length(estados)\n\nlambda <- 1/200\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\n\nR[2,1] <- lambda \nR[3,2] <- 2*lambda \nR[4,1] <- lambda \nR[5,2] <- lambda \nR[5,4] <- lambda \nR[6,3] <- lambda \nR[6,5] <- 2*lambda\nR[7,4] <- 2*lambda\nR[8,5] <- 2*lambda\nR[8,7] <- lambda\nR[9,6] <- 2*lambda\nR[9,8] <- 2*lambda\n# Matriz de probabilidades de transición\nPmat<-matriz.prob.trans(R, 6, 1)\n# Calculamos la probabilidad buscada\nprobabilidad <- Pmat[9,5] + Pmat[9,6] + Pmat[9,8] + Pmat[9,9]\nprobabilidad## [1] 0.9982\n# Matriz de tasas\nnestados <- 6\nlambda <- 10\nmu <- 15\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\n\nR[1,2] <- lambda \nR[2,1] <- mu\nR[2,3] <- lambda \nR[3,2] <- mu\nR[3,4] <- lambda\nR[4,3] <- mu\nR[4,5] <- lambda\nR[5,4] <- mu\nR[5,6] <- lambda\nR[6,5] <- mu\ntiempos.ocupacion(R, 1, 1)##        [,1]   [,2]   [,3]   [,4]   [,5]   [,6]\n## [1,] 0.4451 0.2548 0.1442 0.0814 0.0465 0.0280\n## [2,] 0.3821 0.2793 0.1604 0.0920 0.0535 0.0326\n## [3,] 0.3246 0.2407 0.2010 0.1187 0.0710 0.0441\n## [4,] 0.2746 0.2070 0.1780 0.1695 0.1046 0.0663\n## [5,] 0.2356 0.1806 0.1598 0.1569 0.1624 0.1047\n## [6,] 0.2124 0.1648 0.1489 0.1492 0.1571 0.1677\n# Réplicas del proceso\nreplicas <- 2500\nenvs <- lapply(1:replicas, function(i) {\n  cajero <- cola.MM1K(1, 10, 15, 1, 6)\n})\n# almacenamos análisis de llegadas del sistema\nsimarrivals <- as_tibble(get_mon_arrivals(envs))\nsimresources <- as_tibble(get_mon_resources(envs))\n# detectamos los instantes de tiempo donde el sistema esta libre y obtenemos los tiempos correspondientes\nres<-c()\nfor(i in  1:replicas)\n{\n  temp <- simresources[which(simresources$replication == i), ]\n  deltas <- diff(temp$time)\n  free <- which(temp$system == 0)\n  t_free <- deltas[free]\n  res <- c(res, sum(t_free, na.rm = TRUE))\n}\nnestados <- 6\nlambda <- 6\nmu <- 5\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\n\nR[1,2] <- lambda \nR[2,1] <- mu\nR[2,3] <- lambda \nR[3,2] <- mu\nR[3,4] <- lambda\nR[4,3] <- mu\nR[4,5] <- lambda\nR[5,6] <- mu\nR[6,3] <- mu\nmmat<-tiempos.ocupacion(R, 24, 1)\nmmat##        [,1]   [,2]   [,3]   [,4]   [,5]   [,6]\n## [1,] 4.0004 4.6322 5.4284 2.9496 3.5097 3.4798\n## [2,] 3.8602 4.6639 5.4664 2.9703 3.5345 3.5047\n## [3,] 3.7697 4.5553 5.5361 3.0084 3.5802 3.5503\n## [4,] 3.7207 4.4965 5.4656 3.0608 3.6431 3.6132\n## [5,] 3.7063 4.4793 5.4448 2.9586 3.7204 3.6906\n## [6,] 3.7380 4.5173 5.4905 2.9835 3.5503 3.7204\nsum(mmat[5, 1:4])## [1] 16.589\nmaquinas <- 4\nestados <- maquinas + 1\noperarios <- 2\nlambda <- 1/2\nmu <- 1/72\nlambdas <- pmin(maquinas - (0:(maquinas-1)), operarios)*lambda\nmus <- (1:(maquinas-1))*mu\n# Debemos quitar el último elemento de lambda y el primero de mu para usar la función definida\nprobs <- distr.lim.nm(estados, lambdas, mus)## Warning in prl/prm: longitud de objeto mayor no es múltiplo de la longitud de uno menor\nprobs## [1] 1.540618e-05 1.109245e-03 3.993283e-02 9.583879e-01 5.546226e-04\nsum(probs[1:3])## [1] 0.04105748\nmaxcola <- 5\nestados <- maxcola + 1\nlambda <- 10\nmu <- 15\nlambdas <- rep(lambda, maxcola)\nmus <- rep(mu, maxcola)\n# Distribución límite\nprobs <- distr.lim.nm(estados, lambdas, mus)\nprobs## [1] 0.36541353 0.24360902 0.16240602 0.10827068 0.07218045 0.04812030\n# Estados del sistema\nnestados <- 9\nlambda <- 1/20\n# Matriz de tasas\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nR[2,1] <- lambda \nR[3,2] <- 2*lambda \nR[4,1] <- lambda \nR[5,2] <- lambda \nR[5,4] <- lambda \nR[6,3] <- lambda \nR[6,5] <- 2*lambda\nR[7,4] <- 2*lambda\nR[8,5] <- 2*lambda\nR[8,7] <- lambda\nR[9,6] <- 2*lambda\nR[9,8] <- 2*lambda\n# Resolución  de las ecuaciones de balance\nps <- distr.lim.general(R)\nps## [1] 1 0 0 0 0 0 0 0 0\n# Estados del sistema\nnestados <- 3\n# Matriz de tasas\nR <- matrix(nrow = nestados, ncol = nestados, data = 0)\nR[1,1] <- 0 \nR[1,2] <- 1/4\nR[1,3] <- 1/4\nR[2,1] <- 3/4\nR[2,2] <- 0\nR[2,3] <- 1/4\nR[3,1] <- 1/2\nR[3,2] <- 1/6\nR[3,3] <- 0\n# Resolución  de las ecuaciones de balance\nps <- distr.lim.general(R)\n# Expresando en porcentajes\nround(100*ps, 2)## [1] 54.55 18.18 27.27"},{"path":"COLAS.html","id":"COLAS","chapter":"Unidad 5 Sistemas de colas","heading":"Unidad 5 Sistemas de colas","text":"En esta unidad, consideramos especificamente los sistemas basados en colas de espera. Nos centraremos en los más sencillos y que están basados en el Proceso de Poisson, algunos de los cuales ya hemos presentado en la unidad anterior.Los sistemas de colas están ampliamente extendidos en nuestra vida real y es necesario dedicar una unidad un análsis\nmás extenso para poder responder preguntas como:¿Cuántos clientes hay en la cola en promedio?¿Cuanto tiempo esta un cliente e la cola?¿cuántos clientes son rechazados o se pierden por la capacidad de la cola?¿cómo están de ocupados los servidores?Comenzamos introduciendo la nomenclatura estándar para los sistemas de colas:Proceso de llegadas: Es la forma en que los “clientes” entran al sistema de forma que los tiempos de llegadas sucesivas son variables aleatorias iid. Dicho proceso, se describe mediante la distribución de los tiempos de llegada, representados por los símbolos: \\(M\\) (exponencial), \\(G\\) (general), \\(D\\) (determinista), y \\(E_k\\) (Erlang con \\(k\\) fases).Proceso de llegadas: Es la forma en que los “clientes” entran al sistema de forma que los tiempos de llegadas sucesivas son variables aleatorias iid. Dicho proceso, se describe mediante la distribución de los tiempos de llegada, representados por los símbolos: \\(M\\) (exponencial), \\(G\\) (general), \\(D\\) (determinista), y \\(E_k\\) (Erlang con \\(k\\) fases).Tiempos de servicio: Suponemos que los tiempos de servicio de los sucesivos clientes son variables aleatorias iid. Se representan por las mismas letras que los tiempos de interllegada.Tiempos de servicio: Suponemos que los tiempos de servicio de los sucesivos clientes son variables aleatorias iid. Se representan por las mismas letras que los tiempos de interllegada.Numero de servidores: Habitualmente se denota por \\(s\\) y se asume que todos ellos se comportan de la misma forma, de forma que cada cliente es antendido por un único servidor.Numero de servidores: Habitualmente se denota por \\(s\\) y se asume que todos ellos se comportan de la misma forma, de forma que cada cliente es antendido por un único servidor.Capacidad del sistema: Habitualmemte se denota por \\(K\\) y es la capacidad total del sistema incluyendo tanto los clientes que pueden ser atendidos como los que pueden esperar en la cola. Si un nuevo cliente encuentra \\(K\\) clientes en el sistema, este se pierde. La capacidad del sistema puede ser finita o infinita, pero sino se indica nada se considera infinita.Capacidad del sistema: Habitualmemte se denota por \\(K\\) y es la capacidad total del sistema incluyendo tanto los clientes que pueden ser atendidos como los que pueden esperar en la cola. Si un nuevo cliente encuentra \\(K\\) clientes en el sistema, este se pierde. La capacidad del sistema puede ser finita o infinita, pero sino se indica nada se considera infinita.Disciplina de la cola: Como son tratados los nuevos clientes cuando acceden al sistema. Las opciones consideradas son: FIFO (el primero que entra es el primero en ser atendido), LIFO (el último en llegar es el primero en ser atendido), SIRO (servicio en orden aleatorio), y PRI (discilina de la cola con prioridades). Sino se indica nada se considera por defecto la disciplina FIFO.Disciplina de la cola: Como son tratados los nuevos clientes cuando acceden al sistema. Las opciones consideradas son: FIFO (el primero que entra es el primero en ser atendido), LIFO (el último en llegar es el primero en ser atendido), SIRO (servicio en orden aleatorio), y PRI (discilina de la cola con prioridades). Sino se indica nada se considera por defecto la disciplina FIFO.La notación habitual de una cola se establece como:\\[\\text{Llegadas} / \\text{Servicio} / \\text{Servidores} / \\text{Capacidad} / \\text{Disciplina}\\]Una cola \\(M/M/1\\) representa que tanto el proceso de llegadas como servicio son exponenciales, sólo disponemos de un servidor, con capacidad de la cola infinita y con disciplina FIFO.Todas ls colas que presentamos en esta unidad pueden ser descritas mediante procesos de nacimiento y muerte, tal y como los definimos en la unidad anterior. Sin embargo, en el punto siguienteintroducimos la terminología básica de los sistemas de colas.","code":""},{"path":"COLAS.html","id":"COLASA","chapter":"Unidad 5 Sistemas de colas","heading":"5.1 Terminología y y medidas de eficiencia","text":"Notación habitual de los sistemas de colas:\\(N(t)\\): Denota el número de clientes en el sistema en el instante \\(t\\). \\(N(t)\\) es una CMTC con espacio de estdos discreto.\\(N_q(t)\\): Representa el número de clientes en la cola en el instante \\(t\\).\\(P_n(t)\\): Es la probabilidad de que, en el instante \\(t\\), se encuentren \\(n\\) clientes en el sistema. estos efectos se supone conocido el número de clientes en el instante cero (usualmente dicho número es cero). Estas probabilidades se corresponden con las probabilidades de trasnsición comenzando desde el estado 0 que vimos en la unidad anterior.\\(s\\): Denota el número de servidores del mecanismo de servicio.\\(\\lambda_n\\): Representa el número medio de llegadas de clientes al sistema, por unidad de tiempo, cuando ya hay \\(n\\) clientes en él. También se denomina tasa de llegadas (que se correspondería con la tasa de nacimientos si \\(N(t)\\) es un proceso de nacimiento y muerte). Cuando las tasas de llegada dependen de \\(n\\) (es decir todos los \\(n\\) son constantes) suele denotarse \\(\\lambda\\) dicho valor constante.\\(\\mu_n\\): Es el número medio de clientes los que se les completa el servicio, por unidad de tiempo, cuando hay \\(n\\) clientes en el sistema. Es frecuente referirse los \\(mu_n\\) como tasas de complección de servicio (o, simplemente, tasas de servicio). Si todos los servidores tienen la misma distribución del tiempo de servicio, suele denotarse por \\(\\mu\\) el número medio de clientes que puede atender cada servidor por unidad de tiempo. Como consecuencia se tiene que \\(\\mu_n = n\\mu\\) si \\(n = 1, 2,... ,s\\) y \\(\\mu_n = s\\mu\\) para \\(n \\geq s\\).\\(\\rho\\): Es la llamada razón o constante de utilización del sistema (o intensidad de tráfico. Se define, como\\[\\rho = \\frac{\\lambda}{s\\mu}\\]Cuando los \\(\\lambda_n\\) son constantes y todos los servidores tienen la misma distribución de tiempo de servicio, \\(\\lambda\\) es el número medio de clientes que entran en el sistema y \\(s\\mu\\) es el número medio de clientes los que pueden dar servicio los \\(s\\) servidores cuando todos están ocupados. En estas condiciones, \\(\\rho\\) representa la fracción de recursos del sistema que es consumida por los clientes. Así, intuitivamente, parece necesario que se cumpla, en estos casos, que \\(\\rho < 1\\) y además cuanto más cercano 1 que sea \\(\\rho\\), más tráfico ha de soportar el sistema (o menos tiempo libre tendrán los servidores, o más espera habrán de sufrir los clientes, como se quiera expresar).En toda la unidad asumimos que todos los modelos de colas son estacionarios, de forma que los procesos \\(\\{N(t), t \\geq 0\\}\\) y {N_q(t), t }$ cambían con el tiempo. Podemos entonces definir las variables de interés del sistema:\\(N\\): Es la variable aleatoria que contabiliza el número de clientes en el sistema.\\(N_q\\): Denota la variable aleatoria número de clientes en la cola.\\(p_n\\): Probabilidad de que se encuentren \\(n\\) clientes en el sistema \\((n = 0, 1,... )\\).y las medidas de eficiencia:\\(L\\): Representa el número medio de clientes en el sistema, es decir \\(L = E(N)\\).\\(L_q\\): Que es más que el número medio de clientes en la cola, o lo que es lo mismo, \\(L_q = E(N_q)\\).\\(T\\): Es la variable aleatoria que describe el tiempo que un cliente pasa en el sistema.\\(T_q\\): Representa el tiempo que un cliente espera en la cola.\\(W\\) : Es el tiempo medio que un cliente está en el sistema, o simplemente, \\(W = E(T)\\).\\(W_q\\): Denota el tiempo medio de espera en la cola para un cliente genérico. Matemáticamente, \\(W_q = E(T_q)\\).","code":""},{"path":"COLAS.html","id":"COLASB","chapter":"Unidad 5 Sistemas de colas","heading":"5.2 Formulas de Little","text":"En los modelos con distribución del tiempo entre llegadas y distribución del servicio exponencial (así como en muchos otros modelos más generales llamados ergódicos) se verifican ciertas fórmulas que relacionan los números medios de clientes, en el sistema o en la cola, con los tiempos medios de un clientes en el sistema o en la cola. Estas son las llamadas fórmulas de Little.Cuando las tasas de llegada son constantes (es decir \\(\\lambda_n = \\lambda\\) para $n = 0, 1,… $), la primera fórmula de Little establece la igualdad:\\[L = \\lambda W,\\]\nmientras que la segunda se expresa mediante\\[L_q = \\lambda W_q.\\]\nUna forma intuitiva de entender el porqué de la validez de las fórmulas de Little es la siguiente. Considérese un cliente que llega al sistema justo ahora. Después de un tiempo, cuya media es \\(W\\) , ese cliente saldrá servido del sistema. Como el número medio de clientes que llegan al sistema por unidad de tiempo es , el número medio de clientes que habrán llegado desde que nuestro cliente en cuestión entró en el sistema hasta que salió de él es \\(W\\). Por otra parte, es obvio que dicho número medio de clientes es precisamente el número medio de clientes que hay en el sistema justo en el momento que sale del sistema nuestro cliente particular, es decir, \\(L\\). Un razonamiento análogo es válido para la segunda fórmula de Little.Obviamente, las fórmulas de Little pueden ser válidas si las \\(\\lambda_n\\) son constantes pero sí pueden generalizarse esa situación mediante:\\[L = \\bar{\\lambda}W\\]\n\\[L_q = \\bar{\\lambda}W_q\\]con\\[\\bar{\\lambda} = \\sum_{n = 0}^{\\infty} \\lambda_np_n\\]\nOtra relación importante (en este caso para relacionar \\(W\\) y \\(W_q\\)) es la dada por:\\[W = W_q + \\frac{1}{\\mu}\\]\nSu deducción es inmediata pues viene decir que el tiempo medio que un cliente está en el sistema (\\(W\\)) coincide con la suma del tiempo medio en la cola (\\(W_q\\)) más el tiempo medio que tarda en ser servido (\\(1/\\mu\\), ya que \\(\\mu\\) es el número medio de clientes que un servidor puede atender por unidad de tiempo).","code":""},{"path":"COLAS.html","id":"COLASC","chapter":"Unidad 5 Sistemas de colas","heading":"5.3 Colas con un único servidor","text":"En este apartado presentamos los aspectos más relvantes referidos los sistemas de colas con un único servidor.\nempezando por el más sencillo que considera tiempos de llegadas y servicio exponenciales, y con un único servidor.","code":""},{"path":"COLAS.html","id":"mm1","chapter":"Unidad 5 Sistemas de colas","heading":"5.3.1 M/M/1","text":"Comenzamos con le sistema más sencillo donde se consideran tiempos de llegadas y servicio exponenciales, un único servidor, capacidad del sistema infinita y prioridad FIFO. De esta forma, tanto las tasas de llegadas como las tasas de servicio vienen dadas por:\\[\n\\begin{matrix}\n\\lambda_n = \\lambda & n = 0, 1,...\\\\\n\\mu_n = \\mu & n = 1, 2,...\n\\end{matrix}\\]de forma que la matriz de tasas vieen dada por:\\[\nR = \\begin{pmatrix}\n 0 & \\lambda & 0 & 0 & ...\\\\\n\\mu & 0 & \\lambda & 0 & ...\\\\\n0 & \\mu & 0 & \\lambda & ...\\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots\n\\end{pmatrix}\\]donde partir de las ecuaciones de equilibrio podemos obtener la relación entre tasas de llegadas y servicio:\\[c_n = \\frac{\\lambda_{n-1}\\lambda_{n-2}...\\lambda_0}{\\mu_{n}\\mu_{n-1}...\\mu_1} = \\frac{\\lambda^n}{\\mu^n} = \\rho^n, \\quad n = 1, 2,...\\]Utilizando propiedades de series geométricas, dado que \\(\\rho >0\\), el modelo será estacionario si \\(\\rho < 1\\). Otra forma de expresarlo es \\(\\lambda < \\mu\\), que tiene la interpretación adicional de que el número medio de clientes que entran en el sistema por unidad de tiempo sea menor que el número medio de clientes que podrían ser atendidos por el servidor por unidad de tiempo, en caso de que éste estuviese absolutamente todo el tiempo atendiendo clientes (cosa que ocurre siempre).En lo que sigue supondremos que el sistema de la cola es estacionario (es decir \\(\\rho < 1\\)). Lo primero que debemos calcular es la suma de la serie de las \\(c_n\\):\\[\\sum_{n = 1}^{\\infty} c_n = \\sum_{n = 1}^{\\infty} \\rho^n = \\frac{\\rho}{1-\\rho}.\\]\n\\[\n\\begin{matrix}\np_0 = 1 - \\rho\\\\\np_n = c_np_0 = (1 - \\rho)\\rho^n\n\\end{matrix}\\]De esta forma, la distribución de probabilidad de la variable aleatoria del “número de clientes en el sistema” es:\\[P(N = n) = p_n = (1-\\rho)\\rho^n, \\quad n = 0, 1,...\\]que corresponde con una distribuión geométrica de parámetro \\((1 - \\rho)\\). Por tanto, el valor de \\(L\\) viene dado por:\\[L = E(N) = \\sum_{n = 0}^{\\infty} np_n = (1 - \\rho)\\rho \\sum_{n = 1}^{\\infty} n \\rho^{n-1} = (1 - \\rho)\\rho\\frac{1}{(1 - \\rho^2)} = \\frac{\\rho}{1 - \\rho} = \\frac{\\lambda}{\\mu - \\lambda}.\\]partir de ella podemos obtener:\\[L_q = L - (1 - p_0)\\]que es válido para cualquier sistema de cola, y que en nuestro caso es:\\[L_q = \\frac{\\lambda^2}{\\mu(\\mu-\\lambda)}\\]Aplicando las fórmulas de Little tenemos:\\[\n\\begin{matrix}\nW = \\frac{L}{\\lambda} = \\frac{1}{\\mu - \\lambda},\\\\\nW_q = \\frac{L_q}{\\lambda} = \\frac{\\lambda}{\\mu(\\mu - \\lambda),}\n\\end{matrix}\\]de donde podemos deducir:\\[W = W_q + \\frac{1}{\\mu}\\]Si se desea tener más información sobre la espera de clientes en la cola o en el sistema, debe calcularse la distribución de rpoabbildiad de las variables \\(T\\) y \\(T_q\\). Estas distribuciones permitirán calcular la probabilidad de cualquier suceso relativo al tiempo de estancia en la cola o en el sistema. Si denotamos por \\(W(t)\\) y \\(W_q(t)\\) las coorespondientes funciones de distribución de \\(T\\) y \\(T_q\\) tendremos:\\[W(t) = 1 - exp[-(\\mu - \\lambda)t]\\]\\[\nW_q(t) =\n\\begin{cases}\n1 - \\frac{\\lambda}{\\mu}exp[-(\\mu - \\lambda)t] & \\text{ si } t \\geq 0\\\\\n0 & \\text{ si } t < 0\n\\end{cases}\n\\]::: {.example #colas001 name = “Operador de elevador”}Un operador de un pequeño elevador de grano tiene un único muelle de descarga. Las llegadas de camiones durante la temporada alta forman un proceso de Poisson con una tasa de llegada media de cuatro por hora. Debido la variación de las cargas (y al deseo de los conductores de hablar) el tiempo que cada camión pasa frente al muelle de descarga se aproxima por una variable aleatoria exponencial con una media de 14 minutos. Suponiendo que que las plazas de aparcamiento son ilimitadas, el sistema de colas \\(M/M/1\\) puede describir el comportamiento del proceso con tasas de llegadas \\(\\lambda = 4 hora\\) y tasa de servicio \\(\\mu = 60/14 hora\\).¿cuál es la probabilidad de que el muelle de descarga esté inactivo?¿cuál es la probabilidad de que haya exactamente tres camiones esperando?¿cuál es la probabilidad de que haya cuatro o más camiones en el sistema?:::Resolvemos el ejemplo de dos formas diferentes: 1) teóricamente con las fórmulas anteriores, 2) con la libreria queueing. Al final de la unidad presentamos la solución de simmer para simular de una cola \\(M/M/1\\). En este último caso deberemos aproximar las cantidades de interés mediante los correspondientes estimadores Monte-Carlo, si repetimos las imualacion del sistema un número adecuado de veces.Para responder la primera pregunta tenemos en cuenta que \\(\\rho = 0.9333\\) y que la probabilidad buscada es la que corresponde al estado \\(0\\) de la distribución estacionaria, es decir,\\[p_0 = 1 - \\rho = 0.0667\\]\nEn cuanto la segunda pregunta debemos tener en cuenta que:\\[P(N_q = 3) = P(N = 4) = p_4 = 0.0667*0.9333^4 = 0.0506.\\]Para resolver la última pregunta tenemos que:\\[P(N \\geq 4) = 1 - P(N \\leq 3) = 1 - \\sum_{n = 0}^{3} p_n = \\rho^4 = 0.759.\\]Utilizamos ahora la librería queueing para resolver las mismas preguntas. En primer lugar tenemos que definir el sistema y sus características (tasas de llegada, tasas de servicio, y número de elementos de la distribución estacionaria que debemos calcular). Para ello utilizamos la función NewInput() con \\(n = 4\\) elemntos de la distribución estacionaria, ya que las probabildiades buscadas hacen referencia esos cuatro primeros valores.Los valores y funciones del sistema que proporciona la función son:\\(RO\\) = valor de intensidad de tráfico \\(\\rho\\).\\(Lq\\) = número medio de clientes en la cola.\\(VNq\\) = varianza del número de clientes e la cola.\\(Wq\\) = tiempo medio de espera en la cola.\\(VTq\\) = varianza del tiempo de espera en la cola.\\(L\\) = número medio de clientes en el sistema.\\(VN\\) = varianza del número de clientes en el sistema.\\(W\\) = tiempo medio que un cliente está en el sistema.\\(VT\\) = varianza del tiempo que un cliente está en el sistema.\\(Wqq\\) = tiempo medio que un cliente permanece en la cola cuando está existe.\\(Lqq\\) = número medio de clientes en la cola cuando está existe.\\(Pn\\) = Distribición estacionaria de sistema.\\(Qn\\) = Probabilidad de que un cliente encuentre \\(n\\) clientes.\\(FW\\) = Función de distribución de \\(W\\) para un conjunto de valores de \\(t\\).\\(FWq\\) = Función de distribución de \\(W_q\\) para un conjunto de valores de \\(t\\).Veamos la salida completa:Podemos respondera ahora las cuestiones de interés sin más que buscar en los elemntos que proporciona la función.::: {.example #colas002 name = “Estación de trabajo”}En una estación de trabajo con un único procesador se ejecutan programas (que se supone prácticamente su única carga de trabajo) con tiempo de CPU de distribución exponencial de media 3 minutos. Los programas se atienden según una disciplina FIFO. Sabiendo que las llegadas de programas la estación se producen según un proceso de Poisson con una intensidad de 15 programas cada hora, por término medio, se pide:¿Cuál es la probabilidad de que haya más de dos programas en espera de ejecución (además del que se está ejecutando)?Calcular el tiempo medio que transcurre desde que se envía un programa al servidor hasta que se termina su ejecución. ¿Cuál es la relación entre este tiempo y el tiempo medio de CPU?Calcular la probabilidad de que el programa esté en el servidor (esperando o ejecutándose) más de 10 minutos.¿Cuál es el número medio de programas que están la espera de comenzar ejecutarse?Obtener las respuestas los apartados anteriores suponiendo que ahora se ha incrementado la llegada de programas hasta 18 la hora, por término medio.En este caso utilizaremos la librería queueing para los cálculos numéricos. Si tomamos como unidad de tiempo las horas tendremos que \\(\\lambda = 15\\) y \\(1/\\mu = 3 /60\\), con lo cual \\(\\mu = 20.\\):::Para responder la cuestión 1 debemos calcular:\\[P(N_q \\geq 3) = P(N \\geq 4) = 1 - P(N \\leq 3)\\]Para el primer apartado de la segunda cuestión sólo necesitamos el valor de \\(W\\), que corresponde con el tiempo medio en el sistema:El tiempo medio es de 0.2 horas o 12 minutos. Para responder la segunda pregunta hay que tener en cuenta que el tiempo de CPU corresponde con el tiempo de servicio, es decir, la relción buscada es:\\[\\frac{W}{1/\\mu}\\]Cada proceso está en la estación un tiempo equivalente cuatro veces su tiempo de CPU.Para respondear al tercer apartado debemos calcular (expresado en las unidades de tiempo utilizadas:\\[P(T > 10/60)\\]\nDicha probabilidad se obtiene partir de la función de distribuvión de los tiempos que el cliente está en el sistema:La cuarta cuestión se corresponde con el valor de \\(L_q\\):de forma que el número de procesos en espera es de 2.25.Para responder al quinto apartado debemos cambiar el valor de la tasa de llegadas y volver hacer los cálculos:Como puede verse numéricamente el sistema está bastante más congestionado ahora. Podemos representar gráficamente ambas soluciones.\nFigura 5.1: Funciones de distribución de W y Wq para ambos sistemas (sistema 1 = línea continua, sistema 2 = línea discontinua.\nComo se puede ver los tiempos medios de espera de los clientes en el sistema y en la cola para la segunda opción tienen probabildides más bajas lo largo del tiempo, lo que indica que el sistema está más congestionado porque los tiempos de atención son superiores (valores donde se alcanza la probabilidad 1).","code":"\n# Deficición del entorno\nenv.MM1 <- NewInput.MM1(lambda = 4, mu = 60/14, n = 4)\n# Características del sistema\ns.MM1 <- QueueingModel(env.MM1)\n# Medidas del sistema\ns.MM1## $Inputs\n## $lambda\n## [1] 4\n## \n## $mu\n## [1] 4.285714\n## \n## $n\n## [1] 4\n## \n## attr(,\"class\")\n## [1] \"i_MM1\"\n## \n## $RO\n## [1] 0.9333333\n## \n## $Lq\n## [1] 13.06667\n## \n## $VNq\n## [1] 208.1956\n## \n## $Wq\n## [1] 3.266667\n## \n## $VTq\n## [1] 12.19556\n## \n## $Throughput\n## [1] 4\n## \n## $L\n## [1] 14\n## \n## $VN\n## [1] 210\n## \n## $W\n## [1] 3.5\n## \n## $VT\n## [1] 12.25\n## \n## $Wqq\n## [1] 3.5\n## \n## $Lqq\n## [1] 15\n## \n## $Pn\n## [1] 0.06666667 0.06222222 0.05807407 0.05420247 0.05058897\n## \n## $Qn\n## [1] 0.06666667 0.06222222 0.05807407 0.05420247 0.05058897\n## \n## $FW\n## function (t) \n## {\n##     1 - exp(-t/W)\n## }\n## <bytecode: 0x7fa6fcc7b318>\n## <environment: 0x7fa6fcc7ac50>\n## \n## $FWq\n## function (t) \n## {\n##     1 - (RO * exp(-t/W))\n## }\n## <bytecode: 0x7fa6fcc7b778>\n## <environment: 0x7fa6fcc7ac50>\n## \n## attr(,\"class\")\n## [1] \"o_MM1\"\n# ¿cuál es la probabilidad de que el muelle de descarga esté inactivo?\ns.MM1$Pn[1]## [1] 0.06666667\n# ¿cuál es la probabilidad de que haya exactamente tres camiones esperando?\n# se corresponde con el elmento 4 + 1 de pn\ns.MM1$Pn[5]## [1] 0.05058897\n# ¿cuál es la probabilidad de que haya cuatro o más camiones en el sistema?\n1- sum(s.MM1$Pn[1:4])## [1] 0.7588346\n# Deficición del entorno\nenv.MM1 <- NewInput.MM1(lambda = 15, mu = 20, n = 10)\n# Características del sistema\ns.MM1 <- QueueingModel(env.MM1)\n1- sum(s.MM1$Pn[1:4])## [1] 0.3164062\ns.MM1$W## [1] 0.2\ns.MM1$W/(1/20)## [1] 4\n1 - s.MM1$FW(10/60)## [1] 0.4345982\ns.MM1$Lq## [1] 2.25\n# Deficición del entorno\nenv.MM1 <- NewInput.MM1(lambda = 18, mu = 20, n = 10)\n# Características del sistema\ns.MM1 <- QueueingModel(env.MM1)\n# Cuestión 1\n1- sum(s.MM1$Pn[1:4])## [1] 0.6561\n# Cuestión 2.1\ns.MM1$W## [1] 0.5\n# Cuestión 2.2\ns.MM1$W/(1/20)## [1] 10\n# Cuestión 3\n1 - s.MM1$FW(10/60)## [1] 0.7165313\n# Cuestión 4\ns.MM1$Lq## [1] 8.1\n# Primer sistema\nenv.MM1 <- NewInput.MM1(lambda = 15, mu = 20, n = 10)\ns.MM1.1 <- QueueingModel(env.MM1)\n# Segundo sistema\nenv.MM2 <- NewInput.MM1(lambda = 18, mu = 20, n = 10)\ns.MM1.2 <- QueueingModel(env.MM2)\n# Establecemos secuencia de tiempos pra el análisis\ntiempos <- seq(0, 4, 0.01)\n# Almaceamos los resultados\nsistema <- data.frame(tiempos = tiempos, \n                      FW1 = s.MM1.1$FW(tiempos),\n                      FWq1 = s.MM1.1$FWq(tiempos),\n                      FW2 = s.MM1.2$FW(tiempos),\n                      FWq2 = s.MM1.2$FWq(tiempos))\n# gráficos\ng1 <- ggplot(sistema, aes(tiempos, FW1)) +\n  geom_line(linetype = 1) +\n  geom_line(aes(tiempos, FW2), linetype = 2) +\n  labs(x = \"Tiempo (en horas)\", y = \"Probabilidad\", title = \"W(t)\")\ng2 <- ggplot(sistema, aes(tiempos, FWq1)) +\n  geom_line(linetype = 1) +\n  geom_line(aes(tiempos, FWq2), linetype = 2) +\n  labs(x = \"Tiempo (en horas)\", y = \"Probabilidad\", title = \"Wq(t)\")\ngrid.arrange(g1, g2, ncol = 2)"},{"path":"COLAS.html","id":"mm1k","chapter":"Unidad 5 Sistemas de colas","heading":"5.3.2 M/M/1/K","text":"Se trata de un modelo como el \\(M/M/1\\), ya estudiado, pero con límitación \\(K\\) para el tamaño de la cola. Es decir, la distribución del tiempo entre dos intentos de llegadas al sistema de clientes consecutivos es un PP de tasa \\(\\lambda\\), mietras que la distribución del tiempo de servicio es exponencial de media \\(1/\\mu\\) y sólo hay un servidor. Además el número de clientes que pueden estar en la cola es como mucho \\(K\\), la población potencial es infinita y la disciplina es FIFO. Obviamente, en este modelo se puede dar el caso de que un cliente que intente entrar en el sistema lo consiga, por estar la cola llena.En esta situación tenemos que las tasas de llegadas viene dadas por:\\[\n\\lambda_n =\n\\begin{cases}\n\\lambda & \\text{ si } n = 0, 1,...,K\\\\\n0 & \\text{ si } n = K+1, K+2,...\n\\end{cases}\n\\]\nmientras que las tasas de servicio se corresponden con la cola \\(M/M/1\\)\\[\n\\mu_n = \\mu, \\quad n = 1, 2,...\n\\]\ndonde partir de las ecuaciones de equilibrio podemos obtener la relación entre tasas de llegadas y servicio:\\[\nc_n =\n\\begin{cases}\n\\rho^n & \\text{ si } n = 0, 1,...,K, K+1\\\\\n0 & \\text{ si } n = K+2, K+3,...\n\\end{cases}\n\\]\nEn este caso, por muy frecuente que sea la llegada de clientes al sistema en relación con la capacidad del servidor para dar servicio, la propia limitación en el tamaño de la cola fuerza la estacionariedad, pues lo peor que podríamos imaginar es que prácticamente todo el tiempo estuviese el sistema saturado (es decir \\(P(N = K + 1) = 1\\)). Para analizar el comportamiento de la serie distinguiremos que \\(\\rho \\neq 1\\) y \\(\\rho = 1\\).Caso \\(\\rho \\neq 1\\)De esta forma, la distribución de probabilidad de la variable aleatoria del “número de clientes en el sistema” es:\\[\nP(N = n) = p_n =\n\\begin{cases}\n\\frac{\\rho - 1}{\\rho^{K+2} - 1} \\rho^n & \\text{ si } n = 0, 1,..., K+1\\\\\n0  & \\text{ si } n = K+2, K+3,...\n\\end{cases}\n\\]El número medio de clientes en el sistema es:\\[L = \\frac{\\rho}{1 - \\rho} - \\frac{(K + 2)\\rho^{K+2}}{1 - \\rho^{K+2}}\\]Dado que las tasas de llegada son contantes, necesitamos obtener el valor de \\(\\bar{\\lambda}\\) para aplicar la fórmula de Little al resto de cantidades de interés. En este caso:\\[\\bar{\\lambda} = \\frac{\\lambda(\\rho^{K+1} - 1)}{\\rho^{K+1} - 1}\\]partir de esta expresión podemos obtener el tiempo medio de espera de los clientes en la cola como:\\[W = \\frac{1}{\\mu - \\lambda} - \\frac{(K+1)\\rho^{K+2}}{\\lambda(1-\\rho^{K+1})}\\]De la relación entre \\(W\\) y \\(W_q\\) podemos obtener:\\[W_q = \\frac{\\lambda}{\\mu(\\mu - \\lambda)} - \\frac{(K+1)\\rho^{K+2}}{\\lambda(1-\\rho^{K+1})}\\]\nPor último:\\[L_q =  \\frac{\\rho^2}{1 - \\rho} - \\frac{(K + 1 + \\rho)\\rho^{K+2}}{1 - \\rho^{K+2}}\\]Caso \\(\\rho = 1\\)En este caso las fórmulas anteriroes se simplifican :\\[p_n = \\frac{1}{K+2}, \\text{ para } n = 0, 1,...,K + 1\\]\n\\[L = \\frac{K + 1}{2}\\]\n\\[\\bar{\\lambda} = \\frac{\\lambda(K + 1)}{K + 2}\\]\\[W = \\frac{K + 2}{2\\lambda}\\]\n\\[W_q = \\frac{K}{2\\lambda}\\]\n\\[L_q = \\frac{K(K + 1)}{2(K+2)}\\]En este modelo (y en otros posteriores) el significado de \\(\\rho\\) como intensidad de tráfico se desvirtúa. Aquí \\(\\rho\\) puede interpretarse como el cociente entre número medio de llegadas de clientes al sistema por unidad de tiempo y el número medio de clientes los que el servidor tendría capacidad de dar servicio por unidad de tiempo, sinó más bien como un cociente semejante, pero donde el númerador representa el número medio de intentos de llegada, más que de llegadas efectivas al sistema. De hecho, por este motivo \\(\\rho\\) puede ser mayor o igual que 1, aún siendo el sistema estacionario.\nEl valor de \\(\\bar{\\lambda}\\) sí representa el número medio de entradas efectivas de clientes en el sistema por unidad de tiempo y, así, la verdadera intensidad de tráfico podría medirse través de:\\[\n\\bar{\\rho} = \\frac{\\bar{\\lambda}}{\\mu} =\n\\begin{cases}\n\\frac{K+1}{K+2} & \\text{ si } \\rho = 1 \\\\\n\\frac{\\rho^{K+2}-\\rho}{\\rho^{K+2}-1} & \\text{ si } \\rho \\neq 1 \n\\end{cases}\n\\]\nque efectivamente sí es siempre menor que 1.::: {.example name = “Taller Mecánico”}En un taller mecánico llegan vehículos para una puesta punto antes de pasar la ITV, las llegadas siguen un proceso de Poisson de promedio 18 vehículos/hora. Las dimensiones del taller sólo permiten que haya 4 vehículos, y las ordenanzas municipales permiten esperar en la vía pública. El taller despacha un promedio de 6 vehículos/hora de acuerdo con una distribución exponencial. Se pide:¿Cuál es la probabilidad de que haya ningún vehículo en el taller?¿Cuál es el promedio de vehículos en el taller?¿Cuánto tiempo pasa por término medio un vehículo en el taller?¿Cuánto tiempo esperan por término medio los vehículos en la cola?¿Cuál es la longitud media de la cola?:::Se trata de un sistema \\(M/M/1/K\\) con \\(K = 4\\), y utilizaremos la librería queueing para los cálculos numéricos. Si tomamos como unidad de tiempo las horas tendremos que \\(\\lambda = 18\\) y \\(\\mu = 6\\). Geenramos el sistema de cola definido y procedemos con los cálculos solicitados.Las medidas proporcionadas por la función son las mismas que con el modelo \\(M/M/1\\). Comenzamos responder las preguntas:Apartado 1. La probabilidad de que haya ningún vehículo en el taller es \\(p_0\\):Apartado 2. Obtenemos el número medio de vehículos en el sistema \\(L\\):Apartado 3. En este caso estamos interesados en el tiempo medio de estancia en el sistema (\\(W\\)):Apartado 4. En este caso estamos interesados en el tiempo medio de estancia en la cola (\\(W_q\\)):Apartado 5. En este caso estamos interesados en el número medio de clientes en la cola (\\(L_q\\)):Para el resto de sistemas de colas que vamos presentar desarrollaremos de forma completa todas las fórmulas teóricas, y nos centraremos en los resultados numéricos que proporciona la libreria queueing para la resolución de aplicaciones.","code":"\n# Deficición del entorno\nenv.MM1K <- NewInput.MM1K(lambda = 18, mu = 6, k = 4)\n# Características del sistema\ns.MM1K <- QueueingModel(env.MM1K)\ns.MM1K$Pn[1]## [1] 0.008264463\ns.MM1K$L## [1] 3.520661\ns.MM1K$W## [1] 0.5916667\ns.MM1K$Wq## [1] 0.425\ns.MM1K$Lq## [1] 2.528926"},{"path":"COLAS.html","id":"COLASD","chapter":"Unidad 5 Sistemas de colas","heading":"5.4 Colas con múltiples servidores","text":"Generalizamos los modelos anteriores situaciones donde tenemos múltiples servidores.","code":""},{"path":"COLAS.html","id":"mms","chapter":"Unidad 5 Sistemas de colas","heading":"5.4.1 M/M/s","text":"Es una generalización del modelo \\(M/M/1\\) en el caso en que haya \\(s\\) servidores. Se trata pues de una cola en la que la distribución del tiempo entre llegadas consecutivas es una \\(exp(\\lambda)\\), la distribución del tiempo de servicio es \\(exp(\\mu)\\) y hay \\(s\\) servidores. En este caso la población potencial y la capacidad de la cola son infinitas y la disciplina de la cola es FIFO.Las tasas de llegadas vienen dadas por\\[\\lambda_n = \\lambda, \\text{ para } n = 0, 1,...\\]\ny las tasas de servicio\\[\\mu_n = \n\\begin{cases}\nn\\mu & \\text{ si } n = 1, 2,...,s\\\\\ns\\mu & \\text{ si } n = s+1, s+2,...\n\\end{cases}\n\\]con ratio de ocupación\\[\\rho = \\frac{\\lambda}{\\mu s}\\]partir de las ecuaciones de equilibrio podemos obtener la relación entre tasas de llegadas y servicio:\\[\nc_n =\n\\begin{cases}\n\\frac{\\lambda^n}{n!\\mu^n} & \\text{ si } n = 0, 1,...,s\\\\\n\\frac{\\lambda^s}{s!\\mu^s}\\rho^{n-s} & \\text{ si } n = s+1, s+2,...\n\\end{cases}\n\\]La suma de la serie de los \\(c_n\\) será convergente (el sistema es estacionario) si \\(\\rho < 1\\), es decir,\n\\(\\lambda < s\\mu\\).Ejemplo 5.1  En una determinada planta de fabricación, la operación final es una operación de pintura. En el centro de pintura siempre hay dos trabajadores que trabajan en paralelo, aunque debido la configuración física, pueden ayudarse mutuamente. Las llegdas al centro de pintura se producen según un proceso de Poisson con\ncon una tasa de llegada media de 100 al día. Cada trabajador tarda una media de 27 minutos en pintar cada artículo. Últimamente, el exceso de trabajo en curso es motivo de preocupación, por lo que la dirección está considerando ampliar el centro de pintura y contratar un tercer trabajador. (Se supone que el tercer trabajador, tras un periodo de formación, también tardará una media de 27 minutos por pieza). Otra opción sería comprar un robot para realizar la tarea de los trabajadores, ya que se sabe que el tiempo medio que tardará en cada pieza es de 10 minutos.Analiza cada uno de los tres sistemas respecto de las medidas de eficiencia e indica que alternativa reduciría el inventario.El coste del inventario (incluyendo la pieza que se está trabajando) se estima en 0,50 euros por pieza y hora. El coste por trabajador (salario y gastos generales) se estima en 40.000 euros al año, y el coste de instalación y mantenimiento de un robot se estima en 100.000 euros al año ¿Qué alternativa, si es que hay alguna, es justificable utilizando un criterio de coste esperado largo plazo?Se proponen tres sistemas de colas con las características siguientes (utilizando como unidad de tiempo las horas):Situación 1. Cola \\(M/M/2\\) con \\(\\lambda = 100/24\\) y \\(\\mu = 60/27\\)Situación 2. Cola \\(M/M/3\\) con \\(\\lambda = 100/24\\) y \\(\\mu = 60/27\\)Situación 3. Cola \\(M/M/1\\) con \\(\\lambda = 100/24\\) y \\(\\mu = 60/10\\)Para determinar que sistema mejoraría el estado del inventario utilizamos varias medidas relativas cada uno de ellos:ratio de ocupación,probabilidad de que el sistema este ocupado,tiempo medio de las piezas en el sistema.Definimos los tres sistemas y obtenemos las medidas de interés. Para los sistemas \\(M/M/s\\) utilizaremos la función NewInput.MMC, donde el parámetro \\(c\\) indica el número de servidores. Generamos los tres sistemas:Obtenemos y comparamos las diferentes medidas consideradasDesde el punto de vista de ratio de ocupación el mejor sistema sería el de tres trabajores, pero si utilizamos los otros dos criterios el mejor sistema sería el que utiliza el robot.Hacemos ahora la evaluación de costes por hora teniendo en cuenta que cada año tiene 8760 horas (365*24). Para obtener los costes asociados debemos estimar el número de piezas en el sistema por hora para evaluar el coste total de inventario, ay añadir el coste de la mano de obra. En esta situación tenemos:Atendiendo los costes, el modelo que utiliza el robot resulta en un menor coste por hora por lo que resulta el más beneficioso.","code":"\n# Parámetros de los sistemas\nlambda <- 100/24\nmuk <- 60/27\nmu1 <- 60/10\n\n# M/M/2\nenv.MM2 <- NewInput.MMC(lambda = lambda, mu = muk, c = 2, n = 2)\ns.MM2 <- QueueingModel(env.MM2)\n# M/M/3\nenv.MM3 <- NewInput.MMC(lambda = lambda, mu = muk, c = 3, n = 2)\ns.MM3 <- QueueingModel(env.MM3)\n# M/M/1\nenv.MM1 <- NewInput.MM1(lambda = lambda, mu = mu1, n = 2)\ns.MM1 <- QueueingModel(env.MM1)\n# ratio de ocupación\nc(s.MM2$RO, s.MM3$RO, s.MM1$RO)## [1] 0.9375000 0.6250000 0.6944444\n# Probabildid de que el sistema este ocupado\nc(1-s.MM2$Pn[1], 1-s.MM3$Pn[1], 1-s.MM1$Pn[1])## [1] 0.9677419 0.8677686 0.6944444\n# Tiempo medio en el sistema\nc(s.MM2$W, s.MM3$W, s.MM1$W)## [1] 3.7161290 0.6049587 0.5454545\n# Coste M/M/2\ns.MM2$L*0.50 + 2*(40000/8760)## [1] 16.87436\n# Coste M/M/3\ns.MM3$L*0.50 + 3*(40000/8760)## [1] 14.95896\n# Coste M/M/1\ns.MM3$L*0.50 + (100000/8760)## [1] 12.67586"},{"path":"COLAS.html","id":"mmsk","chapter":"Unidad 5 Sistemas de colas","heading":"5.4.2 M/M/s/K","text":"Es una generalización del modelo \\(M/M/1/K\\) en el caso en que haya \\(s\\) servidores. Las tasas de llegada son casi idénticas las del modelo \\(M/M/1\\), mientras que las de servicio son exáctamente iguales las de un \\(M/M/s\\):\\[\\lambda_n = \n\\begin{cases}\n\\lambda \\text{ para } n = 0, 1,..., K+s-1\\\\\n0 \\text{ para } n = K+s, K+s+1,...\n\\end{cases}\n\\]\\[\\mu_n = \n\\begin{cases}\nn\\mu & \\text{ si } n = 1, 2,...,s\\\\\ns\\mu & \\text{ si } n = s+1, s+2,...\n\\end{cases}\n\\]con ratio efectivo de ocupación\\[\\bar{\\rho} = \\frac{\\bar{\\lambda}}{\\mu s}\\]Este sistema siempre es estacionario. continuación, se presenta un ejemplo de este sistema donde se muestra la función que debemos usar para analiar este tipo de cola.Ejemplo 5.2  Por razones técnicas, una centralita con dos operadoras sólo permite mantener tres llamadas en espera (de tal forma que cualquier llamada producida cuando ya hay dos siendo atendidas por las operadoras y otras tres en espera, recibe el tono de “línea ocupada”). Las llamadas llegan según un proceso de Poisson, razón de 6 por minuto, siendo l5 segundos la media del tiempo que tarda cada operadora en direccionar una llamada y dicho tiempo de distribución exponencial. Calcular:El porcentaje de tiempo en que cada operadora está ocupada y el número medio de servidores ocupados.El número medio de llamadas en espera.La probabilidad de que una llamada obtenga la señal de “línea ocupada.”Calcular las tres cantidades anteriores bajo el supuesto de que se amplie 5 las llamadas en espera.Para el análisis de este sistema utilizamos la función NewInput.MMCK donde además de las tasas, debemos indicar el número de servidores, y la capacidad del sistema. Tomaremos como unidad de tiempo los minutos de forma que \\(\\lambda = 6\\) y \\(\\mu = 60/15 = 4\\). La capacidad del sistema es \\(K = 5\\) que se corresponde con dos llamadas atendidas y tres en espera. Se trata pues de un sistema \\(M/M/2/5\\).Veamos como responder cada una de las cuestiones planteadas utilizando los resultados del sistema diseñado. para responder al primer apartado debemos obtener el ratio efectivo de ocupación, asi como la diferencia entre el número medio de clientes en el sistema y el número medio de clientes en la cola para determinar el número medio de servidores ocupados.La ocupación de cada operadora es del 68.6% y el número medio de operadores ocupados es del 1.4. Con respecto al número medio de llamadas en espera tenemos:En cuanto la probabilidad solicitada debemos calcular \\(P(N_q = 3) = P(N = 5)\\) que se obtiene como:Tan solo en un 8.5% de las ocasiones salta el mensaje de línea ocupada, es decir, el sistema esta ocupado al 100%.Evaluamos ahora el incremento del tamaño de sistema aumentado las llamadas en espera.","code":"\n# M/M/2/5\nenv.MM25 <- NewInput.MMCK(lambda = 6, mu = 4, c = 2, k = 5)\ns.MM25 <- QueueingModel(env.MM25)## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n# Porcentaje de tiempo servidor ocupado\nround(100*s.MM25$RO, 2)## [1] 68.62\n# Número medio de servidores ocupados\ns.MM25$L - s.MM25$Lq## [1] 1.372329\n# Número medio de llamadas en espera\ns.MM25$Lq## [1] 0.6336252\n# Probabilidad de linea ocupada\ns.MM25$Pn[6]## [1] 0.08511384\n# M/M/2/7\nenv.MM27 <- NewInput.MMCK(lambda = 6, mu = 4, c = 2, k = 7)\ns.MM27 <- QueueingModel(env.MM27)## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n\n## Warning in formals(fun): argument is not a function\n# Porcentaje de tiempo servidor ocupado\nround(100*s.MM27$RO, 2)## [1] 71.77\n# Número medio de servidores ocupados\ns.MM27$L - s.MM27$Lq## [1] 1.435402\n# Número medio de llamadas en espera\ns.MM27$Lq## [1] 1.014966\n# Probabilidad de linea ocupada\ns.MM27$Pn[8]## [1] 0.04306559"},{"path":"COLAS.html","id":"COLASE","chapter":"Unidad 5 Sistemas de colas","heading":"5.5 Redes de colas en serie","text":"Una red de colas en serie es una colección de \\(K\\) colas que se suceden unas otras de tal manera que sólo es posible la entrada de clientes dede fuera del sistema la primera de ellas, produciéndose la salida de ellas tras el servicio de la última cola. En esta situación podemos definir las medidas de eficiencia del sistema completo de colas en función de las medidas de efiecencia de cada una de las colas que conforman el sistema, teniendo en cuenta que tan sólo hay una tasa de llegada que corresponde con la cola inicial de la red.Imaginemos \\(=1,2,...,k\\) colas en red del tipo \\(M/M/s_i\\) independientes con tasa de entrada \\(\\lambda\\) y tasa de servicio \\(\\mu_i\\), y con medidas de eficiencia \\(L_i, W_i, L_{q_i}, W_{q_i}\\). Dadoq ue en este caso el flujo de un cliente través de la red es secuencial será cierto que los tiempos medios de un cliente en la red son la suma de los correspondientes cada subsistema. Si denotamos por \\(L_{red}, W_{red}, L_{q_{red}}, W_{q_{red}}\\) las medidas de eficencia del sistema, aplicando este razonamiento tenemos que:\\[L_{red} = \\sum_{= 1}^k L_i\\]\\[W_{red} = \\sum_{= 1}^k W_i\\]\\[W_{q_{red}} = W_{red} - \\left(\\sum_{= 1}^k \\frac{1}{\\mu_i}\\right)\\]\\[L_{q_{red}} = \\lambda W_{q_{red}}\\]de esta forma basta con analizar cada una de las clas que conforman la red para estudiar el comportamiento global del sistema.Ejemplo 5.3  Una empresa de ITV en una localidad dispone de una superficie que consta de tres partes: Una caseta donde los clientes entregan la documentación del vehículo y realizan el pago de tasas, sin restricciones paa atender ningún vehículo. Una nave formada por dos circuitos (revisión y oficina de personal técnico) atendidos por dos técnicos cada uno de ellos. Los vehículos que llegan la nave son atendidos con una tasa de servicio medio de 45 clientes/hora para la revisión y 2 minutos/cliente en la oficina de personal técnico. Los coches acuden la empresa una media de 57 clientes/hora, ya que un mayor número de vehículos colapsaría el trabajo de la caseta, cuyo empleado atiende un ritmo medio de 1 cliente/minuto. Las llegadas siguen un Proceso de Poisson y los tiempos de servicio se distribuyen según una variable exponencial. Se pide:Factor de utilziación o intensidad de tráfico en cada nodo de la red.Probabildiades de que haya ningún cliente en cada uno de los nodos de la red.Longitud media de la cola de vehículos que habiendo pagado las tasas se encuentran esperando la entrada de la nave.Tiempo medio que un cliente pasa en la revisión.Tiempo medio que un cliente pasa en la oficina de personal técnico.Tiempo medio que un cliente se encuentra en la ITV.Para agilizar el proceso la empresa estudia la posibilidad de ampliar el número de servidores en la caseta o en la oficina. Suponiendo que el coste de ampliación en uno u otro lugar fuera equivalente, ¿qué criterio sería más acertado para que el tiempo de servicio del sistema fuera menor?El sistema se puede describir com una red de colas en serie con nodos: caseta (\\(M/M/1\\)), equipamiento (\\(M/M/2\\)) y personal técnico (\\(M/M/2\\)), con tasas de llegadas y servicio (expresadas en minutos) dadas por:\\[\\lambda_1 = \\lambda_2 = \\lambda_3 = 57/60 = 0.95\\]\\[\\mu_1 = 1; \\mu_2 = 45/60 = 0.75; \\mu_3 = 1/2 = 0.5\\]Planteamos los tres sistemas de colas y obtenemos las correspondientes medidas de eficiencia:","code":"\n# M/M/1\nnodo1 <- QueueingModel(NewInput.MM1(lambda = 0.95, mu = 1, n = 15))\n# M/M/2\nnodo2 <- QueueingModel(NewInput.MMC(lambda = 0.95, mu = 0.75, c = 2, n = 15))\n# M/M/2\nnodo3 <- QueueingModel(NewInput.MMC(lambda = 0.95, mu = 0.5, c= 2, n = 15))\n# Medidas de eficiencia de cada nodo\nef.nodo1 <- c(nodo1$RO, nodo1$L, nodo1$Lq, nodo1$W, nodo1$Wq, nodo1$Pn[1]) \nef.nodo2 <- c(nodo2$RO, nodo2$L, nodo2$Lq, nodo2$W, nodo2$Wq, nodo2$Pn[1]) \nef.nodo3 <- c(nodo3$RO, nodo3$L, nodo3$Lq, nodo3$W, nodo3$Wq, nodo3$Pn[1])\neficiencia <- data.frame(rbind(ef.nodo1, ef.nodo2, ef.nodo3))\nnames(eficiencia) <-c(\"Ro\", \"L\", \"Lq\", \"W\", \"Wq\",\"P_0\") \neficiencia##                 Ro         L         Lq         W         Wq        P_0\n## ef.nodo1 0.9500000 19.000000 18.0500000 20.000000 19.0000000 0.05000000\n## ef.nodo2 0.6333333  2.115028  0.8483612  2.226345  0.8930118 0.22448980\n## ef.nodo3 0.9500000 19.487179 17.5871795 20.512821 18.5128205 0.02564103"},{"path":"COLAS.html","id":"COLASF","chapter":"Unidad 5 Sistemas de colas","heading":"5.6 Funciones simmer","text":"En este apartado se presentan los algoritmos de simulación de simmer para los sistemas de colas estudiados.","code":""},{"path":"COLAS.html","id":"mm1-1","chapter":"Unidad 5 Sistemas de colas","heading":"5.6.1 \\(M/M/1\\)","text":"","code":"\n# Sistema\n#################################################\ncola.MM1 <- function(t, lambda, mu)\n{\n  # lambda: tasa de llegadas\n  # mu: tasa de servicio\n\n  # Funciones de tiempos\n  tarrival <- function() rexp(1, lambda)\n  tserver <- function() rexp(1, mu)\n  \n  # Trayectoria de servicio\n  servicio <- trajectory() %>%\n    visit(\"server\", tserver)               \n\n  # Entorno del sistema \n  #################################################\n  simmer() %>%\n    add_resource(\"server\", capacity = 1, queue_size = Inf) %>%           \n    add_generator(\"arrival\", servicio, tarrival) %>% \n    run(until = t)     \n}"},{"path":"COLAS.html","id":"mm1k-1","chapter":"Unidad 5 Sistemas de colas","heading":"5.6.2 \\(M/M/1/K\\)","text":"","code":"\n# Sistema\n#################################################\ncola.MM1K <- function(t, lambda, mu, K)\n{\n  # lambda: tasa de llegadas\n  # mu: tasa de servicio\n  # K: capacidad del sistema\n\n  # Funciones de tiempos\n  tarrival <- function() rexp(1, lambda)\n  tserver <- function() rexp(1, mu)\n  \n  # Tamaño de la cola\n  qsize <- K - 1\n  \n  # Trayectoria de servicio\n  servicio <- trajectory() %>%\n    visit(\"server\", tserver)               \n\n  # Entorno del sistema \n  #################################################\n  simmer() %>%\n    add_resource(\"server\", capacity = 1, queue_size = qsize) %>%           \n    add_generator(\"arrival\", servicio, tarrival) %>% \n    run(until = t)     \n}"},{"path":"COLAS.html","id":"mms-1","chapter":"Unidad 5 Sistemas de colas","heading":"5.6.3 \\(M/M/s\\)","text":"","code":"\n# Sistema\n#################################################\ncola.MMs <- function(t, lambda, mu, s)\n{\n  # lambda: tasa de llegadas\n  # mu: tasa de servicio\n  # s: servidores idénticos disponibles\n\n  # Funciones de tiempos\n  tarrival <- function() rexp(1, lambda)\n  tserver <- function() rexp(1, mu)\n  \n  # Trayectoria de servicio\n  servicio <- trajectory() %>%\n    visit(\"server\", tserver)               \n\n  # Entorno del sistema \n  #################################################\n  simmer() %>%\n    add_resource(\"server\", capacity = s, queue_size = Inf) %>%           \n    add_generator(\"arrival\", servicio, tarrival) %>% \n    run(until = t)     \n}"},{"path":"COLAS.html","id":"mmsk-1","chapter":"Unidad 5 Sistemas de colas","heading":"5.6.4 \\(M/M/s/K\\)","text":"","code":"\n# Sistema\n#################################################\ncola.MMsK <- function(t, lambda, mu, s, K)\n{\n  # lambda: tasa de llegadas\n  # mu: tasa de servicio\n  # s: servidores\n  # K: capacidad del sistema\n\n  # Funciones de tiempos\n  tarrival <- function() rexp(1, lambda)\n  tserver <- function() rexp(1, mu)\n  \n  # Tamaño de la cola\n  qsize <- K - s\n  \n  # Trayectoria de servicio\n  servicio <- trajectory() %>%\n    visit(\"server\", tserver)               \n\n  # Entorno del sistema \n  #################################################\n  simmer() %>%\n    add_resource(\"server\", capacity = s, queue_size = qsize) %>%           \n    add_generator(\"arrival\", servicio, tarrival) %>% \n    run(until = t)     \n}"},{"path":"COLAS.html","id":"COLASG","chapter":"Unidad 5 Sistemas de colas","heading":"5.7 Ejercicios","text":"Los ejercicios que se presentan continuación se estruturan en dos niveles de dificultad. El primer nivel son ejercicios más básicos (codificados con una B que provienen de los ejemplso vistos en la unidad), mientras que el segundo bloque necesitan una mayor cantidad de trabajo (codificados con una ). Cuando consideres necesario puedes plantear una solución mediante simulación para contestar las preguntas de interés.Ejercicio B-1. Para el ejemplo del sistema de la estación de trabajo descrito para el sistema \\(M/M/1\\) vamos contestar las diferentes cuestiones que allí se planteaban pero considerando que la estación de trabajo dispone de tres servidores idénticos. Hallar también el número medio total de procesos en la estación.Ejercicio -1. Los coches llegan un peaje 24 horas al día según un proceso de Poisson con\nuna tasa media de 15 por hora. Estamos interesados en:¿Cuál es el número esperado de coches que llegarán la cabina entre la 1:00 p.m. y 1:30 p.m.?¿Cuál es el tiempo esperado entre dos coches que llegan consecutivamente?Son las 13:12 y acaba de llegar un coche. ¿Cuál es el número esperado de coches que llegarán entre este momento y la 1:30 p.m.?Son las 13:12 y acaba de llegar un coche. ¿Cuál es la probabilidad de que lleguen dos más coches lleguen de aquí las 13:30?Son las 13:12 y el último coche en llegar lo hizo las 13:05. ¿Cuál es la probabilidad de que lleguen más coches hasta las 13:30?Son las 13:12 y el último coche en llegar lo hizo las 13:05. ¿Cuál es la tiempo esperado entre la llegada del último coche y la del siguiente?Ejercicio -2. Un gran hotel ha colocado un ordenador para uso de los clientes en una sala de atención al cliente. La llegada de clientes que necesitan utilizar el ordenador sigue un proceso de Poisson con una media de ocho por hora. El tiempo que cada persona utiliza el ordenador es muy variable y se aproxima mediante una distribución exponencial con un tiempo medio de 5 minutos. El hotel está interesado en:¿Cuál es la probabilidad de que la sala donde está el ordenador esté vacía?¿Cuál es la probabilidad de que nadie esté esperando para utilizar el ordenador?¿Cuál es el tiempo medio que un cliente debe esperar en la cola para utilizar el ordenador?¿Cuál es la probabilidad de que un cliente que llega vea dos personas esperando en cola?Ejercicio -3. Una prensa de taladro en un taller de trabajo tiene piezas que llegan para ser taladradas de acuerdo con un proceso de Poisson con una tasa media de 15 por hora. El tiempo medio que se tarda en completar cada pieza es una variable aleatoria con una función de distribución exponencial cuya media es de 3 minutos. Estamos interesados en conocer:¿Cuál es la probabilidad de que el taladro esté ocupado?¿Cuál es el número medio de piezas en espera de ser taladradas?¿Cuál es la probabilidad de que al menos una pieza esté esperando para ser taladrada?¿Cuál es el tiempo medio que pasa una pieza en la sala de taladrado?la empresa le cuesta 8 céntimos por cada minuto que pasa cada pieza en la sala de taladrado. Por un gasto adicional de 10 euros por hora, la empresa puede disminuir la duración media de la operación de taladrado 2 minutos. ¿Merece la pena el coste adicional?Ejercicio -4. Una tienda de alimentacion es atendida por una persona. Aparentemente el patr ´ de llegadas de clientes durante los sabados se comporta siguiendo un proceso de Poisson con una tasa de llegadas de 10 personas por hora. los clientes se les atiende siguiendo un orden tipo FIFO y debido al prestigio de la tienda, una vez que llegan estan dispuestos esperar el servicio. Se estima que el tiempo que se tarda en atender un cliente se distribuye exponencialmente, con un tiempo medio de 4 minutos.\nDetermina:La probabilidad de que haya alguién en la cola.La longitud media de la cola.Tiempo medio que un cliente permanece en la cola.Ejercicio -5. En una fabrica existe una oficina de la Seguridad Social la que los obreros tienen acceso durante las horas de trabajo. El jefe de personal, que ha observado la afluencia de obreros la ventanilla, ha solicitado que se haga un estudio relativo al funcionamiento de este servicio. Se designa un especialista para que determine el tiempo medio de espera de los obreros en la cola y la duracion\nmedia de la conversacion que cada uno mantiene con el empleado de la ventanilla. Este analista\nllega la conclusion de que durante la primera y la última media hora de la jornada la afluencia es\nmuy reducida y fluctuante, pero que durante el resto de la jornada el fenómeno se puede considerar\nestacionario. Del analisis de 100 periodos de 5 minutos, sucesivos o , pero situados en la fase\nestacionaria, se dedujo que el numero medio de obreros que acudían la ventanilla era de 1.25 por\nperiodo y que el tiempo entre llegadas seguía una distribucion exponencial. Un estudio similar sobre\nla duracion de las conversaciones, llevó la conclusión de que se distribuían exponencialmente con\nduracion media de 3.33 minutos. Determina:Número medio de obreros en cola.Tiempo medio de espera en la cola.Compara el tiempo perdido por los obreros con el tiempo perdido por el oficinista. Calcula el coste para la empresa, sin una hora de inactividad del oficinista vale 250 euros y una hora del obrero 400 euros.Ejercicio -6. Una compañía ferroviaria pinta sus propios vagones, según se vayan necesitando, en sus propios talleres donde se pinta mano de uno en uno con una velocidad que se distribuye según una exponencial de media uno cada 4 horas y un coste anual de 4 millones de euros. Se ha determinado que los vagones pueden llegar según un proceso de Poisson de media uno cada 5 horas. Además el coste por cada vagón que está activo es de 500 euros la hora.Se plantean otras dos posibilidades. Una es encargar dicho trabajo una empresa de pintura que lo haría con aerosol con el consiguiente ahorro de tiempo. Sin embargo el presupuesto para esta segunda alternativa es de 10 millones de euros anuales. En este caso, el proceso se aproxima uno de Poisson con una tasa de uno cada 3 horas. La otra opción es poner otro taller exactamente igual al que hay actualmente, con igual tasa de servicio y coste anual que permita pintar dos vagones la vez.En todos los casos el trabajo se considera ininterrumpido, esto es, se trabajan 24 × 365 = 8760 horas anuales. ¿Cuál de los tres procedimientos es preferible?Ejercicio -7. Un taller utiliza 10 máquinas idénticas. Cada máquina deja de funcionar en promedio una vez cada 7 horas. Un operario puede reparar una máquina en 4 horas en promedio, pero el tiempo de reparación real varía según una distribución exponencial.Interpretar y comparar las respuestas:\n* El número mínimo de mecánicos que se necesita para que el número estimado de máquinas que fallan sea menor que 4.\n* El número mínimo de mecánicos que se necesita, de manera que la demora esperada hasta que se repare una máquina sea menor que 4 horas.Ejercicio -8. Un asesor fiscal dispone de un local para atender sus clientes, los cuales se\nconcentran mayoritariamente entre los meses de mayo y junio. El local tiene una capacidad máxima de 8 asientos en espera, el cliente se va si encuentra un asiento libre, y el tiempo entre llegada de clientes se puede considerar distribuido exponencialmente con 20 clientes/hora en período punta. El tiempo de una consulta esta distribuido exponencialmente con una media de 12 minutos.¿Cuántas consultas por hora realizará en promedio?¿Cuál es el tiempo medio de permanencia en el local?Ejercicio -9. Un estudiante trabaja como encargado de una biblioteca por las noches y es el único en el mostrador durante todo su turno de trabajo. Las llegadas al mostrador siguen una distribución de Poisson con una media de 8 por hora. Cada usuario de la biblioteca es atendido de uno en uno, y el tiempo de servicio sigue una distribución exponencial con una media de 5 minutos.¿Cuál es la probabilidad de que se forme cola?¿Cuál es la longitud media de la cola?¿Cuál es el tiempo medio que un cliente pasa en la biblioteca hasta que le han atendido?¿Cuál es el tiempo medio que un cliente pasa en la cola esperando que le atiendan?El estudiante pasa su tiempo en que hay clientes clasificando artículos de revistas. Si puede clasificar 22 fichas por hora como media cuando trabaja continuamente, ¿cuántas fichas puede ordenar durante su trabajo?Ejercicio -10. Una compañía de alquiler de coches tiene un servicio de mantenimiento de coches (revisión del aceite, frenos, lavado…) que sólo es capaz de atender los coches de uno en uno y que trabaja 24 horas al día. Los coches llegan al taller con una media de 3 coches por día. El tiempo que dura el servicio de mantenimiento de un coche sigue una distribución exponencial de media 7 horas. El servicio de\nmantenimiento cuesta la compañía 375 euros por día. La compañía estima en 25 euros/día el coste de tener el coche parado sin poderse alquilar. La compañía se plantea la posibilidad de cambiar el servicio de mantenimiento por uno más rápido que puede bajar el tiempo de mantenimiento una media de 5 horas, pero esto también supone un incremento del coste. ¿Hasta que valor puede aumentar el coste para que la compañía contrate los nuevos servicios de mantenimiento?Ejercicio -11. Nuestro local de comida rápida, “Panis,” tiene mucho que aprender sobre teoría\nde colas. Insta los clientes que formen 3 colas en las que se distribuyen de forma aleatoria delante de los empleados durante el periodo de comidas diario. Además han instalado entre las tres colas barreras para que los clientes se pasen otras colas para prevenir que la gente se “cambie de cola.” Llegan los\nclientes según una distribución de Poisson con una media de 60 por hora y el tiempo en que un cliente es servido varía según una distribución exponencial de media 150 segundos. Asumiendo el estado permanente del sistema, ¿cuál es el tiempo medio de estancia del cliente hasta que ha sido atendido? El gerente de “Panis” ha creído ahora que es preferible una única cola para distribuir finalmente los tres servidores y por tanto las barreras son eliminadas. ¿cuál es el tiempo de espera de este modo?Ejercicio -12. Una organización está actualmente envuelta en el establecimiento de un centro de telecomunicaciones para tener una mejor capacidad de las mismas. El centro deberá ser el responsable de la salida de los mensajes así como de la entrada y distribución dentro de la organización. El encargado del centro es el responsable de determinar los operadores que deben trabajar en él. Los operarios encargados de la salida de mensajes son responsables de hacer pequeñas correcciones los mensajes, mantener un índice de códigos y un fichero con los mensajes salientes en los últimos 30 días, y por supuesto, transmitir el mensaje. Se ha establecido que este proceso es exponencial y requiere una media de 28 min/mensaje. Los operarios de transmisión trabajarán en el centro 7 horas al día y cinco días la semana. Todos los mensajes salientes serán procesados según el orden en que se vayan recibiendo y siguen una distribución de Poisson con una media de 21 por cada 7 horas diarias. Los mensajes deben ser atendidos en 2 horas como máximo. Determine el número mínimo de personal que se necesita para cumplir este criterio de servicio.Ejercicio -13. La empresa “Refrigeración Hermanos Pérez” debe elegir entre dos tipos de sistema para el mantenimiento de sus camiones. Se estima que los camiones llegarán al puesto de mantenimiento de acuerdo con una distribución exponencial de media 40 minutos y se cree que este ratio de llegada es independiente del sistema de servicio que se establezca. El primer tipo de sistema puede atender dos camiones en paralelo, y cada camión se le haría todo el servicio en una media de 30 minutos (el tiempo sigue una distribución exponencial). En el segundo sistema sólo se podría atender un camión pero el tiempo medio en que se realiza el mantenimiento de un camión es de 15 minutos (distribución exponencial). Para ayudar al encargado de la decisión responda las siguientes cuestiones:¿cuántos camiones habrá por término medio habrá en cualquiera de los dos sistemas?¿Cuánto tiempo pasará cada camión en el taller en cualquiera de los dos sistemas?El encargado estima que cada minuto que un camión pasa en el taller reduce los beneficios en 2 euros. Se sabe que el sistema de dos camiones en paralelo tiene un coste de un euro por minuto. ¿Qué debería costar el segundo sistema para que haya diferencia económica entre los dos?Ejercicio -14. Una empresa que alquila ordenadores, considera necesario revisarlos una vez al año. La primera alternativa, con un coste de 750.000 € es hacer un mantenimiento manual en el que cada ordenador necesitaría un tiempo que sigue una distribución exponencial con una media de 6 horas. La segundo opción sería un mantenimiento con máquinas, con un coste de un millón de euros, en este caso el tiempo de mantenimiento es de 3 horas con una distribución exponencial. Para ambas alternativas los ordenadores llegan siguiendo una distribución de poisson 3 al día. El tiempo en que está parado un ordenador tiene un coste de 150 € por hora. ¿Qué alternativa debe elegir la empresa? Se asume que la empresa trabaja 24 horas, 365 días al año.Ejercicio -15. Un pequeño autoservicio de lavado en el que el coche que entra puede hacerlo hasta que el otro haya salido completamente, tiene una capacidad de aparcamiento de 10 coches, incluyendo el que está siendo lavado. La empresa ha estimado que los coches llegan siguiendo una distribución de Poisson con una media de 20 coches/hora, el tiempo de servicio sigue una distribución exponencial de 12 minutos. La empresa abre durante 10 horas al día. ¿Cuál es la media de coches perdidos cada día debido las limitaciones de espacio?Ejercicio -16. La compañía “Gasolinas y Aceites SA” es la encargada de descargar los barcos cargados de petróleo que llegan al puerto y llevarlo la refinería. En el puerto tiene 6 muelles de descarga y 4 equipos para la descarga del barco. Cuando los muelles están llenos, los barcos se desvía muelles de espera hasta que les toca su turno. Los barcos llegan según una media de uno cada 2 horas. Para descargar el barco se necesita una media de 10 horas, siguiendo una distribución exponencial. La compañía desea saber los siguientes datos:Por término medio, ¿cuántos barcos hay en el puerto?Por término medio, ¿cuánto tiempo pasa un barco en el puerto?¿cuál es la media de llegada de los barcos los muelles de espera?La compañía estudia la posibilidad de construir otro muelle de descarga. La construcción y mantenimiento del puerto costaría X € al año. La compañía estima que desviar un barco hacia los muelles de espera cuando los muelles de descarga están llenos tiene un coste de Y €. ¿Cuál es la relación entre X e Y para que la compañía construya otro puerto de descarga?Ejercicio -17. Uno de los hospitales de la ciudad de Valencia ofrece todos los miércoles por la noches revisiones gratis de vista. Un test necesita, por término medio, 20 minutos distribuyéndose según una exponencial. Los clientes llegan según una distribución de Poisson de media 6/hora, y los pacientes se atienden según norma FIFO. Los encargados del hospital desean saber que cantidad de personal sanitario deben disponer. Para ello habría que calcular para diferentes cantidades de doctores: 1) ¿cuál es el número medio de gente esperando? 2) el tiempo medio que un cliente pasa en la clínica y 3) el tiempo medio que los doctores están parados.Ejercicio -18. Una estación de ITV cuenta con tres puestos para inspección y en cada uno sólo puede ser atendido un coche. Cuando un coche sale de un puesto la vacante es ocupada por otro que está en cola. La llegada de coches sigue una distribución de Poisson con una media de un coche por minuto en sus horas punta, que duran tres horas. En el parking sólo caben 4 vehículos. El tiempo de inspección sigue una distribución exponencial de media 6 minutos. El inspector jefe desea saber el número medio de coches en la estación, el tiempo medio (incluida la inspección) de espera, y el número medio de coches en cola debido que los puestos están ocupados. ¿Cuántos coches tendrán que volver en otro momento?Ejercicio -19. En el departamento de emergencia de un hospital los pacientes llegan mediante un Proceso de Poisson 3 clientes/hora. El médico que está en dicho departamento los atiende con una frecuencia de servicio exponencial una tasa de 4 clientes/hora. ¿Contrataría o un segundo médico? Para responder esta pregunta se deben comparar las siguientes características en ambos sistemas:Probabilidad de que se encuentren pacientes en el departamento de emergencias.Probabilidad de que existan 3 pacientes en el departamento de emergencias.Tiempo total del cliente en el departamento de emergencias.Tiempo total de espera por en el departamento de emergencias.El número de pacientes en el departamento de emergencias en un momento dado.El número de pacientes en el departamento de emergencias esperando ser atendidos.Probabilidad de que el cliente espere más de 1 hora en el departamento de emergencias.Probabilidad de que el cliente espere más de 1 hora en ser atendido en el departamento de emergencias.Ejercicio -20. Una base de mantenimiento de aviones dispone de recursos para revisar unicamente un motor de avión la vez. Por tanto, para devolver los aviones lo antes posible, la política que se sigue consiste en aplazar la revision de los 4 motores de cada avión. En otras palabras, solamente se revisa un\nmotor cada vez que un avión llega la base. Con esta política, los aviones llegan segun una distribucion de Poisson de tasa media uno al día. El tiempo requerido para revisar un motor (una vez que se empieza el trabajo) tiene una distribucion exponencial de media 1/2 día. Se ha hecho una propuesta para cambiar la política de revision de manera que los 4 motores se revisen de forma consecutiva cada vez que un avión llegue la base. pesar de que ello supondría cuadruplicar el tiempo esperado de servicio, cada avion necesitaría ser revisado unicamente con una frecuencia 4 veces menor. Utliza las medidas descriptivas del sistema para comparar ambas políticas.Ejercicio -21. Una pequeña estación de servicio junto una autopista interestatal está abierta las 24 horas al día y tiene un surtidor y espacio para otros dos coches. El proceso de llegadas es un PP con tasa media de llegada de 8 coches/hora y el tiempo medio de servicio en el surtidores es una variable aleatoria exponencial de 6 minutos. El beneficio esperado de cada coche es de 5 dólares. Por 60 dólares más al día, el propietario de la estación puede aumentar la capacidad de los coches en espera en uno. Analiza cada uno de los sistemas propuestos y determina si merece la pena pagar 60 dólares más.Ejercicio -22. Un centro de reparación dentro de una planta de fabricación está abierto las 24 horas del día y siempre hay una persona presente. La llegada de artículos que necesitan ser reparados en el centro de reparación se ajusta un proceso de Poisson con una tasa media de 6 por día. La duración de la reparación de los artículos es muy variable y sigue una distribución exponencial con una media de 5 horas. La política de gestión actual es permitir un máximo de tres trabajos en el centro de reparación. Si hay tres trabajos en el centro y llega un cuarto, el trabajo se envía un contratista externo que devolverá el trabajo 24 horas más tarde. Por cada día que un artículo está en el centro de reparaciones, le cuesta la empresa 30 euros. Cuando un artículo se envía al contratista externo, le cuesta la empresa 30 euros por el tiempo perdido, más 75 euros por la reparación. Contesta las cuestiones siguientes:Se ha sugerido que la dirección cambie la política para permitir cuatro trabajos en el centro; así los trabajos se enviarían al contratista externo sólo cuando haya cuatro presentes. ¿Es esta una política mejor?¿Cuál sería la política de corte óptima? En otras palabras, ¿qué nivel sería mejor enviar los trabajos excedentes al contratista externo?El personal y el mantenimiento del centro de reparaciones durante las 24 horas del día cuestan 400 por día. ¿Es una política económica acertada o sería mejor cerrar el centro de reparaciones centro de reparaciones y utilizar sólo el contratista externo?Ejercicio -23. Una pequeña tienda de informática tiene dos dependientes para atender los clientes (pero capacidad infinita para retener los clientes). Los clientes llegan la tienda según un proceso de Poisson con una tasa media de 5 por hora. El 50% de los que llegan quieren comprar hardware y el 50% quiere comprar software. La política actual de la tienda es que un dependiente atiende sólo los clientes de software y otro para atender sólo los clientes de hardware, por lo que la tienda actúa como dos sistemas M/M/1 independientes. Tanto si el cliente quiere hardware como software, el tiempo que pasa con uno de los dependientes de la tienda se distribuye exponencialmente con una media de 20 minutos. El propietario de la tienda está considerando cambiar la política de funcionamiento de la tienda y hacer que los dependientes ayuden tanto con el software como con el hardware; así, nunca habría nunca habrá un dependiente inactivo cuando haya dos o más clientes en la tienda. La desventaja es que los dependientes serían menos eficientes, ya que tendrían que ocuparse de algunas cosas que conocen. Se calcula que el cambio aumentaría el tiempo medio de tiempo de servicio 21 minutos.Si el objetivo es minimizar el tiempo de espera esperado de un cliente, ¿qué política es la mejor?Si el objetivo es minimizar el número esperado de clientes en la tienda, ¿qué política es la mejor?Ejercicio -24. Los clientes llegan una cola de una estación un ritmo de cinco por hora. Cada cliente necesita una media de 78 minutos de servicio. ¿Cuál es el número mínimo de servidores necesarios para mantener el sistema estable? ¿Cuál es el número esperado de servidores ocupados si el sistema emplea \\(s\\) servidores (\\(1 \\leq s \\leq 10\\))? ¿¿Cuántos servidores son necesarios si la legislación laboral estipula que un servidor puede estar ocupado más del 80% del tiempo?Ejercicio -25. Los clientes llegan una barbería según un proceso de Poisson un ritmo de ocho por hora. Cada cliente requiere 15 minutos de media. La barbería tiene cuatro sillas y un solo barbero. Un cliente espera si todas las sillas están ocupadas. Suponiendo una distribución exponencial de los tiempos de servicio:Calculae el tiempo esperado que pasa un cliente en la barbería.Supongamos que el barbero cobra 12 euors por el servicio. Calcula la tasa de ingresos largo plazo del barbero. (Pista: ¿Qué fracción de los clientes que llegan ingresan?)Supongamos que el barbero contrata un ayudante, por lo que ahora hay dos barberos. ¿Cuál es la nueva tasa de ingresos?Supongamos que el barbero instala una silla más para que los clientes esperen. ¿Cuánto aumentan los ingresos debido la silla adicional?Ejercicio -26. Una máquina produce artículos de uno en uno, siendo los tiempos de producción iid exponenciales con media \\(1/\\lambda\\). Los artículos producidos se almacenan en un almacén de capacidad \\(K\\). Cuando el almacén está lleno, la máquina se apaga, y se vuelve encender cuando el almacén tiene espacio para al menos un artículo. La demanda de los artículos se produce según un \\(PP(\\mu)\\). La demanda que puede satisfacerse se pierde. Supongamos que el tiempo medio de tiempo de fabricación es de 1 hora y la tasa de demanda es de 20 al día. Supongamos que la capacidad del capacidad del almacén es de 10.Calcula la fracción de tiempo que la máquina está apagada largo plazo.Calcula la fracción de la demanda perdida largo plazo.Cuando un artículo entra en el almacén, su valor es de 100 euros Sin embargo, pierde valor razón de\n1 euro por hora mientras espera en el almacén. Así, si un artículo ha estado en el almacén durante 10 horas cuando se vende, sólo alcanza 90 euros Calcule los ingresos largo plazo por hora.Ejercicio -27. Una sucursal bancaria dispone de 3 cajeros automáticos. De vez en cuan- el papel de algún cajero se atasca y el aparato deja de funcionar hasta que uno de los empleados (especialmente adiestrado para llevar cabo esta tarea) consigue arreglar la avería. Se sabe que el tiempo que utiliza dicho empleado sigue una distribución exponencial con media de l0 minutos, mientras que la distribución del tiempo que un cajero está fun- cionando hasta que se atasca el papel es también exponencial pero con media de 2 horas. Calcular:La probabilidad de que funcionen los tres cajeros.El número medio de cajeros averiados.El tiempo medio que un cajero está averiado.Si en un momento dado funcionan los tres cajeros, ¿cuál es el tiempo medio hasta la próxima avería?Ejercicio -28. Un laboratorio de informática consta de 5 estaciones de trabajo. Cada estación se avería, por término medio, una vez cada 30 días, siendo el tiempo hasta la próxima avería, de distribución exponencial. El laboratorio dispone de dos personas que, en caso de ser necesario, pueden arreglar estas averías. El tiempo de reparación (para cada uno de los técnicos) es exponencial, con media de 3 días. Calcular:El número medio de estaciones funcionando.El porcentaje de tiempo que cada uno de los técnicos puede dedicar otras tareas ajenas la reparación de las estaciones.Ejercicio -29. una máquina perforadora de una cadena de producción llegan mecanismos de interruptores diferenciales según un proceso de Poisson, con media de l0 por minuto. El tiempo, en minutos, necesario para llevar cabo la perforación del mecanismo es de distribución exponencial con parámetro l2. Cuando un nuevo mecanismo llega la máquina perforadora y ésta está ocupada, aguarda, según el turno que le corresponda, hasta que pueda ser perforado. tal efecto, se supone que la zona de espera en la que se van almacenando los mecanismos antes de ser perforados es lo suficientemente amplia para que existan aglomeraciones que sobrepasen estas dimensiones.¿Cuál es el porcentaje de tiempo durante el cual la perforadora está libre?¿Cuál es el número medio de mecanismos en toda la zona de per- foración (perforadora y zona de espera)?Calcular el tiempo medio que un mecanismo pasa en todo el proceso de perforación (desde que llega esa zona hasta que sale perforado) y la probabilidad de que para un mecanismo se emplee más de un minuto en todo ese proceso.Si ahora se supone que la zona de espera tiene sólo capacidad para 3 mecanismos y que cuando un mecanismo que llega y se encuentra dicha zona completa, se desvía otra rama de la cadena de producción, calcular la probabilidad de que se produzca dicho desvío.Ejercicio -30. una máquina perforadora de una cadena de producción llegan mecanismos de interruptores diferenciales según un proceso de Poisson, con media de l0 por minuto. El tiempo, en minutos, necesario para llevar cabo la perforación del mecanismo es de distribución exponencial con parámetro l2. Cuando un nuevo mecanismo llega la máquina perforadora y ésta está ocupada, aguarda, según el turno que le corresponda, hasta que pueda ser perforado. tal efecto, se supone que la zona de espera en la que se van almacenando los mecanismos antes de ser perforados es lo suficientemente amplia para que existan aglomeraciones que sobrepasen estas dimensiones.¿Cuál es el porcentaje de tiempo durante el cual la perforadora está libre?¿Cuál es el número medio de mecanismos en toda la zona de per- foración (perforadora y zona de espera)?Calcular el tiempo medio que un mecanismo pasa en todo el proceso de perforación (desde que llega esa zona hasta que sale perforado) y la probabilidad de que para un mecanismo se emplee más de un minuto en todo ese proceso.Si ahora se supone que la zona de espera tiene sólo capacidad para 3 mecanismos y que cuando un mecanismo que llega y se encuentra dicha zona completa, se desvía otra rama de la cadena de producción, calcular la probabilidad de que se produzca dicho desvío.Ejercicio -31. Un sistema informático de una biblioteca dispone de 3 lectores de CD que funcionan ininterrumpidamente. obstante, de vez en cuando se produce algún error de lectura en alguno de ellos y deja de funcionar hasta que uno de los encargados de la biblioteca (que es quien siempre lleva cabo esta tarea) consigue arreglar la avería. Se sabe que el tiempo que esta persona utiliza en dicha reparación sigue una distribución exponen- cial con media de 5 minutos, mientras que la distribución del tiempo que un lector está funcionando hasta que se produce algún error de lectura es también exponencial pero con media de l hora. Calcular:La probabilidad de que funcionen los tres lectores.El número medio de lectores averiados.El tiempo medio que un lector está averiado.Si en un momento dado funcionan dos lectores, ¿cuál es el tiempo medio hasta la próxima avería?Ejercicio -32. Una factoría dispone de cuatro equipos de generación de corriente eléctrica que suministran gran parte de la energía que necesita dicha empresa. La distribución del tiempo que transcurre desde que un generador comienza funcionar hasta que se avería es exponencial, con media de 40 días. El tiempo de reparación de un generador es una variable aleatoria de distribución exponencial y media l0 días. Sabiendo que existe un único técnico capaz de reparar los generadores, se pide:La probabilidad de que el técnico esté ocupado.El porcentaje medio de tiempo en el que todos los equipos de gene- ración están averiados.El número medio de averías de equipos en un mes.El tiempo medio que transcurre desde la avería de un equipo hasta su reparación.El número medio de equipos funcionando.Ejercicio -33. Un autoservicio dispone de tres empleados, un camarero sirve el primer plato, el segundo camarero sirve el segundo plato y el tercero se encarga de la caja. El primer camarero dispone de suficiente espacio para atender clientes sin limitación, mientras que los otros dos camareros tienen un espacio limitado dos personas como máximo. El autoservicio muestra que la tasa media de llegada la hora de la comida es de 54 clientes/hora, el pimer camarero tiene un tiempo medio de servicio de un minuto, el segundo camarero de treinta segundos, y el tercero de 1 minuto.Se solicita:\n* Medidas de eficiencia del sistema descrito.\n* Longitud de las colas que forman el sistema.\n* Tiempo medio que un cliente pasa en el autoservicio desde que llega hasta que sale dispuesto para comer.Ejercicio -34. Una empresa de fabricación de puertas de madera tiene una unidad de negocio que fabrica puertas de muebles de cocina. Dichas puertas, de dimensiones diferentes según pedidos, reciben un tratamiento en 3 etapas. El número de puertas que la unidad de negocio fabrica son alrededor de 50000 puertas al año. La primera etapa es capaz de procesar 220 puertas al día. La segunda etapa consta de dos\nmáquinas que procesan cada una 140 puertas al día. La tercera etapa es una etapa manual, para la que se dispone de 3 trabajadores que tardan aproximadamente 5 minutos por puerta. Los días tienen 480 minutos y los años 240 días. Se pueden suponer tiempos distribuidos según una distribución exponencial tanto para las llegadas de pedidos como para los ritmos de producción.¿Cuál es el número de puertas que habrá en cada etapa, incluyendo las puertas en las máquinas y las que están siendo procesadas por los operarios?¿En que afectaría al sistema anterior que en la etapa segunda se colocara un limitador de capacidad, mediante el cual se aceptaran al almacén previo dicha etapa más de 5 puertas?Suponga que en el sistema original la demanda de puertas asciende 70000 puertas/año. Si se opta por comprar una máquina nueva en la primera etapa, ¿Cuántas horas extra al día debe trabajar la primera máquina? ¿En qué afectaría dicho cambio los plazos de entrega? ¿Cómo se comportarían los almacenes?Suponga que en la segunda etapa, hay dos si tres máquinas. Dichas máquinas tardan en estropearse 3 días desde que se arreglan y un mecánico tarda de media 5 horas en arreglarlas cada vez. Sólo se dispone de un mecánico. ¿Tiene este sistema suficiente capacidad para hacer frente la demanda?Sobre el caso anterior ¿Qué porcentaje de tiempo sólo hay una máquina trabajando? ¿Y ninguna? ¿Qué ocurre con los almacenes durante este tiempo que hay menos de dos máquinas trabajando?Sobre el caso anterior ¿Qué opinión le merece que vaya uno de los trabajadores de la tercera sección ayudar al mecánico cuando haya dos o más máquinas estropeadas? Debe sustentar la opinión con datos, suponga para ello que el trabajador de la tercera sección se comporta como un mecánico más, cuando trabaja como tal.¿Cuál sería en el caso anterior la probabilidad de que hubiera más de una máquina estropeada?Ejercicio -35. Una sección de una empresa fabrica puertas metálicas para ascensores. Las puertas para ascensores pueden tener una gran variedad de formatos, colores y huecos para vidrios variables.\nSe puede admitir que el proceso de producción se compone de 4 etapas consecutivas pero independientes. La empresa trabaja alrededor de 220 días al año. Cada día tiene 7 horas y 30 minutos de trabajo efectivo. Durante el pasado año se recibieron pedidos por una cantidad de 8.500 puertas. Los pedidos tienen\nuna cantidad variable de unidades, y los ajustes de cambio de partida, aunque importantes en ocasiones, parecen repercutir en los ritmos de producción promedio de las diferentes etapas de trabajo.La primera etapa se realiza simultáneamente por dos equipos de trabajo, con un ritmo promedio cada uno de ellos de una puerta cada 20 minutos. La segunda etapa la realiza un equipo de trabajo con un tiempo de ciclo promedio de 11 minutos por puerta. La tercera etapa requiere del uso de otra máquina con un\ntiempo de ciclo promedio de 10 minutos por puerta. Por último la cuarta etapa es de preparación final. Como es un trabajo principalmente manual, que realiza un único operario, tiene un tiempo de ciclo de 18\nminutos por unidad, y se dispone de tantos trabajadores como se requieran, pues irán viniendo de otras secciones siempre que haya una puerta por preparar. ASumiendo tiempos exponenciales:¿Cuál será el número medio de puertas que habrá en el sistema?.¿Cuántos trabajadores serán necesarios normalmente en la cuarta etapa?.Si un pedido tiene 30 puertas ¿Cuánto tiempo tardará en promedio en ser servido?¿Cuál es el tiempo promedio previsto de entrega de una puerta? Si le dicen que el tiempo de entrega promedio es de 5 días. ¿qué puede ser debido?. Proponga un mecanismo de corrección.Cual será el efecto sobre la cantidad de puertas en la primera etapa si en lugar de dos equipos de trabajo con tiempos de ciclo como los citados se establece un único equipo más eficiente con un tiempo de ciclo de 9 minutos por unidad.Ejercicio -36. Una empresa dedicada la fabricación de cocinas tiene una linea de producción dedicada en exclusividad las puertas de cocina. Dichas puertas, de dimensiones diferentes según pedidos, reciben un tratamiento en 3 etapas. El número de puertas que la unidad de negocio fabrica son alrededor de 50000 puertas al año. La primera etapa es capaz de procesar 220 puertas al día. La segunda etapa consta de dos máquinas que procesan cada una 140 puertas al día. La tercera etapa es una etapa manual, para la que se dispone de 3 trabajadores que tardan aproximadamente 5 minutos por puerta. Los días tienen 480 minutos y los años 240 días. Asumiendo que los tiempos y la demanda de pedidos se comportan segun variables aletaorias exponenciales, la empresa está interesada en:¿Cuál es el número de puertas que habrá en cada etapa, incluyendo las puertas en las máquinas y las que están siendo procesadas por los operarios?¿En que afectaría al sistema anterior que en la etapa segunda se colocara un limitador de capacidad, mediante el cual se aceptaran al almacén previo dicha etapa más de 5 puertas?Suponga que en el sistema original la demanda de puertas asciende 70000 puertas/año. Si se opta por comprar una máquina nueva en la primera etapa, ¿Cuántas horas extra al día debe trabajar la primera máquina? ¿En qué afectaría dicho cambio los plazos de entrega? ¿Cómo se comportarían los almacenes?Suponga que en el sistema original la demanda de puertas asciende 70000 puertas/año. Si se opta por comprar una máquina nueva en la primera etapa, ¿Cuántas horas extra al día debe trabajar la primera máquina? ¿En qué afectaría dicho cambio los plazos de entrega? ¿Cómo se comportarían los almacenes?Suponga que en la segunda etapa, hay dos si tres máquinas. Dichas máquinas tardan en estropearse 3 días desde que se arreglan y un mecánico tarda de media 5 horas en arreglarlas cada vez. Sólo se dispone de un mecánico. ¿Tiene este sistema suficiente capacidad para hacer frente la demanda?Sobre el caso anterior ¿Qué porcentaje de tiempo sólo hay una máquina trabajando? ¿ Y ninguna? ¿Qué ocurre con los almacenes durante este tiempo que hay menos de dos máquinas trabajando?Sobre el caso anterior ¿Qué opinión le merece que vaya uno de los trabajadores de la tercera sección ayudar al mecánico cuando haya dos o más máquinas estropeadas? Debe sustentar la opinión con datos, suponga para ello que el trabajador de la tercera sección se comporta como un mecánico más, cuando trabaja como tal.¿Cuál sería en el caso anterior la probabilidad de que hubiera más de una máquina estropeada?Ejercicio -37. Una empresa fabrica puertas metálicas para ascensores. Las puertas para ascensores pueden tener una gran variedad de formatos, colores y huecos para vidrios variables. Se puede admitir que el proceso de producción se compone de 4 etapas consecutivas pero independientes. La empresa trabaja alrededor de 220 días al año. Cada día tiene 7 horas y 30 minutos de trabajo efectivo. Durante el pasado año se recibieron pedidos por una cantidad de 8.500 puertas. Los pedidos tienen una cantidad variable de unidades, y los ajustes de cambio de partida, aunque importantes en ocasiones, parecen repercutir en los ritmos de producción promedio de las diferentes etapas de trabajo.La primera etapa se realiza simultáneamente por dos equipos de trabajo, con un ritmo promedio cada uno de ellos de una puerta cada 20 minutos. La segunda etapa la realiza un equipo de trabajo con un tiempo de ciclo promedio de 11 minutos por puerta. La tercera etapa requiere del uso de otra máquina con un tiempo de ciclo promedio de 10 minutos por puerta. Por último la cuarta etapa es de preparación final. Como es un trabajo principalmente manual, que realiza un único operario, tiene un tiempo de ciclo de 18 minutos por unidad, y se dispone de tantos trabajadores como se requieran, pues irán viniendo de otras secciones siempre que haya una puerta por preparar.La empresa está interesada en conocer:¿Cuál será el número medio de puertas que habrá en el sistema?.¿Cuántos trabajadores serán necesarios normalmente en la cuarta etapa?.Si un pedido tiene 30 puertas ¿Cuánto tiempo tardará en promedio en ser servido?¿Cuál es el tiempo promedio previsto de entrega de una puerta? Si le dicen que el tiempo de entrega promedio es de 5 días. ¿qué puede ser debido?. Proponga un mecanismo de corrección.Cual será el efecto sobre la cantidad de puertas en la primera etapa si en lugar de dos equipos de trabajo con tiempos de ciclo como los citados se establece un único equipo más eficiente con un tiempo de ciclo de 9 minutos por unidad.","code":""},{"path":"SIMSIST.html","id":"SIMSIST","chapter":"Unidad 6 Aplicaciones prácticas","heading":"Unidad 6 Aplicaciones prácticas","text":"En esta unidad se presentan diferntes sistemas d eproducción sobre los que hay que diseñar un algoritmo de simulación para responder las preguntas de interés.Caso 1. Trabaja en una empresa que da servicio de distribución de aguas. Concretamente se le ha encargado que preste su atención del departamento de atención telefónica. Actualmente se reconocen 3 tipos de llamadas que se reciben en tres teléfonos distintos. De tipo 1 se reciben 40 llamadas la hora, de tipo 2 se reciben también 40 llamadas la hora y de tipo 3 se reciben en condiciones normales 20 llamadas la hora.El tiempo que se tarda en atender una llamada de tipo 1 es de 3 minutos igual que las llamadas de tipo 2. Las llamadas de tipo 3 requieren una atención en promedio de 5 minutos cada una. Usted está diseñando un nuevo sistema de atención telefónica, que atendería todos los clientes con un único número de teléfono. Un sistema informático discrimina el destino de la llamada mediante una operación que dura aproximadamente 20 segundos en promedio. Una vez el sistema informático decide el destino, tiene una probabilidad del 5% de equivocarse. En ese caso el operador que recibe la llamada, envía ésta al centro adecuado para que sea atendido. La empresa esta interesado en:¿Cuántos operadores se deben poner para cada tipo de llamadas si deseamos mantener la intensidad de tráfico en estado estacionario (\\(\\rho < 1\\))?¿Cuál es el tiempo medio que un cliente estaría en el sistema con el número mínimo de operadores? ¿cuál es el tiempo esperado en cola para ser atendido para las llamadas de cada tipo? ¿Cuántas llamadas habría en promedio en cada sección?¿Cuál es tiempo medio que un cliente estaría en el sistema si pusiera en cada sección uno más de los operadores estrictamente necesarios?Se le plantea una nueva alternativa. Consiste en hacer que todos los operadores atiendan todas las llamadas, aunque en ese caso el tiempo de atención de cada llamada es el doble del indicado más arriba para cada tipo. ¿Cuántos operadores hacen falta? ¿Cuál es el tiempo medio de estancia en el sistema? ¿Cuál es el tiempo de espera ser atendido?Caso 2. El servicio técnico de una empresa tiene 3 etapas relevantes y necesarias para todos los productos que maneja. Cada una de ellas es relativamente manual y la capacidad productiva de la misma es directamente proporcional al número de personas que trabajan en la misma. El número de productos que se reciben en dicho servicio técnico es de 41 unidades al día y la llegada de los mismos sigue un\nproceso de Poisson. Tras la tercera etapa hay un proceso de control de calidad que revisa el producto\nobtenido. Es también una etapa manual y se podría considerar una cuarta etapa. Tras la inspección un cierto porcentaje de productos son devueltos la etapa 1, otros la etapa 2 y otros la etapa 3. Por la configuración del producto, una vez un producto vuelve la etapa 1 debe seguir el proceso preestablecido hasta el final.Los datos de cada etapa están en la tabla adjunta. Los tiempos de operación en cada etapa están expresados en horas y se ajustan razonablemente bien una distribución exponencial:\\[\n\\begin{matrix}\n& Etapa 1 & Etapa 2 & Etapa 3 & Calidad\\\\\n\\text{Tiempo de opración (en horas)} & 3 & 4 & 2 & 1\\\\\n\\text{Porcentaje devueltos} & 2\\% & 3\\% & 5\\% &\n\\end{matrix}\n\\]Los productos que se fabrican son específicos para cada cliente. El cliente tiene una cierta urgencia en recoger su producto acabado y por ello el tiempo de espera del mismo es un tema relevante. Si la empresa está interesada en la producción para los próximos 6 meses (cada día tiene 7 horas y 30 minutos de trabajo efectivo, y cada mes 22 días de trabajo.)Diseñe el sistema que con un mínimo número de personas total cumple con los requerimientos.Defina los parámetros básicos del sistema: número de pedidos promedios, tiempo de espera medio, numero medio de pedidos por etapa.Los datos de tiempo de espera parecen muy elevados. Se le ocurren varias maneras de atacar el problema:Contratar una persona más. Si tuviera que proponer la contratación de una persona más ¿dónde la pondría y por qué? ¿qué efecto tendrá sobre el sistema?Invertir en alguna de las diferentes etapas para reducir la mitad la tasa de fallos. ¿en cuál y por qué? ¿qué efecto tendría en el sistema?Invertir en alguna de las diferentes etapas para reducir la mitad la variabilidad del proceso. ¿en cuál y por qué? ¿qué efecto tendría?Caso 3. Acaba usted de llegar la cola del aparcamiento de un parque temático. Las colas empiezan con los cajeros los que paga 6 Euros por coche que entra en el aparcamiento. La segunda cola empieza mientras espera que le asignen una plaza del aparcamiento. La tercera es la cola para pagar la entrada ( 8 euros más por persona), y por último una cola para que comprueben que pretende entrar comida en el parque temático. Una vez dentro del Parque comenzará una serie de colas que acabará en cada una de las atracciones. todo el mundo que entra en el Parque sigue el mismo camino, pero su interés radica en saber cuánto tardará usted en alcanzar el interior del Parque.Un breve análisis de la situación indica los siguientes datos:Entran aproximadamente 2400 coches por hora, para ser atendidos por 20 cajas en paralelo que tardan en cobrar aproximadamente 29 segundos por cliente.De todos los coches que entran un 18% van al aparcamiento VIP. El 82% restante va al aparcamiento convencional que, de un modo muy eficiente es capaz de aparcar los coches, de uno en uno, con un tiempo de ciclo promedio de 3,5 segundos por coche. Mediante otros medios (trenes y autobuses) se acercan junto con los clientes en coche particular nuevos grupos de clientes.Se calcula que en el parque entran aproximadamente 25.000 personas al día en 6000 grupos. De los 6000 grupos sólo 3500 grupos compran las entradas en taquilla (los otros ya las compraron por agencia o llevan un pase de varios días comprado anteriormente). Todos los clientes llegan aproximadamente en las 3 primeras horas de apertura del parque.Los que han de pagar tendrán que hacer 6 colas para pagar en 30 cajas (cada cola alimenta 5 cajas). En cada caja tardarán en promedio 92 segundos en atenderles.Tras pagar queda la última cola donde cada cliente pasa de modo individual, y pasan todos: los que acaban de comprar y los que venían con ticket precomprado, por el detector de comidas y bebidas. Estos son 12 carriles en paralelo, cada uno con su propia cola, que tardan 5 segundos en dejar pasar cada cliente.Para un día normal de funcionamiento:Si cada coche mide 4 metros, cuantos metros de carretera hacen falta para que quepan en promedio todos los coches que se pondrán en cola delante de las cajas de aparcamiento.¿Cuánto tiempo se tarda en hacer la cola para aparcar el coche, una vez haya pagado el aparcamiento?¿Cuánto tiempo tardaremos en conseguir nuestra entrada desde que hemos aparcado el coche, considerando que tarda 5 minutos desde que aparca hasta que llega la cola?¿Cuánta gente habrá como usted haciendo cola para pagar?¿Cuánto tiempo tardaremos en entrar en el parque desde que aparcamos?.¿qué ocurrirá en el sistema de cajas si el tiempo de atención en la caja de compra de entradas el tiempo medio de atención es de 100 segundos?¿qué repercusión tendría en la cola posterior dicha alteración?Con las condiciones de e, ¿cuál es la repercusión de añadir un carril adicional de venta de entradas?Caso 4. JCP Automatismos es una empresa que diseña, fabrica e instala sistemas de manutención automáticos. Actualmente se encuentran diseñando un sistema que pretenden dimensionar apoyándose en sus conocimientos. Dicho sistema recoge, en una de sus partes, tres tipos de productos paletizados través de sendas mesas transportadoras de rodillos. Dichas mesas transportadoras desembocan en un carro. El carro recoge las paletas que las mesas le suministran y las envía otras dos mesas de rodillos que alimentan sendas máquinas.El ritmo de entrada de productos 1 en su mesa es de 20 paletas/hora. El de productos de tipo 2 es 40 paletas/hora. El de productos de tipo 3 es 60 paletas/hora.El tiempo que en promedio tarda el transportador en cubrir un ciclo entero es de 25 segundos por paleta transportada. Es decir en promedio se tarda 25 segundos en moverse la mesa de rodillos en la que hay que recoger el producto, coger la paleta, desplazarse la mesa de destino y descargar la paleta. El transportador elije el producto transportar sin seguir ningún criterio específico. El 80% de los productos que entran por 1 va la mesa . El 40% de los productos que entran por 2 van la mesa . El 50% de los productos que entran por 3 van la mesa . La máquina que consume elementos de la mesa lo hace un ritmo de 50 segundos por paleta. La máquina que consume elementos de la mesa b lo hace también 50 segundos por paleta.Se trata de definir la capacidad mínima que han de tener las 5 mesas de rodillos, para que el sistema se bloquee. Para ello:Definir el problema según una red de colas de varios productos (suponer que las colas inicialmente tienen límite en la capacidad). Definir la matriz de transición para cada producto.Calcular los valores de \\(\\lambda\\) y \\(\\mu\\) para cada una de los servidores.¿Cuál será la cola promedio en cada una de las mesas suponiendo que tienen límite de capacidad?¿Cómo afectaría al sistema que el transportador eligiera para extraer, en cada ocasión, el producto en cabecera de la mesa de rodillos con más productos?¿Cómo cree que afectará la máquina que alimenta la mesa 3 que ésta tuviera una limitación de 10 unidades?. ¿Y si fuera de 5 unidades?Caso 5. Ascensores PKJu es una empresa de mantenimiento de ascensores que opera en el área de Elche. Tiene su cargo un parque de 500 ascensores. Usted se está buscando la vida como “consultor de Organización.” Y en el edificio donde viven ha sufrido ya en dos ocasiones un servicio bastante defectuoso\n–tardaron más de dos días en resolver un problema-, así que se ha ido ofrecerle la dirección de la empresa la posibilidad de repensar el modo de funcionamiento.En la empresa son conscientes de que efectivamente tienen un problema (las reclamaciones de los clientes indican que algo pasa). Le han pedido que haga una propuesta de mejora. Las actividades de mantenimiento los ascensores son de tres tipos:Las actividades de mantenimiento preventivo (aproximadamente 1,1 revisiones al año por ascensor). La duración estándar de la operación oscila entre 3 y 5 horas (incluyendo desplazamientos que son en promedio una hora y media todo incluido).Las actividades de mantenimiento correctivo que suponen alrededor de 500 acciones al año (estas actividades tienen un tiempo promedio de 4 horas de resolución).Las actividades de emergencia (donde hay que sacar alguien de un ascensor bloqueado o similar) que suponen alrededor de 100 acciones al año y que tienen un tiempo de resolución promedio de dos horas. El 75% de las mismas ocurren durante el tiempo “de oficina.” Si de resultas de la actividad de emergencia hay que resolver algo más (lo que ocurre en el 50% de las ocasiones) se hace en el momento como una\nactividad de mantenimiento correctivo.Tienen tres técnicos “de toda la vida” que se desenvuelven mejor en las actividades de mantenimiento correctivo (tardando aproximadamente un 20% menos de tiempo en resolver cualquier problema que el promedio) pero les gustan las de preventivo (“porque ahora todo lo hacen los ordenadores,” es por ello\nque siempre encuentran motivos para estar un 20% más del tiempo previsto).Conocen suficientes técnicos de ascensores para saber que puede contar con los que necesite sin experiencia. Actualmente, cuando creen que van necesitar más gente, la contratan por semanas, pero calculan que les sale alrededor de un 20% más cara que si el contrato fuera fijo.Para las emergencias han creado un retén que trabaja 24 horas al día, 365 días al año. El año tiene 240 días laborables. Y los días tienen 8 horas laborables. Como el retén tiene que estar disponible 24/365 la empresa ha subcontratado por un fijo dos autónomos que dan ese servicio durante las horas que son “de oficina.”Su modo de gestión en los días laborables y en horas de oficina” es el siguiente. Cada día laborable se inician actividades de mantenimiento según estén programadas. Uno de los trabajadores experimentados se queda en el retén por si hay alguna emergencia. En el caso de que haya que atender una emergencia se\nenvía al técnico que está en el retén al lugar de “los hechos.” Si hubiera ninguno disponible en el retén se localiza algún otro técnico para que se desplace al lugar donde es necesario urgentemente.Actualmente tiene un tipo de gestión en que cualquier técnico está disponible para recibir una orden de trabajo desde cualquier ascensor. Se le ha ocurrido que sería mejor dividir su zona en varias áreas. De tal modo que los técnicos se especialicen por zonas (así incrementan el conocimiento relativo de su parque de ascensores). Estima que el beneficio que obtendría con ello es que reduciría tiempos de desplazamiento en al menos un 50%. Se trata de que exponga, de la manera más clara y concisa posible cómo plantearía el problema la empresa. Cuanto más nivel de detalle le dé la solución mejor.Caso 6. Un pequeño supermercado de playa tiene tres líneas de cajas. El propietario cuenta con la ayuda de dos auxiliares. El propietario es mucho más eficiente que los auxiliares siendo capaz el primero\nde atender un cliente cada 3 minutos, mientras que el auxiliar necesita 4 minutos.En los momentos de mayor afluencia de gente entran alrededor de 30 clientes la hora, un 20% de los cuales tarda 5 minutos en irse sin comprar nada si el propietario está atendiendo la caja. Ese porcentaje se reduce al 10% si el propietario está paseando por el interior de la tienda. Los clientes que compran algo tardan en promedio 6 minutos en pasar desde la “sala” la zona de cajas.los clientes les disgusta estar en la cola. Un 15% de los mismos entran en el supermercado si ven demasiado “lío” en la caja.En general al propietario le gusta estar al tanto de los lineales y por ello deja uno de los auxiliares al cargo de la caja. Si la cola crece por encima de 5 pone al segundo de los auxiliares y sólo cuando ve que la cola se hace demasiado larga (más de 10 personas aproximadamente) abre la otra caja y ayuda hasta que quedan 5 personas en la cola), momento en el que se va.Para un día cualquiera (12 horas de funcionamiento):¿Cuánta gente hay en el supermercado en los momentos de mayor afluencia?¿Hace bien el propietario en ponerse en la cola sólo cuando los dos auxiliares están en la caja y ve que la cola sigue siendo demasiado larga?¿Cuál es la longitud exacta de la cola en el caso de que el propietario de la caja se incorpore exactamente cuándo hay 10 clientes en la cola y abandone cuando sólo quedan 5?","code":""},{"path":"simmerunidad.html","id":"simmerunidad","chapter":"Unidad 7 Simulación DES con simmer","heading":"Unidad 7 Simulación DES con simmer","text":"","code":""},{"path":"simmerunidad.html","id":"simulación-1","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.1 Simulación","text":"Algunos sistemas del mundo real contienen tal complejidad que es inviable representarlos íntegramente y de modo preciso través de modelos analíticos; para estudiarlos sin embargo, podemos recurrir la simulación. Robert E. Shannon32 define simulación como el proceso de diseñar un modelo de un sistema real y realizar experimentos con este modelo, con el propósito de comprender su comportamiento o de evaluar diversas estrategias para que el sistema opere (dentro de los límites impuestos por un criterio o conjunto de criterios).\nDependiendo de la naturaleza del sistema representar, hay varios tipos de simulación. Una taxonomía habitual común para clasificar los problemas de simulación lo hace considerando tres dimensiones:33Variación aleatoria: determinística vs. estocástica, es decir, bien se utilizan fórmulas determinísticas o bien se incorpora variabilidad estocástica.Variación en el tiempo: estática vs. dinámica, esto es, se simula un proceso estático que varía lo largo del tiempo, o uno dinámico que sí lo hace.Variación en la medida: continua vs. discreta, es decir, el resultado o output medible del proceso varía de modo continuo o lo hace saltos discretos.","code":""},{"path":"simmerunidad.html","id":"simulación-des","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.2 Simulación DES","text":"La simulación de eventos discretos (Discrete Event Simulation -DES-) es una técnica específica para modelar sistemas estocásticos que evolucionan en el tiempo (son dinámicos) saltos discretos, esto es, su estado cambia de forma discreta en instantes concretos lo largo de instantes de tiempo que se secuencian según alguna ley de probabilidad.Son ejemplos de procesos DES las colas de espera, los productos en una cadena de producción, e incluso los objetos digitales que se mueven en una red social. Su naturaleza discreta permite describir su comportamiento en términos de eventos, esto es, de una ocurrencia instantánea que puede cambiar el estado del sistema, mientras que entre eventos consecutivos todas las variables de estado van permanecer invariables.Las aplicaciones DES son muy numerosas: sistema de fabricación, ingeniería de la construcción, gestión de proyectos, logística, sistemas de transporte, procesos de negocios, salud, redes de comunicaciones, ….34 La simulación de tales sistemas nos proporciona información sobre el riesgo, eficiencia y efectividad de los procesos, e incluso nos permite estudiar los efectos de introducir cambios en el sistema. En servicios públicos nos permite estudiar cuellos de botella en colas, optimizar flujos de pacientes en los hospitales, testar la robustez de una cadena de producción o predecir el funcionamiento de un nuevo protocolo o configuración en una red de telecomunicaciones.Existen tres aproximaciones básicas para proceder en la simulación DES:35Orientada la actividad (activity-oriented): el modelo consiste en secuencias de actividades que esperan ser ejecutadas dependiendo de ciertas condiciones; el reloj de simulación avanza incrementos fijos de tiempo. En cada paso se escanea toda la lista de actividades y se verifican sus condiciones de ejecución. Este modo de simular es demasiado sensible la elección del incremento de tiempos, dada la aleatoriedad de los tiempos en que suceden los eventos.Orientada los eventos (event-oriented): mantiene una lista de eventos programados y ordenados por el tiempo en el que van ocurrir. La simulación consiste en saltar de evento evento, ejecutando secuencialmente las rutinas asociadas.Orientada los procesos (process-oriented): refina la simulación orientada eventos añadiendo procesos que interactúan y cuya activación es desencadenada por eventos. En este caso, el modelizador define un conjunto de procesos que corresponden entidades u objetos del sistema real y su ciclo de vida.","code":""},{"path":"simmerunidad.html","id":"software-1","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.3 Software","text":"La librería simmer36 es un paquete de R para simulación DES que permite una modelización orientada procesos de alto nivel. Además, explota el novedoso concepto de trayectoria: un camino común (o modo de comportamiento único) en el modelo de simulación para entidades (procesos) del mismo tipo (equivalentes). Aprovecha además la definición de flujos de trabajo en cadena (pipe) del paquete magrittr.37La librería simmer se empezó desarrollar en 2014 para resolver un problema de optimización de facilidades en servicios sanitarios, basada en la simulación de eventos discretos DES. Está implementada en C++ y de ahí su eficiencia.´simmer` es la única librería de simulación de procesos en R, donde contamos también con las librerías:SpaDES,38 que se centra en modelos discretos espaciales;queuecomputer39 implementa un método eficiente para simular colas con llegadas y tiempos de servicio arbitrarios;queueing40 contiene múltiples funciones para analizar sistemas de colas.Más allá del lenguaje R, los competidores directos de simmer son SimPy41 y SimJulia,42 construidos, respectivamente, bajo los lenguajes Python y Julia.Instalamos y cargamos pues, las librerías vinculadas simmer y otras generales básicas en R:","code":"\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(simmer.plot)\nlibrary(parallel)\nlibrary(dplyr)\nlibrary(tidyverse)"},{"path":"simmerunidad.html","id":"simulación-con-simmer-1","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.4 Simulación con simmer","text":"","code":""},{"path":"simmerunidad.html","id":"conceptos-clave","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.4.1 Conceptos clave","text":"Para entender la Simulación de Eventos Discretos (DES), es preciso controlar cierta terminología específica, que se muestra continuación:Recurso (resource). Se trata de una entidad pasiva que se mueve pero proporciona un servicio o realiza una actividad dirigida las llegadas que se producen en el sistema. Todo recurso en simmer contiene dos elementos auto-gestionados:\nServidor, que representa el recurso que da servicio o realiza la actividad, con una determinada capacidad y que puede ser accedido (seized) y abandonado (released).\nCola: una cola priorizada de cierto tamaño (puede ser infinita), que se llena cuando el servidor está plena capacidad.\nRecurso (resource). Se trata de una entidad pasiva que se mueve pero proporciona un servicio o realiza una actividad dirigida las llegadas que se producen en el sistema. Todo recurso en simmer contiene dos elementos auto-gestionados:Servidor, que representa el recurso que da servicio o realiza la actividad, con una determinada capacidad y que puede ser accedido (seized) y abandonado (released).Cola: una cola priorizada de cierto tamaño (puede ser infinita), que se llena cuando el servidor está plena capacidad.Gestor (manager). Es una entidad activa, esto es, se trata de un proceso que tiene la habilidad de reajustar las propiedades de un recurso (como su capacidad y tamaño de la cola) medida que transcurre el tiempo (run-time).Gestor (manager). Es una entidad activa, esto es, se trata de un proceso que tiene la habilidad de reajustar las propiedades de un recurso (como su capacidad y tamaño de la cola) medida que transcurre el tiempo (run-time).Fuente (source) es el proceso responsable de generar nuevas llegadas según un patrón de tiempos entre llegadas, y de integrarlas en el modelo de simulación.Fuente (source) es el proceso responsable de generar nuevas llegadas según un patrón de tiempos entre llegadas, y de integrarlas en el modelo de simulación.Llegada (arrival). Es un proceso capaz de interaccionar con los recursos o con otras entidades del modelo de simulación. Puede tener atributos y valores de priorización asociados, y en general, tiene un tiempo de vida limitado. Tras su creación, cada llegada es integrada en una trayectoria dada.Llegada (arrival). Es un proceso capaz de interaccionar con los recursos o con otras entidades del modelo de simulación. Puede tener atributos y valores de priorización asociados, y en general, tiene un tiempo de vida limitado. Tras su creación, cada llegada es integrada en una trayectoria dada.Trayectoria (trajectory). Se trata de la secuenciación de actividades que definen el camino seguir de cada una de las llegadas que acceden ella. El modelo de simulación se representa por un conjunto de trayectorias.Trayectoria (trajectory). Se trata de la secuenciación de actividades que definen el camino seguir de cada una de las llegadas que acceden ella. El modelo de simulación se representa por un conjunto de trayectorias.Actividad (activity) es la unidad individual de acción que permite que las llegadas interactúen con los recursos y otras entidades, realicen rutinas mientras están en el sistema, retrocedan y avancen lo largo de la trayectoria de forma dinámica, etc.Actividad (activity) es la unidad individual de acción que permite que las llegadas interactúen con los recursos y otras entidades, realicen rutinas mientras están en el sistema, retrocedan y avancen lo largo de la trayectoria de forma dinámica, etc.Todos los procesos son susceptibles de ser representados través de diagramas de flujo. Es conveniente siempre representarlos, con el fin de ordenar y mostrar con claridad los caminos y secuenciaciones involucradas. Para crear diagramas de flujo disponemos de la simbología estándar ANSI para diagramas de flujo).","code":""},{"path":"simmerunidad.html","id":"entornos-y-trayectorias","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.4.2 Entornos y trayectorias","text":"La simulación con simmer, aunque se puede basar en los eventos, funciona mejor orientada los procesos, esto es, enfocada la identificación de fuentes y procesos y las interacciones entre ellos. Utiliza dos elementos básicos:El entorno de simulación se almacena en un objeto simmer definido por el comando env(), gestiona los recursos (resources) y las fuentes de llegadas (generators), controla la ejecución de la simulación y contiene los resultados de la simulación.Las trayectorias, definidas con el comando trajectory(), que contienen las secuencias de acciones o actividades que van experimentar las llegadas. Cada actividad viene descrita por un verbo que representa una funcionalidad concreta (bloque funcional). El conjunto de acciones disponibles en simmer lo estudiaremos en la sección Acciones.Simular con simmer consiste, simplemente, en construir un entorno de simulación en el que se añaden recursos que dan servicios y se generan llegadas que acceden trayectorias en las que desarrollan ciertas actividades y son atendidas por los recursos. Toda la sintaxis se encadena con el comando pipe %>%.La Figura 7.1 ilustra de un modo sencillo la dinámica de simulación con simmer partir de entornos y trayectorias: el simulador es inicializado con simmer y monitorizado con monitor. Cada simulador contiene entidades constituidas por procesos y recursos. los procesos acceden las llegadas, provenientes de fuentes y reguladas por gestores, que realizan una serie de actividades que definen trayectorias y son ejecutadas por los recursos. Así mismo, los gestores pueden interaccionar con los recursos.\nFigura 7.1: Figura 2. Entorno de simulación en simmer Fte: IBiDat\nAunque las trayectorias se definen de modo independiente los entornos de simulación, se recomienda definir siempre el entorno en primer lugar (pues nombra recursos y llegadas), env=simmer(), para luego definir las trayectorias y completar el entorno con los recursos y las fuentes. Hay que tener en cuenta que las trayectorias y los entornos van usar elementos comunes, con lo que la sintaxis ha se ser construida y revisada en paralelo.Para hacer correr la simulación utilizamos el comando run(), con el que podemos especificar cuándo parar. El comando reset() nos permite resetear una simulación.Las trajectorias se pueden seccionar con el operador de selección [], juntar con join() y modificar con el operador =. Hay muchas actividades disponibles en simmer para incorporar en trayectorias y que presentaremos categorizadas más adelante, según su funcionalidad.Veamos un ejemplo de un modelo de simulación sencillo en el que llegan clientes una tienda cada minuto (durante 3 minutos), miran los productos durante 5 minutos y se van.Al visualizar el output, apreciamos que llegan tres clientes en los instantes 1,2,3. Cada cliente permanece en la tienda durante 5 minutos inspeccionando la mercancía, y después sale en los instantes 6, 7 y 8 respectivamente. En las actividades y generadores de llegadas hemos utilizado parámetros fijos, pero los podemos hacer aleatorios. Adaptemos el ejemplo anterior tiempos aleatorios uniformes entre llegadas y tiempos de permanencia aleatorios normales.Ahora vemos en la primera columna los instantes de tiempo en que llegan y se van los clientes.","code":"\nenv=simmer()\n# Se define la trayectoria \"tienda\" con la actividad que realizan los clientes\ntienda=trajectory() %>%\n  # Lanza un mensaje de aviso de llegada\n  log_(\"Llega a la tienda\") %>%\n  # mira productos 5min\n  timeout(5) %>% \n  # Lanza un mensaje de aviso de llegada\n  log_(\"Sale de la tienda\")\n# se lanza el entorno de simulación incluyendo el generador de llegadas \n# (clientes), que aparecen en tres instantes de tiempo,\n# y que son dirigidos a la trayectoria \"tienda\"\nenv=env %>%\n  add_generator(\"cliente\", tienda,at(1,2,3)) %>%\n  # se muestran los resultados en pantalla\n  print() %>%\n  # se lanza el sistema\n  run()## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: in memory }\n## { Source: cliente | monitored: 1 | n_generated: 0 }\n## 1: cliente0: Llega a la tienda\n## 2: cliente1: Llega a la tienda\n## 3: cliente2: Llega a la tienda\n## 6: cliente0: Sale de la tienda\n## 7: cliente1: Sale de la tienda\n## 8: cliente2: Sale de la tienda\nenv=simmer()\ntienda=trajectory() %>%\n  log_(\"Llega a la tienda\") %>%\n  # Cada cliente permanece en la tienda mirando productos aprox. 5min\n  timeout(function() rnorm(1,5,1)) %>% \n  log_(\"Sale de la tienda\")\n\nenv=env %>%\n  # el tiempo entre llegadas de los clientes es aleatorio entre 0 y 2 min.\n  add_generator(\"cliente\", tienda,function() runif(1,0,2)) %>% \n  print() %>%\n  # simulamos hasta el instante 10\n  run(10) ## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: in memory }\n## { Source: cliente | monitored: 1 | n_generated: 0 }\n## 1.20152: cliente0: Llega a la tienda\n## 1.51594: cliente1: Llega a la tienda\n## 2.51149: cliente2: Llega a la tienda\n## 3.76426: cliente0: Sale de la tienda\n## 4.05654: cliente3: Llega a la tienda\n## 4.12502: cliente4: Llega a la tienda\n## 4.51636: cliente5: Llega a la tienda\n## 5.29376: cliente6: Llega a la tienda\n## 5.96187: cliente1: Sale de la tienda\n## 6.65052: cliente7: Llega a la tienda\n## 8.58992: cliente3: Sale de la tienda\n## 8.6116: cliente8: Llega a la tienda\n## 8.65991: cliente2: Sale de la tienda\n## 8.88082: cliente4: Sale de la tienda\n## 9.67203: cliente9: Llega a la tienda\n## 9.73449: cliente10: Llega a la tienda"},{"path":"simmerunidad.html","id":"recursos","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.4.3 Recursos","text":"Recordemos que un recurso, que proporciona servicio las llegadas, en la simulación DES tiene dos componentes internos: un servidor y una cola. Todo recurso va ser definido por tres parámetros:el nombre (name) del recurso o servidor,la capacidad (capacity) del recurso, yel tamaño de la cola (queue_size) en la que esperan las llegadas que haya algún recurso disponible; representa el aforo de la sala de espera; cuando es cero significa que hay posibilidad de cola.Los recursos se definen con la sintaxis:El argumento capacity indica cuántos servidores hay en el sistema, y queue_size el tamaño de la cola de espera. Por defecto, los recursos son monitorizados (mon=TRUE) y preferentes (preemptive = FALSE). La preferencia significa que si aparece una llegada con prioridad alta, el recurso detendrá temporalmente el procesado de las llegadas que esté atendiendo y tengan menos prioridad, y atenderá la preferente. En los recursos preferentes, preemptive = TRUE el parámetro preempt_order define qué llegada debe priorizarse según una política FIFO (First , first )o LIFO (Last , first ). Todas las llegadas con mayor preferencia son ubicadas en una cola especial que tiene mayor prioridad que la cola principal, y en consecuencia se atienden antes. Además, el parámetro queue_size_strict controla si esta cola especial de llegadas preferentes debe ser tenida en cuenta para calcular el tamaño límite de la cola; si este parámetro impone el límite, entonces los rechazos se producirán en la cola principal.Para ampliar información, consultar el Manual de Referencia sobre add_resource.Cuando tenemos recursos en el sistema que dan un servicio, surgen dos acciones básicas que son: seize o asignación un recurso, y release o desocupación del recurso. Por supuesto, si una llegada puede ser atendida por un servidor (recurso) libre, puede esperar en cola si hay hueco en la cola, o ser rechazada si lo hay.Transformemos el ejemplo anterior en clientes que llegan aleatoriamente una tienda. Ahora al llegar, cada cliente mira productos alrededor de 5 minutos, luego busca un dependiente para ser atendido o espera hasta que uno esté desocupado, este lo atiende por aproximadamente 10 minutos y luego se va. Supongamos que hay 2 dependientes en la tienda.Visualizamos los clientes: cuándo llegan, cuándo son atendidos por un dependiente y cuándo se van de la tienda. Para los dependientes (recursos) vemos los instantes de tiempo (time) en los que inician un servicio o se les añade algún cliente en cola, el número de dependientes ocupados (server) y el número de clientes esperando ser atendidos (queue).","code":"add_resource(.env, name, capacity = 1, queue_size = Inf, mon = TRUE,\n  preemptive = FALSE, preempt_order = c(\"fifo\", \"lifo\"),\n  queue_size_strict = FALSE, queue_priority = c(0, Inf))\nset.seed(999)\nenv=simmer()\n\n# Actividades que se desarrollan en la tienda\ntienda=trajectory() %>%\n  log_(function()  \"Llega a la tienda\") %>%\n  # mira productos aprox. 5min\n  timeout(function() rnorm(1,5,1)) %>% \n  # es asignado a un dependiente \n  log_(function() \"Busca un dependiente\") %>%\n  seize(\"dependiente\",1) %>%\n  # que lo antiende aprox. 10min.\n  log_(\"Es atendido\") %>%\n  timeout(function() rnorm(1,10,1)) %>%\n  # desocupa al dependiente\n  release(\"dependiente\",1)%>%\n  # sale de la tienda\n  log_(function() \"Sale de la tienda\")\n\nenv=env %>%\n  # simulación (uniforme(0,5) del tiempo entre llegadas de clientes\n  add_generator(\"cliente\", tienda,function() runif(1,0,5)) %>% \n  # dimensionamiento de recursos: dos dependientes\n  add_resource(\"dependiente\",2) %>%  \n  print() %>%\n  run(20) %>% # simulamos hasta ese instante\n  # monitorizamos los recursos (dependientes)\n  get_mon_resources()## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: in memory }\n## { Resource: dependiente | monitored: TRUE | server status: 0(2) | queue status: 0(Inf) }\n## { Source: cliente | monitored: 1 | n_generated: 0 }\n## 1.94536: cliente0: Llega a la tienda\n## 4.86066: cliente1: Llega a la tienda\n## 5.6328: cliente0: Busca un dependiente\n## 5.6328: cliente0: Es atendido\n## 8.68238: cliente1: Busca un dependiente\n## 8.68238: cliente1: Es atendido\n## 8.79439: cliente2: Llega a la tienda\n## 11.55: cliente3: Llega a la tienda\n## 11.9157: cliente2: Busca un dependiente\n## 12.0631: cliente4: Llega a la tienda\n## 14.2341: cliente0: Sale de la tienda\n## 14.2341: cliente2: Es atendido\n## 15.9421: cliente4: Busca un dependiente\n## 16.1694: cliente5: Llega a la tienda\n## 17.3468: cliente3: Busca un dependiente\n## 18.9358: cliente6: Llega a la tienda\n## 18.9865: cliente1: Sale de la tienda\n## 18.9865: cliente4: Es atendido"},{"path":"simmerunidad.html","id":"fuentes","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.4.4 Fuentes","text":"Una fuente de llegadas, clientes o productos de un sistema de simulación es definida con tres parámetros principales:name_prefix, el nombre con el que identificamos cada llegada que se generatrajectory, la trayectoria la que accededistribution, la distribución de los tiempos entre llegadas.Hay dos tipos de fuentes: generadores y fuentes de datos (dataframes), las que accedemos respectivamente con los comandos add_generator() y add_dataframe().Generadores, proporcionados con el comando add_generator(), que genera tiempos dinámicos entre llegadas partir de una función (distribución) que define el usuario.Ejemplifiquemos las posibilidades de generación de tiempos de llegadas con el ejemplo anterior que ya realizamos, en el que al entrar cada cliente, pasa 5 minutos en el sistema y luego se marcha.También podemos desencadenar llegadas demanda desde otra trayectoria. Sería el ejemplo de un operador, que en el momento en que ficha digitalmente como trabajador de la empresa, se incorpora trabajar durante una jornada parcial de 3 horas:La sintaxis que se utiliza para generar llegadas es:El argumento mon permite especificar si queremos que el simulador monitoree las llegadas: 0 = sin monitoreo, 1 = monitoreo simple de llegadas simple, 2 = monitoreo simple y de atributos de las llegadas. Por defecto tendremos mon=1. En el argumento distribution se pueden utilizar funciones definidas por el usuario para los tiempos entre llegadas y también, como hemos visto, (), (), () y from_to(). Si hay un sistema de prioridades, se especificaría con priority=1, y qué hacer para las llegadas preferentes o prioritarias, en los argumentos preemptible y restart.Para ampliar información, consultar el Manual de Referencia sobre add_generator.Fuentes de datos con tiempos entre llegadas, provenientes de un data frame que vincula el usuario con el comando add_dataframe():Ambos generadores o fuentes de llegadas se reprograman sí mismos para ciclarse hasta agotar el tiempo de simulación, en el caso de que este supere el rango inicial.Para ampliar información, consultar el Manual de Referencia sobre add_generator y add_dataframe.","code":"\nenv=simmer()\n# defino la función de los tiempos entre llegadas, U(0,2)\ndistr <- function() runif(1, 0, 2)\n\n# definimos laa acciones que hace el cliente en la tienda\ntienda <- trajectory() %>%\n  timeout(5)\n\nenv %>%\n  # los tiempos entre llegadas se simulan de \"distr\"\n  add_generator(\"llegada_random\", tienda, distr) %>%\n  # las llegadas ocurren en los instantes 0, 1, 10, 30, 40 y 43\n  add_generator(\"llegada_at\", tienda, at(0,1,10,30,40,43)) %>%\n  # los tiempos entre llegadas se simulan de \"distr\", empezando en el instante 1\n  add_generator(\"llegada_from\", tienda, from(1, distr)) %>%\n  # los tiempos entre llegadas se simulan de \"distr\", acabando en el instante 5\n  add_generator(\"llegada_to\", tienda, to(5, distr)) %>%\n  # los tiempos entre llegadas se simulan de \"distr\", empezando en 1 y acabando en 5\n  add_generator(\"llegada_from_to\", tienda, from_to(1, 5, distr, every=4)) %>%\n  run(15) %>% \n  # monitorizamos todas las llegadas\n  get_mon_arrivals()##                name start_time  end_time activity_time finished replication\n## 1       llegada_at0  0.0000000  5.000000             5     TRUE           1\n## 2   llegada_random0  0.1729814  5.172981             5     TRUE           1\n## 3       llegada_to0  0.4509553  5.450955             5     TRUE           1\n## 4       llegada_at1  1.0000000  6.000000             5     TRUE           1\n## 5     llegada_from0  1.0000000  6.000000             5     TRUE           1\n## 6  llegada_from_to0  1.0000000  6.000000             5     TRUE           1\n## 7   llegada_random1  1.2274626  6.227463             5     TRUE           1\n## 8       llegada_to1  1.6187369  6.618737             5     TRUE           1\n## 9     llegada_from1  2.0801778  7.080178             5     TRUE           1\n## 10    llegada_from2  2.1182239  7.118224             5     TRUE           1\n## 11 llegada_from_to1  2.7380298  7.738030             5     TRUE           1\n## 12  llegada_random2  2.8600575  7.860058             5     TRUE           1\n## 13 llegada_from_to2  2.9572654  7.957265             5     TRUE           1\n## 14    llegada_from3  2.9890172  7.989017             5     TRUE           1\n## 15      llegada_to2  3.1719196  8.171920             5     TRUE           1\n## 16      llegada_to3  3.8909441  8.890944             5     TRUE           1\n## 17    llegada_from4  3.9343827  8.934383             5     TRUE           1\n## 18 llegada_from_to3  4.4370700  9.437070             5     TRUE           1\n## 19      llegada_to4  4.4642147  9.464215             5     TRUE           1\n## 20  llegada_random3  4.4702904  9.470290             5     TRUE           1\n## 21  llegada_random4  4.5808807  9.580881             5     TRUE           1\n## 22      llegada_to5  4.7246900  9.724690             5     TRUE           1\n## 23 llegada_from_to4  4.9288147  9.928815             5     TRUE           1\n## 24 llegada_from_to5  5.0000000 10.000000             5     TRUE           1\n## 25    llegada_from5  5.1656520 10.165652             5     TRUE           1\n## 26    llegada_from6  5.5418947 10.541895             5     TRUE           1\n## 27  llegada_random5  6.0601800 11.060180             5     TRUE           1\n## 28  llegada_random6  6.1803417 11.180342             5     TRUE           1\n## 29    llegada_from7  6.7354383 11.735438             5     TRUE           1\n## 30 llegada_from_to6  6.7442407 11.744241             5     TRUE           1\n## 31    llegada_from8  7.6346328 12.634633             5     TRUE           1\n## 32  llegada_random7  7.6924460 12.692446             5     TRUE           1\n## 33 llegada_from_to7  8.4122507 13.412251             5     TRUE           1\n## 34 llegada_from_to8  9.0000000 14.000000             5     TRUE           1\n## 35  llegada_random8  9.2487709 14.248771             5     TRUE           1\n## 36    llegada_from9  9.6174449 14.617445             5     TRUE           1\n# jornada de trabajo\nt0 <- trajectory() %>%\n  timeout(3)\n# activa \"Trabajar\": la jornada de trabajo\nt1 <- trajectory() %>%\n  activate(\"Trabajar\")\n\nsimmer() %>%\n  # simula llegadas al trabajo cuando \"Trabajar\" esté activado\n  add_generator(\"Trabajar\", t0, when_activated()) %>%\n  # simula una llegada a fichar\n  add_generator(\"Fichado digital\", t1, at(8)) %>%\n  run() %>%\n  get_mon_arrivals()##               name start_time end_time activity_time finished replication\n## 1 Fichado digital0          8        8             0     TRUE           1\n## 2        Trabajar0          8       11             3     TRUE           1add_generator(.env, name_prefix, trajectory, distribution, mon = 1,\n  priority = 0, preemptible = priority, restart = FALSE)add_dataframe(.env, name_prefix, trajectory, data, mon = 1, batch = 50,\n  col_time = \"time\", time = c(\"interarrival\", \"absolute\"),\n  col_attributes = NULL, col_priority = \"priority\",\n  col_preemptible = col_priority, col_restart = \"restart\")"},{"path":"simmerunidad.html","id":"atributos","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.4.5 Atributos","text":"Falta por completar información.","code":""},{"path":"simmerunidad.html","id":"monitoreo","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.4.6 Monitoreo","text":"Al ejecutar un entorno de simulación, si incluimos ninguna opción de visualización de mensajes en la trayectoria, obtenemos en pantalla un resumen escrito básico sobre recursos y llegadas.Al añadir en la ejecución del entorno el comando print() (antes de run()), se monitorizan los eventos que se van sucediendo en la simulación y dónde se almacenan (Monitor).El comando invisible (después de run()) depura la salida para visualizar nada (salvo que hayamos incorporado mensajes en las trayectorias).Si queremos visualizar mensajes específicos vinculados las llegadas y actividades conforme se suceden, habremos de incluir mensajes en las trayectorias través del comando log_().Una vez lanzamos un sistema de simulación, disponemos de diversos métodos para extraer información de él y monitorizarla por ejemplo con el comando log_():now() el tiempo de simulación actualpeek(n) instantes de tiempo en los que acontecerán los siguientes \\(n\\) eventosget_*() para obtener información de recursos, atributos y fuentes: attribute, capacity, global, name, n_activities, n_generated, prioritization, queue_count, queue_size, resources, seized, server_count, sources, trajectory.Con el comando stepn() podemos hacer correr el sistema durante una única simulación adicional, que se almacena en el objeto de simulación salvo que lo asignemos él.Los comandos para monitorizar se pueden aplicar un único entorno de simulación o una lista de entornos, y el objeto de retorno es siempre un data frame, incluso si se encuentran datos. Cada entorno de simulación procesado se trata como una replicación diferente, y se identifica como tal en una columna numérica denominada replication en el dataframe de retorno, con los índices de los entornos como valores. Recuperamos llegadas, recursos y atributos del sistema con los comandos:get_mon_arrivals() devuelve la información temporal por llegada: nombre (name) de la llegada, tiempo de llegada (start_time), tiempo de salida (end_time), tiempo en la actividad sin estar en la cola (activity_time) y una etiqueta finished que indica si la llegada finalizó sus actividades. Por defecto esta información se refiere al tiempo de vida completo de las llegadas, pero se puede obtener por recurso con el argumento per_resource=TRUE.get_mon_arrivals() devuelve la información temporal por llegada: nombre (name) de la llegada, tiempo de llegada (start_time), tiempo de salida (end_time), tiempo en la actividad sin estar en la cola (activity_time) y una etiqueta finished que indica si la llegada finalizó sus actividades. Por defecto esta información se refiere al tiempo de vida completo de las llegadas, pero se puede obtener por recurso con el argumento per_resource=TRUE.get_mon_resources() devuelve los cambios de estado en los recursos: nombre del recurso (resource), instante (time) del evento que desencadenó el cambio de estado, contador de unidades en servicio (server), contador de unidades en la cola (queue), capacidad (capacity), tamaño de la cola (queue_size), contador del sistema (system=server+queue), y límite del sistema (limit=capacity+queue_size).get_mon_resources() devuelve los cambios de estado en los recursos: nombre del recurso (resource), instante (time) del evento que desencadenó el cambio de estado, contador de unidades en servicio (server), contador de unidades en la cola (queue), capacidad (capacity), tamaño de la cola (queue_size), contador del sistema (system=server+queue), y límite del sistema (limit=capacity+queue_size).get_mon_atributes() devuelve los cambios de estado en los atributos: nombre (name) del atributo, instante (time) del evento que desencadenó el cambio de estado, nombre (key) que identifica el atributo y valor (value).get_mon_atributes() devuelve los cambios de estado en los atributos: nombre (name) del atributo, instante (time) del evento que desencadenó el cambio de estado, nombre (key) que identifica el atributo y valor (value).Ejemplifiquemos su funcionamiento sobre el sistema sencillo de la tienda que ya vimos anteriormente, con tiempos para mirar al llegar la tienda, seguidos de atención por dependientes.También podemos derivar el output de un entorno de simulación ficheros ‘csv’ (con monitor_csv) o de otro tipo, como ‘.txt’ especificando los delimitadores (con monitor_delim), con todas las llegadas (arrivals), atributos (attributes), salidas (releases) y recursos (resources), almacenándolas en el directorio temporal tempdir() o en nuestro propio directorio de trabajo.para continuación cargar los datos de estos ficheros y trabajar sobre ellos,Una vez extraída la información simulada para monitorizar el proceso y realizar análisis, con el paquete simmer.plot (Ucar Smeets, 2019b) tenemos métodos de graficado para visualizar rápidamente el uso de un recurso o una llegada lo largo del tiempo.Para las llegadas se pintan gráficos de líneas, con tres opciones o métricas posibles:activity_time es la cantidad de tiempo que consume en actividades cada llegada;flow_time es la cantidad de tiempo que consume cada llegada en el sistema, y se calcula con: ‘flow = end_time - start_time.’waiting_time es la cantidad de tiempo que una llegada espera ser atendida o ejecutada, y se calcula con: ‘waiting_time = flow_time - activity_time.’Para los recursos, tenemos dos métricas de graficado:usage muestra un gráfico de líneas con el tiempo promedio de uso (acumulado) de cada recurso, replication e item (por defecto queue, server y system, que es la suma de servidor y cola). Si steps=TRUE, se pinta un gráfico de escaleras con los valores instantáneos.utilization muestra un gráfico de barras con el promedio de uso del recurso (tiempo total en uso, dividido por el tiempo total de simulación). Para replicaciones múltiples, la barra representa la mediana y las barras de error los cuartiles. Si se proporciona una única replicación, la barra y la barra de error coinciden.Teniendo en cuenta que get_mon proporciona objetos data.frame, podemos utilizar cualquier otro tipo de gráfico específico y personalizado con las funciones gráficas habituales de R, y en particular de ‘ggplot2.’","code":"\ntrayectoria=trajectory() %>%\n   timeout(3)\n\nsimmer() %>%\n  add_generator(\"llegada\",trayectoria,at(0,1,2)) %>%\n  run() ## simmer environment: anonymous | now: 5 | next: \n## { Monitor: in memory }\n## { Source: llegada | monitored: 1 | n_generated: 3 }\nsimmer() %>%\n  add_generator(\"llegada\",trayectoria,at(0,1,2)) %>%\n  print() %>%\n  run() ## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: in memory }\n## { Source: llegada | monitored: 1 | n_generated: 0 }## simmer environment: anonymous | now: 5 | next: \n## { Monitor: in memory }\n## { Source: llegada | monitored: 1 | n_generated: 3 }\nsimmer() %>%\n  add_generator(\"llegada\",trayectoria,at(0,1,2)) %>%\n  run() %>%\n  invisible\nenv=simmer()\ntrayectoria=trajectory() %>%\n  log_(\"Llegada contabilizada.\") %>%\n  timeout(3)\n\nenv=env %>%\n  add_generator(\"llegada\",trayectoria,function() rexp(1,1/2)) %>%\n  run(5) %>%\n  invisible\nenv %>%\n    peek(3)## [1] 5.35573 5.35573\nenv=env %>%\n  stepn() %>%\n  print()## 5.35573: llegada0: Llegada contabilizada.\n## simmer environment: anonymous | now: 5.35572961320109 | next: 5.35572961320109\n## { Monitor: in memory }\n## { Source: llegada | monitored: 1 | n_generated: 1 }llegadas=get_mon_arrivals(env) \nllegadas\natributos=get_mon_attributes(env)\natributos\nrecursos=get_mon_resources(env)\nrecursos\nenv=simmer()\ntienda=trajectory() %>%\n  log_(function()  \"Llega a la tienda\") %>%\n  timeout(function() rnorm(1,5,1)) %>% # mira productos aprox. 5min\n  seize(\"dependiente\",1) %>%\n  log_(\"Es atendido\") %>%\n  timeout(function() rnorm(1,10,1)) %>%\n  release(\"dependiente\",1)%>%\n  log_(function() \"Sale de la tienda\")\n\nenv=env %>%\n  add_generator(\"cliente\", tienda,function() runif(1,0,5)) %>% # tiempo entre llegadas \n  add_resource(\"dependiente\",2) %>% # hay dos dependientes\n  print() %>%\n  run(20) # simulamos hasta ese instante## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: in memory }\n## { Resource: dependiente | monitored: TRUE | server status: 0(2) | queue status: 0(Inf) }\n## { Source: cliente | monitored: 1 | n_generated: 0 }\n## 1.13087: cliente0: Llega a la tienda\n## 1.79667: cliente1: Llega a la tienda\n## 4.27508: cliente2: Llega a la tienda\n## 4.37577: cliente3: Llega a la tienda\n## 5.20351: cliente4: Llega a la tienda\n## 7.07315: cliente1: Es atendido\n## 7.63425: cliente5: Llega a la tienda\n## 7.96535: cliente0: Es atendido\n## 12.2561: cliente6: Llega a la tienda\n## 14.623: cliente7: Llega a la tienda\n## 15.7281: cliente8: Llega a la tienda\n## 16.2301: cliente9: Llega a la tienda\n## 16.297: cliente10: Llega a la tienda\n## 17.1866: cliente11: Llega a la tienda\n## 17.6022: cliente12: Llega a la tienda\n## 18.3314: cliente0: Sale de la tienda\n## 18.3314: cliente2: Es atendido\n## 18.7997: cliente1: Sale de la tienda\n## 18.7997: cliente3: Es atendido\nllegadas=get_mon_arrivals(env) \nllegadas##       name start_time end_time activity_time finished replication\n## 1 cliente0   1.130873 18.33144      17.20057     TRUE           1\n## 2 cliente1   1.796671 18.79968      17.00301     TRUE           1\natributos=get_mon_attributes(env)\natributos## [1] time  name  key   value\n## <0 rows> (or 0-length row.names)\nrecursos=get_mon_resources(env)\nrecursos##      resource      time server queue capacity queue_size system limit replication\n## 1 dependiente  7.073150      1     0        2        Inf      1   Inf           1\n## 2 dependiente  7.965346      2     0        2        Inf      2   Inf           1\n## 3 dependiente  9.788494      2     1        2        Inf      3   Inf           1\n## 4 dependiente  9.958040      2     2        2        Inf      4   Inf           1\n## 5 dependiente 11.436010      2     3        2        Inf      5   Inf           1\n## 6 dependiente 14.378664      2     4        2        Inf      6   Inf           1\n## 7 dependiente 17.431417      2     5        2        Inf      7   Inf           1\n## 8 dependiente 18.331441      2     4        2        Inf      6   Inf           1\n## 9 dependiente 18.799679      2     3        2        Inf      5   Inf           1\nmon <- monitor_csv(path=tempdir()) # tempdir() lo podemos sustituir por nuestro directorio de trabajo\nmon   # nos muestra la ubicación y nombre de los ficheros## simmer monitor: to disk (delimited files)\n## { arrivals: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_arrivals.csv }\n## { releases: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_releases.csv }\n## { attributes: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_attributes.csv }\n## { resources: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_resources.csv }\nenv_mon=simmer(mon=mon)\ntienda=trajectory() %>%\n  log_(function()  \"Llega a la tienda\") %>%\n  timeout(function() rnorm(1,5,1)) %>% # mira productos aprox. 5min\n  seize(\"dependiente\",1) %>%\n  log_(\"Es atendido\") %>%\n  timeout(function() rnorm(1,10,1)) %>%\n  release(\"dependiente\",1)%>%\n  log_(function() \"Sale de la tienda\")\n\nenv_mon=env_mon %>%\n  add_generator(\"cliente\", tienda,function() runif(1,0,5)) %>% # tiempo entre llegadas \n  add_resource(\"dependiente\",2) %>% # hay dos dependientes\n  print() %>%\n  run(20) # simulamos hasta ese instante## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: to disk (delimited files) }\n##   { arrivals: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_arrivals.csv }\n##   { releases: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_releases.csv }\n##   { attributes: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_attributes.csv }\n##   { resources: /var/folders/m7/28kglwg91xjbzq3fpmfgdw4c0000gn/T//Rtmp2mfOYs/file5abd5d0e42e_resources.csv }\n## { Resource: dependiente | monitored: TRUE | server status: 0(2) | queue status: 0(Inf) }\n## { Source: cliente | monitored: 1 | n_generated: 0 }\n## 2.12099: cliente0: Llega a la tienda\n## 4.06522: cliente1: Llega a la tienda\n## 4.31647: cliente2: Llega a la tienda\n## 6.60486: cliente3: Llega a la tienda\n## 6.66412: cliente0: Es atendido\n## 9.19662: cliente2: Es atendido\n## 11.5799: cliente4: Llega a la tienda\n## 14.204: cliente5: Llega a la tienda\n## 16.2476: cliente0: Sale de la tienda\n## 16.2476: cliente1: Es atendido\n## 18.7205: cliente6: Llega a la tienda\nllegadas=read.csv(mon$handlers$arrivals)\nllegadas##       name start_time end_time activity_time finished\n## 1 cliente0   2.120993 16.24759      14.12659        1\n# que contiene la misma información (salvo \"replication\") que\nget_mon_arrivals(env_mon)##       name start_time end_time activity_time finished replication\n## 1 cliente0   2.120993 16.24759      14.12659        1           1\narrivals=get_mon_arrivals(env_mon)\nplot(arrivals, metric=\"waiting_time\")## `geom_smooth()` using method = 'loess' and formula 'y ~ x'## geom_path: Each group consists of only one observation. Do you need to adjust the group\n## aesthetic?\nplot(arrivals, metric=\"activity_time\")## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n## geom_path: Each group consists of only one observation. Do you need to adjust the group\n## aesthetic?\nplot(arrivals, metric=\"flow_time\")## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n## geom_path: Each group consists of only one observation. Do you need to adjust the group\n## aesthetic?\narrivals=get_mon_arrivals(env_mon)\nggplot(arrivals,aes(x=activity_time))+\n  geom_histogram(fill=\"Skyblue\",color=\"blue\")## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"simmerunidad.html","id":"acciones","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.5 Acciones","text":"Las acciones posibles para definir trayectorias las presentamos continuación, categorizadas según su funcionalidad:\nFigura 7.2: Figura 3. Principales acciones en trayectorias simmer. Fte: IBiDat\n","code":""},{"path":"simmerunidad.html","id":"atributos-en-llegadas","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.6 Atributos en llegadas","text":"Las llegadas pueden almacenar y modificar atributos con el comando set_attribute(). Los atributos consisten en pares (key,value) que por defecto se asignan por llegada, salvo que se definan globalmente.proporcionan el nombre (carácter) de la llegada (key) que, y el valor que toma (value). Estos atributos pueden ser definidos de modo particular cada llegada, o de modo global. Los atributos keys y values pueden ser vectores o funciones que devuelvan vectores.Se especifica con el comando set_attribute:que incluye o modifica unos atributos numéricos (values) una llegada o un conjunto de llegadas especificados en el vector keys. Las modificaciones se gestionan través del parámetro mod, que incluye las operaciones más habituales (suma y producto).Los atributos se pueden recuperar con el comando get_attribute(.env, keys), siempre que se haya definido previamente un objeto simmer (.env).Por ejemplo, el siguiente modelo define una entrada en la que se da el valor 60 peso, luego le suma 1 y visualiza el resultado, que es “Mi peso es 61”:Las llegadas además, están sujetas tres posibles valores de prioridad para acceder los recursos y que son definidas través del comando set_prioritization,través del argumento values=c(priority,preemptible,restart) para todas las llegadas que se crean provenientes de cualquier fuente. El significado de estos argumentos es es siguiente:prioridad (priority); un valor más alto implica mayor prioridad. El valor por defecto es la mínima prioridad, representada por el 0.prevención (preemptible); si un recurso es accedido, este valor establece la mínima prioridad de acceso que puede prevenir una llegada, es decir, el acceso al recurso. Si un recurso tiene ‘prevencion=2’ y se produce una llegada con ‘prioridad=3,’ la actividad previa se interrumpe y accede al recurso esta llegada, puesto que su orden de prioridad es mayor al de prevención.En cualquier caso, preemtible debe ser mayor o igual que priority, y por lo tanto sólo las llegadas con prioridad más alta pueden desencadenar una prevención o suspensión inesperada por tener llegadas con mayor prioridad.reinicio (restart), cuando se ha producido una prevención, indica si al finalizar la actividad con la llegada preferente, el recurso ha de reanudar (TRUE) la actividad previa que hubo de suspender o (0).El argumento mod permite modificar y cambiar de forma dinámica por llegada. Con get_prioritization(.env) se obtienen los valores de priorización para acceder los recursos.","code":"set_attribute(keys, values, mod = c(NA, \"+\", \"*\"), init = 0)\nenv=simmer()\ntraj=trajectory() %>%\n  # asignamos el atributo numérico a peso\n  set_attribute(\"peso\",60) %>%\n  # a continuación lo modificamos\n  set_attribute(\"peso\",1,mod=\"+\") %>%\n  # y por último lo visualizamos\n  log_(function() paste(\"Mi peso es\",get_attribute(env,\"peso\")))\n\nenv=env %>%\n  add_generator(\"peso\",traj,at(1)) %>%\n  print() %>%\n  run()## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: in memory }\n## { Source: peso | monitored: 1 | n_generated: 0 }\n## 1: peso0: Mi peso es 61set_prioritization(.trj, values, mod = c(NA, \"+\", \"*\"))"},{"path":"simmerunidad.html","id":"interacción-con-recursos","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.7 Interacción con recursos","text":"Las dos actividades principales para interaccionar con recursos son seize() -acceso- y release() -salida-. Un recurso o conjunto de recursos (amount) entran en funcionamiento con seize() y dejan de funcionar con release().La actividad seize() es especial en el sentido de que el resultado o salida depende del estado del recurso. Una llegada, cuando accede un recurso, puede aprovecharlo con éxito desde el momento en que accede y continuar su camino en la trayectoria, pero también puede ponerse en cola (si el recurso está ocupado) o ser rechazada y despedida de la trayectoria. Para manejar estos casos especiales con total flexibilidad, seize() soporta la especificación de dos sub-trayectorias opcionales:post.seize, que es la actividad que sigue despues de un seize exitoso, yreject, que es la actividad que sigue si la llegada ha sido rechazada.Como en todas las actividades que soportan la definición de sub-trayectorias, hay un parámetro booleano llamado continue. Para cada sub-trayectoria, este parámetro controla si las llegadas deberían continuar la actividad que sigue seize() en la trayectoria principal después de ejecutar la sub-trayectoria.Para ejemplificar su uso consideramos un ambulatorio médico al que llegan pacientes. Si al llegar el paciente, el doctor está disponible, es atendido por este durante 5 minutos. Si está disponible, es rechazado y derivado consulta de enfermería, donde es atendido siempre 8 minutos, al haber 10 enfermeras disponibles. En ambos casos el paciente se va del ambulatorio al terminar la consulta la que haya entrado.la hora de asignar un recurso, podemos hacerlo especificando explícitamente el nombre del recurso (si tenemos varios), o hacerlo de forma dinámica especificando la política seguir. Esto lo podemos hacer con la actividad select(), través de los argumentos resources y policy.Hay varias políticas implementadas internamente las que se puede acceder por su nombre:‘shortest-queue’: se selecciona el recurso con la cola más corta‘round-robin’: se seleccionarán los recursos de una forma cíclica‘first-available’: se selecciona el recurso que queda disponible el primero‘random’: se selecciona un recurso aleatoriamente.El parámetro resources también puede ser dinámico e incluso existe la posibilidad de definir políticas específicas. Una vez que un recurso es seleccionado, hay versiones especiales de las actividades mencionadas para interaccionar con los recursos sin especificar su nombre, como son seize_selected(), set_capacity_selected(), etc.Pongamos como ejemplo una consulta médica con 3 doctores, que atienden los pacientes de un modo ordenado secuencial conforme llegan la consulta.","code":"seize(.trj, resource, amount = 1, continue = NULL, post.seize = NULL,reject = NULL)\nrelease(.trj, resource, amount = 1)\nenv=simmer()\n\ntraj=trajectory() %>%\n  log_(function() paste(\"Llega el \",get_name(env))) %>%\n  seize(\n    \"doctor\",1,continue=c(TRUE,FALSE),\n    post.seize=trajectory(\"Paciente aceptado\") %>% \n      log_(\"Pasa a consulta con el doctor\"), \n    reject=trajectory(\"Paciente rechazado\") %>% \n      log_(\"El doctor está ocupado y es derivado a enfermería\") %>% \n      seize(\"nurse\",1) %>%\n      log_(\"Pasa a consulta con la enfermera\") %>%\n      timeout(8) %>%\n      release(\"nurse\",1) %>%\n      log_(function() paste(\"El\",get_name(env), \"sale de enfermería\"))) %>%\n  timeout(5) %>% \n  release(\"doctor\",1) %>% \n  log_(\"El doctor ya está libre\")\n\nenv=env %>%\n   add_resource(\"doctor\",capacity=1,queue_size=0) %>% \n   add_resource(\"nurse\",capacity=10,queue_size=0) %>%\n   add_generator(\"paciente\",traj,at(0,1,5,8)) %>%\n   run()## 0: paciente0: Llega el  paciente0\n## 0: paciente0: Pasa a consulta con el doctor\n## 1: paciente1: Llega el  paciente1\n## 1: paciente1: El doctor está ocupado y es derivado a enfermería\n## 1: paciente1: Pasa a consulta con la enfermera\n## 5: paciente0: El doctor ya está libre\n## 5: paciente2: Llega el  paciente2\n## 5: paciente2: Pasa a consulta con el doctor\n## 8: paciente3: Llega el  paciente3\n## 8: paciente3: El doctor está ocupado y es derivado a enfermería\n## 8: paciente3: Pasa a consulta con la enfermera\n## 9: paciente1: El paciente1 sale de enfermería\n## 10: paciente2: El doctor ya está libre\n## 16: paciente3: El paciente3 sale de enfermeríaselect(.trj, resources, policy = c(\"shortest-queue\",\n  \"shortest-queue-available\", \"round-robin\", \"round-robin-available\",\n  \"first-available\", \"random\", \"random-available\"), id = 0)\ntraj <- trajectory() %>%\n  simmer::select(paste0(\"doctor\", 1:3), \"round-robin\") %>%\n  seize_selected(1) %>%\n  timeout(5) %>%\n  release_selected(1)\n\nsimmer() %>%\n  add_resource(\"doctor1\") %>%\n  add_resource(\"doctor2\") %>%\n  add_resource(\"doctor3\") %>%\n  add_generator(\"patient\", traj, at(0, 1, 2)) %>%\n  run() %>%\n  get_mon_resources()##   resource time server queue capacity queue_size system limit replication\n## 1  doctor1    0      1     0        1        Inf      1   Inf           1\n## 2  doctor2    1      1     0        1        Inf      1   Inf           1\n## 3  doctor3    2      1     0        1        Inf      1   Inf           1\n## 4  doctor1    5      0     0        1        Inf      0   Inf           1\n## 5  doctor2    6      0     0        1        Inf      0   Inf           1\n## 6  doctor3    7      0     0        1        Inf      0   Inf           1"},{"path":"simmerunidad.html","id":"interacción-con-fuentes","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.8 Interacción con fuentes","text":"Hay cuatro actividades específicas para modificar las fuentes de llegadas. Una llegada puede activar activate() o desactivar deactivate() una fuente, pero también puede modificar la trayectoria la que se adhieren las llegadas que aparecen (derivarlas otras trayectorias), con set_trajectory(), o especificar una nueva distribución entre-llegadas con set_source(). Para seleccionar dinámicamente una fuente, el parámetro que especifica el nombre de la fuente en todos estos métodos puede ser dinámico.En el ejemplo continuación, una llegada, al acceder la trayectoria, desactiva la fuente que genera llegadas cada segundo, deja transcurrir 1 segundo y después vuelve activarla.En este otro ejemplo se define un simulador que genera llamadas cada 2 segundos y las redirige la trayectoria ‘traj2.’ Una vez allí, la fuente de llamadas se modifica para que partir de que la primera llamada finalice (estando 2 segundos en ‘traj2’), se generen llamadas cada segundo y se redirijan estas la trayectoria ‘traj1.’","code":"activate(.trj, sources)\ndeactivate(.trj, sources)\nset_trajectory(.trj, sources, trajectory)\nset_source(.trj, sources, object)  \ntraj=trajectory() %>%\n  deactivate(\"dummy\") %>% \n  timeout(1) %>% \n  activate(\"dummy\") \n\nsimmer() %>%\n  add_generator(\"dummy\",traj,function() 1) %>% \n  run(10) %>% \n  get_mon_arrivals()##     name start_time end_time activity_time finished replication\n## 1 dummy0          1        2             1     TRUE           1\n## 2 dummy1          3        4             1     TRUE           1\n## 3 dummy2          5        6             1     TRUE           1\n## 4 dummy3          7        8             1     TRUE           1\ntraj1 <- trajectory() %>%\n  timeout(1)\n\ntraj2 <- trajectory() %>%\n  set_source(\"llamada\", function() 1) %>%\n  set_trajectory(\"llamada\", traj1) %>%\n  timeout(2)\n\nsimmer() %>%\n  add_generator(\"llamada\", traj2, function() 2) %>%\n  run(6) %>%\n  get_mon_arrivals()##       name start_time end_time activity_time finished replication\n## 1 llamada0          2        4             2     TRUE           1\n## 2 llamada1          3        4             1     TRUE           1\n## 3 llamada2          4        5             1     TRUE           1"},{"path":"simmerunidad.html","id":"ramificación","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.9 Ramificación","text":"Una rama (branch) es un punto en una trayectoria en el cual se pueden seguir una o más sub-trayectorias. simmer soporta dos tipos de ramificación:La actividad branch() coloca la llegada en una de las sub-trayectorias que dependen de alguna condición evaluada en un parámetro dinámico llamado option. Es el equivalente de una condición /else, es decir, si el valor de option es ‘,’ entonces se ejecutará la sub-trayectoria ‘.’La actividad branch() coloca la llegada en una de las sub-trayectorias que dependen de alguna condición evaluada en un parámetro dinámico llamado option. Es el equivalente de una condición /else, es decir, si el valor de option es ‘,’ entonces se ejecutará la sub-trayectoria ‘.’Por otro lado, la actividad clone() genera n ramas paralelas (clonadas) y replica la llegada n-1 veces, colocando cada una de ellas en las n sub-trayectorias creadas. clone() es la única actividad de sub-trayectorias que acepta un parámetro continue. Por defecto todos los clones continúan en la trayectoria principal después de esta actividad. Para borrar todos los clones excepto uno, se utiliza la actividad synchronize().Por otro lado, la actividad clone() genera n ramas paralelas (clonadas) y replica la llegada n-1 veces, colocando cada una de ellas en las n sub-trayectorias creadas. clone() es la única actividad de sub-trayectorias que acepta un parámetro continue. Por defecto todos los clones continúan en la trayectoria principal después de esta actividad. Para borrar todos los clones excepto uno, se utiliza la actividad synchronize().En el ejemplo continuación simulamos un juego en el que el jugador lanza una moneda. Si llega durante la primera hora (now(env)=1), gana un caramelo y se va, y si , pierde dos caramelos que ha de regalar María y José.","code":"branch(.trj, option, continue, ...)\nclone(.trj, n, ...)\nsynchronize(.trj, wait = TRUE, mon_all = FALSE)\nenv=simmer()\n\ntraj=trajectory() %>%\n  branch(\n    option=function() now(env), continue=c(FALSE,TRUE), #si 1 la 1ª trayectoria y se va; si 2 la 2ª trayectoria y sigue\n      trajectory() %>% log_(function() paste(get_name(env),\"Ha llegado el instante\",now(env),\", gana un caramelo y se va.\")), \n      trajectory() %>% log_(function() paste(get_name(env),\"Ha llegado el instante\",now(env),\"y regala dos caramelos\"))) %>% \n  clone(n=2, \n    trajectory() %>% log_(\"uno a María\"), \n    trajectory() %>% log_(\"otro a José\")) %>%  \n  synchronize() \n  \nenv %>%\n  add_generator(\"Jugador\",traj,at(1,2)) %>%\n  run() %>%\n  invisible## 1: Jugador0: Jugador0 Ha llegado el instante 1 , gana un caramelo y se va.\n## 2: Jugador1: Jugador1 Ha llegado el instante 2 y regala dos caramelos\n## 2: Jugador1: uno a María\n## 2: Jugador1: otro a José"},{"path":"simmerunidad.html","id":"bucles","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.10 Bucles","text":"Hay un comando llamado rollback() útil para moverse hacia atrás en una trayectoria y ejecutar bucles sobre una serie de actividades. Esta actividad provoca que la llegada retroceda un cierto número de actividades amount (que pueden ser dinámicas) un cierto número de veces times. Si se utiliza una función de chequeo check, el parámetro times es ignorado y la llegada determina si debe retroceder cada vez que choca con rollback.En el siguiente ejemplo, un jugador accede un reto de resistencia en el que ha de levantar pesas y mantenerlas. Por cada 5 minutos que aguante, recibirá una recompensa de 25€. El jugador es capaz de aguantar 30 minutos, pero la máxima recompensa recibir es de 100€, por lo que se detendrá cuando consiga esa cantidad.","code":"rollback(.trj, amount, times = Inf, check = NULL)\nenv <- simmer()\n\ntraj <- trajectory() %>%\n  set_attribute(\"var\", 0) %>%\n  log_(function()\n    paste(\"Tiempo de resistencia:\",now(env),\". Ganancia=\", get_attribute(env, \"var\"))) %>%\n  set_attribute(\"var\", 25, mod=\"+\") %>%\n  timeout(5)%>%\n  rollback(3, check=function() get_attribute(env, \"var\") <= 100) \n\nenv %>%\n  add_generator(\"dummy\", traj, at(0)) %>%\n  run() %>% invisible## 0: dummy0: Tiempo de resistencia: 0 . Ganancia= 0\n## 5: dummy0: Tiempo de resistencia: 5 . Ganancia= 25\n## 10: dummy0: Tiempo de resistencia: 10 . Ganancia= 50\n## 15: dummy0: Tiempo de resistencia: 15 . Ganancia= 75\n## 20: dummy0: Tiempo de resistencia: 20 . Ganancia= 100"},{"path":"simmerunidad.html","id":"ejecución-en-lotes","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.11 Ejecución en lotes","text":"La ejecución en lotes o batching consiste en acumular varias llegadas antes de que puedan continuar su camino en la trayectoria de modo unitario. Esto significa, por ejemplo, que si 10 llegadas en un lote intenta acceder una unidad de cierto recurso, sólo una unidad puede ser asignada, y las 10. Un lote se puede descomponer con separate(), salvo que se marque como permanent=TRUE.Por defecto todas las llegadas que acceden un lote se juntan en él, y esperan hasta que se consigue el número esperado de llegadas n. Sin embargo, las llegadas pueden evitar unirse al lote bajo alguna restricción si se proporciona una función booleana opcional, rule. También un lote se puede agrupar para acceder un recurso antes de acumular el tamaño del lote, si se especifica un tiempo límite para acceder con timeout. Los lotes se comparten sólo por llegadas que se añaden la misma trayectoria directamente. Siempre que se necesite un lote compartido globalmente, se ha de especificar un nombre con name.Un ejemplo de sistema en el que puede tener sentido la ejecución por lotes es la visita guiada un museo, en la que son precisos 5 visitantes para asignar un guía e iniciar la visita. Si en 10 minutos se han conseguido los visitantes, se iniciará la visita igualmente con los visitantes disponibles. La visita dura 5 minutos y, puesto que hay un único guía, será preciso esperar su finalización para empezar la siguiente. Los tiempos entre llegadas provienen de una distribución exponencial de media 5.","code":"batch(.trj, n, timeout = 0, permanent = FALSE, name = \"\", rule = NULL)\nseparate(.trj)\nset.seed(1234)\nenv=simmer()\n\nvisita=trajectory() %>%\n  batch(n=5,timeout=10,name=\"visitaguiada\",permanent=FALSE) %>%\n  seize(\"guia\",1) %>%\n  log_(\"Comienza la visita con el guía\") %>%\n  timeout(5) %>%\n  release(\"guia\",1) %>%\n  log_(\"Visita terminada\") \n  \n\nenv=env %>%\n  add_resource(\"guia\",1) %>%\n  add_generator(\"visitante\", visita,function() rnorm(1,5,0.5)) %>%\n  print() %>%\n  run(until=50) ## simmer environment: anonymous | now: 0 | next: 0\n## { Monitor: in memory }\n## { Resource: guia | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n## { Source: visitante | monitored: 1 | n_generated: 0 }\n## 14.3965: batch_visitaguiada: Comienza la visita con el guía\n## 19.3965: batch_visitaguiada: Visita terminada\n## 25.0774: batch_visitaguiada: Comienza la visita con el guía\n## 30.0774: batch_visitaguiada: Visita terminada\n## 39.3721: batch_visitaguiada: Comienza la visita con el guía\n## 44.3721: batch_visitaguiada: Visita terminada\nget_mon_arrivals(env)##         name start_time end_time activity_time finished replication\n## 1 visitante0   4.396467 19.39647             5     TRUE           1\n## 2 visitante1   9.535182 19.39647             5     TRUE           1\n## 3 visitante2  15.077402 30.07740             5     TRUE           1\n## 4 visitante3  18.904553 30.07740             5     TRUE           1\n## 5 visitante4  24.119116 30.07740             5     TRUE           1\n## 6 visitante5  29.372144 44.37214             5     TRUE           1\n## 7 visitante6  34.084774 44.37214             5     TRUE           1\n## 8 visitante7  38.811458 44.37214             5     TRUE           1"},{"path":"simmerunidad.html","id":"programación-asíncrona","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.12 Programación asíncrona","text":"Hay ciertos métodos que permiten eventos asíncronos:La actividad send() emite una o más señales (signals) todas las llegadas que se suscriben ellas. Las señales se pueden desencadenar inmediatamente o después de cierto retraso (delay). En ese caso, los dos parámetros, signals y delay, pueden ser dinámicos.La actividad send() emite una o más señales (signals) todas las llegadas que se suscriben ellas. Las señales se pueden desencadenar inmediatamente o después de cierto retraso (delay). En ese caso, los dos parámetros, signals y delay, pueden ser dinámicos.Las llegadas pueden bloquearse y esperar con wait() hasta que se recibe cierta señal.Las llegadas pueden bloquearse y esperar con wait() hasta que se recibe cierta señal.Con trap() las llegadas pueden suscribirse señales (signals) y (opcionalmente) asignar un manipulador (de señales) handler. Si se proporciona el handler, la llegada detiene la atividad actual hasta que recibe la señal. Después, la actividad continúa desde el punto de interrupción. Sin embargo, si la llegada está esperando en un recurso de cola, las señales atrapadas se ignoran. Lo mismo ocurre con un lote: todas las señales suscritas antes de entrar un lote son ignoradas.Con trap() las llegadas pueden suscribirse señales (signals) y (opcionalmente) asignar un manipulador (de señales) handler. Si se proporciona el handler, la llegada detiene la atividad actual hasta que recibe la señal. Después, la actividad continúa desde el punto de interrupción. Sin embargo, si la llegada está esperando en un recurso de cola, las señales atrapadas se ignoran. Lo mismo ocurre con un lote: todas las señales suscritas antes de entrar un lote son ignoradas.Finalmente la actividad untrap()se puede utilizar para cancelar la suscripción signals.Finalmente la actividad untrap()se puede utilizar para cancelar la suscripción signals.Por defecto los manipuladores de señales (signal handlers) pueden ser interrumpidos también por otras señales, lo que significa que un manipulador (handler) puede permanecer reiniciándose si se están emitiendo suficientes señales. Si se necesita un manipulador que pueda ser interrumpido, hay que utilizar el parámetro interruptible=FALSE en trap().En el ejemplo continuación, una inteligencia artificial reclama una clave de acceso al usuario para desbloquear un recurso digital y permitirle el acceso. El usuario proporciona la clave de acceso al cabo de 5 segundos. La IA recibe la clave y desbloquea el recurso.","code":"send(.trj, signals, delay = 0)\nwait(.trj)\ntrap(.trj, signals, handler = NULL, interruptible = TRUE)\nuntrap(.trj, signals)\nia.acceso=trajectory() %>%\n  log_(\"Solicito clave de acceso\") %>%\n  trap(\"clave\") %>%\n  wait() %>%  \n  log_(\"Clave recibida y acceso permitido\")\n\nusuario=trajectory() %>%\n  log_(\"Clave enviada\") %>%\n  send(\"clave\") \n  \nsimmer() %>%\n  add_generator(\"ia.acceso\",ia.acceso,at(0)) %>%\n  add_generator(\"usuario\",usuario,at(5)) %>%\n  run() %>%\n  invisible## 0: ia.acceso0: Solicito clave de acceso\n## 5: usuario0: Clave enviada\n## 5: ia.acceso0: Clave recibida y acceso permitido"},{"path":"simmerunidad.html","id":"renuncias","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.13 Renuncias","text":"Además de ser rechazadas cuando tratan de acceder un recurso, las llegadas pueden dejar una trayectoria en cualquier momento, síncrona o asíncronamente. En principio, renunciar significa que una llegada abandona la trayectoria en un momento dado. La actividad más simple que permite esto es leave(), que inmediatamente desencadena la acción dada alguna probabilidad. Además, renege_in() y renege_if() desencadena la renuncia asíncronamente después de algún tiempo timeout=t o si se recibe una señal, respectivamente, salvo que la acción sea abortada con renege_abort(). Los dos métodos renege_in() y renege_if() aceptan una subtrayectoria opcional, , que se ejecuta directamente antes de abandonar la trayectoria.En el ejemplo siguiente los clientes llegan un banco con un solo empleado, del que se","code":"leave(.trj, prob, out = NULL, keep_seized = TRUE)\nrenege_in(.trj, t, out = NULL, keep_seized = FALSE)\nrenege_if(.trj, signal, out = NULL, keep_seized = FALSE)\nrenege_abort(.trj)\nbanco=trajectory() %>%\n  log_(\"He llegado al banco\") %>%\n  # se marcha si no es atendido en 5 minutos\n  renege_in(\n    5,\n    out=trajectory() %>%\n      log_(\"He colmado mi paciencia. Me voy...\")) %>%\n  seize(\"empleado\",1) %>%\n  # me quedo si soy atendido en 5 minutos\n  renege_abort() %>%\n  log_(\"Me están atendiendo\") %>%\n  timeout(10) %>%\n  release(\"empleado\",1) %>%\n  log_(\"He terminado\")\n\nsimmer() %>%\n  add_resource(\"empleado\",1) %>%\n  add_generator(\"cliente\",banco,at(0,1)) %>%\n  run() %>%\n  invisible## 0: cliente0: He llegado al banco\n## 0: cliente0: Me están atendiendo\n## 1: cliente1: He llegado al banco\n## 6: cliente1: He colmado mi paciencia. Me voy...\n## 10: cliente0: He terminado"},{"path":"simmerunidad.html","id":"ejemplos","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.14 Ejemplos","text":"El concepto de trayectoria desarrollado en simmer da lugar un modo natural de simular una amplia variedad de problemas relacionados con Cadenas de Markov continuas en el tiempo (CTMC), procesos de nacimiento-muerte y sistemas de colas.","code":""},{"path":"simmerunidad.html","id":"proceso-industrial","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.14.1 Proceso industrial","text":"Utilizamos la ilustración de un proceso industrial de Pidd (1988), Section 5.3.1, base de la introducción del artículo de Ucar et al (2019), en el que describe de modo completo la simulación del proceso con simmer, y que traducimos y comentamos continuación.Consideramos un negocio de trabajos de ingeniería, en la que hay varias máquinas idénticas. Cada máquina es capaz de procesar cualquier trabajo que llegue. Hay un suministro de trabajos sin perspectivas de escasez. Los trabajos se asignan la primera máquina disponible. El tiempo en completar un trabajo es variable, pero depende de la máquina que se utilice. Las máquinas están cargo de los operarios, que las revisa y realizan una serie de tareas sobre ellas.El proceso está pues constituido por dos tipos de recursos:máquinas, las que llegan trabajos (jobs)operarios, los que llegan tareas (tasks)Respecto cómo ocupan su tiempo de operatividad, distinguimos entre estados y actividades. Estas últimas se refieren tareas que conllevan cierto tiempo para ser completadas. En la FiguraLas actividades que realizan los operarios son:RESET: resetear/reinicializar la máquina, si muestra desgaste que afecte su funcionalidadRETOOL: reparar la máguina si aprecia algún desgaste que afecta al funcionamiento.\nDespués de una reparación (RETOOL) y antes de reiniciar el trabajo, toda máquina ha de ser reinicializada (RESET).AWAY: salir un rato para atender sus necesidades personales.La actividad que llevan cabo las máquinas es la propia realización del trabajo (RUNNING).Se pueden identificar dos clases de procesos o fuentes de llegadas, que generan:los trabajos de tienda (shop jobs), que usan las máquinas y las desgastan,las tareas personales que realizan los operarios que se ausentan (AWAY).En la Figura 1 está representado el flujo de trabajo de este sistema basado en máquinas (la izquierda) y operarios (la derecha). En círculos los estados posibles de los recursos y en rectángulos las actividades completar.\nFigura 7.3: Figura 1. Ciclo de trabajo del sistema descrito en Pidd (1988)\nLa forma de simular este sistema con simmer consiste en considerar las máquinas y operarios como recursos y describir como trayectorias los ciclos de los trabajos de tienda y de las tareas personales.En primer lugar inicializamos un nuevo entorno de simulación y definimos el tiempo de compleción de las diferentes actividades, que vamos definir según distribuciones exponenciales. Asímismo, se definen los tiempos entre llegadas para los trabajos y las tareas, con NEW_JOB y NEW_TASK respectivamente. Consideraremos también una probabilidad 0.2 para que una máquina haya de ser reparada después de hacer un trabajo (CHECK_WORN).La trayectoria de un trabajo (‘job’) que llega la tienda, empieza por ocupar (seize) una máquina que está preparada (estado READY). La máquina opera durante cierto tiempo aleatorio (RUNNING) en el que está resolviendo un trabajo. Cuando la máquina finaliza este tiempo, se chequea (CHECK_WORN) para comprobar si hay que cambiar piezas o . El chequeo se realiza través de una ramificación en la que si hay que reparar (con probabilidad 0.2), la máquina accede la reparación que lleva cabo el operario durante un tiempo RETOOL; si , continua con la reinicialización durante un tiempo RESET, también desarrollada por el operario. Finaliza el servicio con la compleción del trabajo del operario y del trabajo de la máquina.Por otro lado, las tareas personales que realizan los operadores, los mantienen ocupados durante un tiempo AWAY.Una vez que han sido definidas las trayectorias de los procesos, de las máquinas y de los operarios, dimensionamos el sistema con 10 máquinas idénticas y 5 operarios, y creamos también un generador de trabajos (jobs) y otro de tareas personales (tasks). Dejamos correr el sistema durante 1000 unidades de tiempo.El simulador monitoriza en pantalla todos los cambios de estado y tiempos de vida de todos los procesos, lo que nos permite realizar cualquier tipo de análisis sin demasiado esfuerzo adicional.\nPor ejemplo, podríamos extraer el histórico de los estados de los recursos para analizar el número medio de máquinas/operarios utilizados, así como el número de trabajos/tareas esperando ser asignados.","code":"\n# inicializamos una semilla para reproducir siempre las mismas simulaciones\nset.seed(1234)\n# e inicializamos el entorno de simulación\nenv=simmer(\"JobShop\")\n\n# Definimos cómo se simularán los tiempos de las actividades\nRUNNING=function() rexp(1,1)\nRETOOL= function() rexp(1,2)\nRESET= function() rexp(1,3)\nAWAY= function() rexp(1,1)\n# chequeo de desgaste y necesidad de reparación\nCHECK_WORN=function() runif(1)<0.2 # da FALSE/TRUE\n# y las llegadas de trabajos y tareas personales\nNEW_JOB=function() rexp(1,5)\nNEW_TASK=function() rexp(1,1)\njob=trajectory() %>%\n  seize(\"máquina\") %>%\n  timeout(RUNNING) %>%\n  branch(\n    CHECK_WORN, continue=TRUE, \n      trajectory() %>%\n        seize(\"operario\") %>%\n        timeout(RETOOL) %>%\n        release(\"operario\")\n  ) %>%\n  seize(\"operario\") %>%\n  timeout(RESET) %>%\n  release(\"operario\") %>%\n  release(\"máquina\")\n\ntask=trajectory() %>%\n  seize(\"operario\") %>%\n  timeout(AWAY) %>%\n  release(\"operario\")\nenv %>%\n  add_resource(\"máquina\",10) %>%\n  add_resource(\"operario\",5) %>%\n  add_generator(\"job\",job,NEW_JOB)%>%\n  add_generator(\"task\",task,NEW_TASK) %>%\n  run(until=1000) %>%\n  invisible\naggregate(cbind(server,queue)~resource, get_mon_resources(env),mean)##   resource   server     queue\n## 1  máquina 7.987438 1.0355590\n## 2 operario 3.505732 0.4441298"},{"path":"simmerunidad.html","id":"sistemas-de-colas","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.14.2 Sistemas de colas","text":"Veamos cómo implementar con simmer una cola M/M/1 según el ejemplo mostrado en FishyOperations, 2016. Las viñetas de simmer incluyen más ejemplos de sistemas M/M/c/k (Ucar, 2020a), redes de colas y modelos de Markov de tiempo continuo CTMC (Ucar, 2020b).En la notación de Kendall (Kendall, 1953), un sistema M/M/1 tiene una distribución de llegadas exponencial con media \\(\\lambda\\), (M/M/1), un único servidor (M/M/1), y un tiempo de servicio exponencial de media \\(\\mu\\), (M/M/1). Por ejemplo, la gente llega un cajero automático aproximadamente cada \\(\\lambda\\) minutos, espera su turno en la calle y saca dinero durante aproximadamente \\(\\mu\\) minutos. Se definen entonces los parámetros básicos del sistema cuando \\(\\rho<1\\) (para que se sature el sistema):utilización del servidor, \\(\\rho=\\lambda/\\mu\\)promedio de clientes en el sistema (cola y cajero), \\(N=\\rho/(1-\\rho)\\)tiempo medio en el sistema (ley de Little), \\(T=N/\\lambda\\).Si \\(\\rho>1\\), el sistema es inestable pues hay más llegadas de las que el servidor es capaz de gestionar y la cola crecerá indefinidamente.La simulación de este sistema con simmer es muy sencilla.Después de la especificación de los parámetros (\\(\\lambda\\), \\(\\mu\\)), el primer bloque de código define la trayectoria: cada llegada será asignada al recurso, sacará dinero durante un tiempo variable que responderá una distribución exponencial con media \\(\\mu\\) y dejará el cajero.El segundo bloque de código hace una instancia al entorno de simulación, crea el recurso, define el generador de llegadas de clientes y lanza la simulación durante 2000 unidades de tiempo.continuación visualizamos los datos simulados de funcionamiento del sistema. En el primer gráfico, la evolución temporal de los recursos: cola y servidor. En el segundo gráfico el tiempo de espera lo largo del periodo de simulación, y en el tercer gráfico el tiempo de servicio lo largo del periodo de simulación.Si queremos inferir sobre el funcionamiento del sistema largo plazo, necesitaremos muestras, obtenidas de varias réplicas. La replicación es recomendable llevarla cabo con la librería parallel, que permite lanzar en paralelo varias réplicas simultáneas.Al recuperar las llegadas con get_mon_arrivals, obtenemos un data.frame con todas las llegadas, el instante de llegada (start_time) y salida (end_time), así como el tiempo en servicio -sin contar espera- (activity_time), un indicador de si ha finalizado la actividad (finished) y un índice de replicación (replication).Con varias réplicas podríamos, por ejemplo, calcular el tiempo medio en el sistema (end_time-start_time), y con todas las medias, testar si el tiempo medio es superior o inferior cualquier valor que marquemos, utilizando en este caso un test t-Student:O estudiar la utilización de los recursos,O incluso testar si el tamaño de la cola (o de sujetos en el sistema) ha sido cero (o cualquier otro valor),","code":"\nset.seed(1234)\nlambda=2\nmu=4\nrho=lambda/mu\n\nmm1.cajero=trajectory() %>%\n  seize(\"cajero\",amount=1) %>%\n  timeout(function() rexp(1,mu)) %>%\n  release(\"cajero\",amount=1)\n\nmm1.env=simmer() %>%\n  add_resource(\"cajero\",capacity=1,queue_size=Inf) %>%\n  add_generator(\"cliente\",mm1.cajero,function() rexp(1,lambda)) %>%\n  run(until=2000) \nresources=get_mon_resources(mm1.env)\narrivals=get_mon_arrivals(mm1.env)\nplot(resources, metric=\"usage\", \"cajero\", items = c(\"server\",\"queue\"))\nplot(arrivals, metric=\"waiting_time\")## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\nplot(arrivals, metric=\"activity_time\")## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\n#library(parallel)\nmm1.envs=mclapply(1:100,function(i) { \n     simmer() %>%\n        add_resource(\"cajero\",capacity=1,queue_size=Inf) %>%\n        add_generator(\"cliente\",mm1.cajero,function() rexp(100,lambda)) %>%\n        run(until=1000/lambda) %>%\n       wrap()\n     }, mc.set.seed=FALSE)\nmm1.arrivals=get_mon_arrivals(mm1.envs) \nhead(mm1.arrivals)##       name start_time  end_time activity_time finished replication\n## 1 cliente0  0.3373840 0.3988817    0.06149772     TRUE           1\n## 2 cliente1  0.8873295 1.0936262    0.20629668     TRUE           1\n## 3 cliente2  1.0175261 1.3095587    0.21593254     TRUE           1\n## 4 cliente3  1.2768201 1.7538044    0.44424568     TRUE           1\n## 5 cliente4  1.6875986 1.9712527    0.21744829     TRUE           1\n## 6 cliente5  1.8805297 2.1871458    0.21589316     TRUE           1\nmm1.data=get_mon_arrivals(mm1.envs) %>%\n  group_by(replication) %>%\n  summarise(m=mean(end_time-start_time))\nggplot(mm1.data,aes(x=replication,y=m))+\n  geom_point()+\n  geom_line()\nt.test(mm1.data$m,mu=0.5,alternative =\"greater\")## \n##  One Sample t-test\n## \n## data:  mm1.data$m\n## t = -0.51444, df = 99, p-value = 0.696\n## alternative hypothesis: true mean is greater than 0.5\n## 95 percent confidence interval:\n##  0.4906473       Inf\n## sample estimates:\n## mean of x \n## 0.4977877\nmm1.resources=get_mon_resources(mm1.envs)\nplot(mm1.resources, metric=\"utilization\")\nmm1.data=get_mon_resources(mm1.envs) %>%\n  group_by(replication) %>%\n  summarise(n.cola=mean(queue),n.sistema=mean(system))\nggplot(mm1.data,aes(x=replication,y=n.cola))+\n  geom_point()+\n  geom_line()+\n  geom_point(aes(y=n.sistema),color=\"blue\")+\n  geom_line(aes(y=n.sistema),color=\"blue\")+\n  labs(x=\"Replicación\",y=\"Usuarios\",caption=\"Figura x. Usuarios en cola (negro) y en el sistema (azul).\")\nt.test(mm1.data$n.cola,mu=0,alternative = \"greater\")## \n##  One Sample t-test\n## \n## data:  mm1.data$n.cola\n## t = 72.742, df = 99, p-value < 2.2e-16\n## alternative hypothesis: true mean is greater than 0\n## 95 percent confidence interval:\n##  0.7300316       Inf\n## sample estimates:\n## mean of x \n## 0.7470844\nt.test(mm1.data$n.sistema,mu=1,alternative = \"greater\")## \n##  One Sample t-test\n## \n## data:  mm1.data$n.sistema\n## t = 44.214, df = 99, p-value < 2.2e-16\n## alternative hypothesis: true mean is greater than 1\n## 95 percent confidence interval:\n##  1.477677      Inf\n## sample estimates:\n## mean of x \n##  1.496315"},{"path":"simmerunidad.html","id":"gasolinera","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.14.3 Gasolinera","text":"El ejemplo de la gasolinera es ofrecido en Ucar (2020b) como una ejemplificación de un proceso de cadena de markov continuo en el tiempo.\nUna gasolinera tiene un único surtidor y dispone de espacio de espera para los vehículos (si un vehículo llega mientras otro está utilizando el surtidor, ha de marcharse). Los vehículos llegan la gasolinera según un proceso de Poisson de razón \\(\\lambda=3/20\\) vehículos por minuto. De los vehículos que llegan, el 75% son coches y el resto motocicletas. El tiempo de carga de combustible responde una distribución exponencial con media 8 minutos para los coches y 3 para las motocicletas.Recordemos que un proceso de Poisson de parámetro \\(\\lambda\\) implica una distribución de Poisson \\(Po(\\lambda t)\\) para el número de usuarios del sistema transcurrido un tiempo \\(t\\) y una distribución \\(Exp(\\lambda)\\) para los tiempos entre llegadas de los usuarios.Puesto que se trata de un proceso continuo en el tiempo, definimos una función que ejecuta el proceso hasta un instante \\(t\\). El único surtidor de la gasolinera constituye el recurso del proceso, con capacidad 1 y tamaño de la cola 0, y las llegadas de vehículos se generan según una distribución \\(Exp(\\lambda)\\). Al producirse una llegada, se deriva al surtidor, especificando amount=1 para provocar que si está ocupado, el vehículo se marcha (es rechazado). Puesto que el tiempo de recarga de combustible depende de si el vehículo es coche o motocicleta, y estos llegan en una proporción 3 1 (75% coches-25% motos), el tiempo de permanencia en el surtidor especificado con timeout se genera con probabilidad 0.75 con una \\(Exp(1/8)\\) y con probabilidad 0.25 con una \\(Exp(1/3)\\). Transcurrido ese tiempo, el vehículo abandona el sistema.Definiendo los valores de los parámetros, hacemos correr el sistema hasta el instante \\(t=5000\\), y visualizamos llegadas y recurso.","code":"\n recarga<- function(t) {\n  vehiculo <- trajectory() %>%\n    seize(\"surtidor\", amount=1) %>%\n    timeout(function() {\n      if (runif(1) < p) rexp(1, mu[1])  # coche\n      else rexp(1, mu[2])               # moto\n    }) %>%\n    release(\"surtidor\", amount=1)\n\nsimmer() %>%\n    add_resource(\"surtidor\", capacity=1, queue_size=0) %>%\n    add_generator(\"vehiculo\", vehiculo, function() rexp(1, lambda)) %>%\n    run(until=t)\n }\nt=5000\nlambda=3/20\nmu=c(1/8,1/3)\np=0.75\n \ngasolinera=recarga(t) \nllegadas=get_mon_arrivals(gasolinera)\nsurtidor=get_mon_resources(gasolinera)\nplot(llegadas, metric=\"activity_time\")## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\nplot(surtidor, \"usage\",\"surtidor\",items=\"system\")+\n  geom_hline(yintercept=0.5)"},{"path":"simmerunidad.html","id":"referencias","chapter":"Unidad 7 Simulación DES con simmer","heading":"7.15 Referencias","text":"Bache SM, Wickham H (2014). magrittr: Forward-Pipe Operator R. R package version 1.5. Available https://CRAN.R-project.org/package=magrittr.Banks J (2005). Discrete-Event System Simulation. Prentice-Hall International Series Industrial Systems Engineering. Pearson Prentice Hall.Canadilla, P. (2019). Analysis Queueing Networks Models. Package ‘queueing.’ Available https://cran.r-project.org/web/packages/queueing/.Chubaty , McIntire EJB (2019). SpaDES: Develop Run Spatially Explicit Discrete Event Simulation Models. R package version 2.0.3. Available https://CRAN.R-project.org/package=SpaDES.Ebert (2018). queuecomputer: Computationally Efficient Queue Simulation. R package version 0.8.3. Available https://CRAN.R-project.org/package=queuecomputer.Ebert , Wu P, Mengersen K, Ruggeri F (2017). Computationally Efficient Simulation Queues: R Package queuecomputer.” arXiv:1703.02151. ArXiv.org E-Print Archive. Available http://arxiv.org/abs/1703.02151.FishyOperations R-Bloggers (2016). Simulating queueing systems simmer. Available https://www.r-bloggers.com/2016/04/simulating-queueing-systems--simmer/.Kendall DG (1953). Stochastic Processes Occurring Theory Queues Analysis Method Imbedded Markov Chain.” Annals Mathematical Statistics, 24(3), 338-354. Available https://doi.org/10.1214/aoms/1177728975.Lauwens B (2017). SimJulia.jl: Combined Continuous-Time / Discrete-Event Process Ori-ented Simulation Framework Written Julia. Julia package version 0.5. Available https://github.com/BenLauwens/SimJulia.jl.Law , Kelton WD (2000). Simulation Modeling Analysis. McGraw-Hill Series \nIndustrial Engineering Management Science. McGraw-Hill.Pidd M (1988). Computer Simulation Management Science. John Wiley & Sons.Shannon RE (1975). Systems Simulation: Art Science. Prentice-Hall.Team SimPy (2017). SimPy: Discrete-Event Simulation Python. Python package version\n3.0.9. Available https://simpy.readthedocs.io/en/stable.Ucar, ., Smeets, B., Azcorra, . (2019). “simmer: Discrete-Event\nSimulation R.” Journal Statistical Software, 90(2), 1-30.\nAvailable https://doi.org/10.18637/jss.v090.i02.Ucar, ., Smeets, B. (2019a). simmer: Discrete-Event Simulation R. R package version 4.3.0. Available https://CRAN.R-project.org/package=simmer.Ucar, ., Smeets, B. (2019b). simmer.plot: Plotting Methods simmer. R package version 0.1.15. Available https://CRAN.R-project.org/package=simmer.plot.Ucar, ., Smeets, B. (2020c) simmer: DES R. Available https://r-simmer.org/. Documentation available https://r-simmer.org/reference/.Ucar, . (2020a). Queueing systems, simmer: DES R. Available https://r-simmer.org/articles/simmer-06-queueing.html.Ucar, . (2020b). Continuous-Time Markov Chains, simmer: DES R. Available https://r-simmer.org/articles/simmer-07-ctmc.html.","code":""},{"path":"bibliografía.html","id":"bibliografía","chapter":"Bibliografía","heading":"Bibliografía","text":"","code":""}]
